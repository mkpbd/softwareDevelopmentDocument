


Adding an attribute
To add an attribute to our page, we can use the attribute directive:
@attribute [Authorize]


[Authorize] public partial class SomeClass {}

Adding an interface
To implement an interface (IDisposable in this case), we would use the following code:
@implements IDisposable


public partial class SomeClass : IDisposable {}


Inheriting
To inherit another class, we should use the following code:
@inherits TypeNameOfClassToInheritFrom

To do the same in a code-behind scenario, we would add the class we want to inherit from after
the class name:
public class SomeClass : TypeNameOfClassToInheritFrom {}



Generics
We can define our component as a generic component.
Generics allow us to define the data type, so the component works with any data type.
To define a component as a generic component, we add the ```@typeparam``` directive; then, we can
use the type in the code of the component like this:

```c#
@typeparam TItem
@code
{
[Parameter]
public List<TItem> Data { get; set; }
}
```

Changing the layout

```c#
@layout AnotherLayout
```
This way, our component will use the specified layout (this only works for components with the
```
@page
``` 
directive).

Setting a namespace
By default, the component’s namespace will be the name of the default namespace of our project,
plus the folder structure.

```
@namespace Another.NameSpace
```
Setting a route
We have already touched on the @page directive. If we want our component to be directly accessed
using a URL, we can use the @page directive:

```
@page "/theurl"
```
Adding a using statement

To add a namespace to our component, we can use the @using directive:

```
@using System.IO
```

Understanding dependency injection
DI is a software pattern and a technique to implement Inversion of Control (IoC).
IoC is a generic term that means we can indicate that the class needs a class instance instead of
letting our classes instantiate an object. We can say that our class wants either a specific class
or a specific interface.

```c#
//Program.cs:
builder.Services.AddScoped<IBlogApi, BlogApiJsonDirectAccess>();
```
We can configure the creation of objects in different ways, such as the following:
• Singleton
• Scoped
• Transient

``` c#
services.AddSingleton<IWeatherForecastService, WeatherForecastService>();
services.AddScoped<IWeatherForecastService, WeatherForecastService>();

services.AddTransient<IWeatherForecastService, WeatherForecastService>();
```

## Injecting the service

``` c#
@inject WeatherForecastService ForecastService
[Inject]
public WeatherForecastService ForecastService { get; set; }
```

The third way is for when we want to inject a service into another service – then, we need to inject
the services using the constructor:

```c#
public class MyService
{
public MyService(WeatherForecastService
weatherForecastService)
{
}
}
```
