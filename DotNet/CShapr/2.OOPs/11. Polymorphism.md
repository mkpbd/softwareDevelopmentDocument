
##### **What is Polymorphism in C#?**

Polymorphism is one of the fundamental OOP concepts and is a term used to describe situations where something takes various roles or forms. In the programming world, these things can be operators or functions.

The word polymorphism is derived from two Greek words: poly and morphs. The word “Poly” means many, and “morphs” means forms. Therefore, polymorphism means “many forms” or we can say that the word polymorphism means the ability to take more than one form. That is one thing that can take many forms.

Polymorphism is a concept by which we can perform a single task in different ways. That is, when a single entity behaves differently in different cases, it is called polymorphism in C#. The term polymorphism is an object-oriented programming term that means a function or an operator behaves differently in different scenarios.

Technically, we can say that when a function shows different behaviors when we pass different types and numbers of input values, then it is called Polymorphism in C#. So, behaving in different ways depending on the input received is known as polymorphism, i.e., whenever the input changes, automatically, the output or the behavior also changes.

We can achieve flexibility in our code using polymorphism because we can perform various operations by using methods with the same names according to our business requirements. Let’s understand Polymorphism with some real-time examples.


##### **Example1:**

Suppose you are in a classroom, then at that time, you will behave like a student. But when you are in the shopping mall, at that time you will behave like a customer. Again, when you are traveling on a bus, then you will behave like a passenger. And when you are at your home at that time, you will behave like a son or daughter. Here, you are one person but performing different behaviors. This is nothing but polymorphism. The behaviors change based on the place.
![[word-image-29911-1.webp]]

##### **Example2:**

A security guard in an organization behaves differently with different people entering the organization. The security behaves in a different way when the Boss comes and, in another way, when the employees come. And when the customers enter, the same security guard will respond differently. So here, the behavior of the security guard changes from person to person. It depends on the member who is entering the organization.

![[word-image-29911-2.webp]]

##### **Example3:**

Another good real-time example of polymorphism is water. We all know that water is a liquid at normal temperature, but it changes to a solid when it is frozen, and the same water changes to a gas when it is heated at its boiling point. This is also polymorphism.

![[word-image-29911-3-1.webp]]

##### **Example4:**

One of the best real-time examples of polymorphism is Women in society. The same woman performs a different role in society. The woman can be the wife of someone, the mother of her child, can be doing a job in an organization, and many more at the same time. But the Woman is only one. So, the same woman performing different roles is nothing but performing polymorphism.
![[word-image-29911-4-1.webp]]

##### **Types of Polymorphism in C#:**

There are two types of polymorphism in C#. They are as follows:

1. **Static Polymorphism / Compile-Time Polymorphism / Early Binding**
2. **Dynamic Polymorphism / Run-Time Polymorphism / Late Binding**

The following diagram shows different types of polymorphisms in C# with their examples.

![[word-image-29911-5 1.webp]]

The polymorphism in C# can be implemented using the following three ways.

1. [**Method Overloading**](https://dotnettutorials.net/lesson/function-overloading-csharp/)
2. [**Operator Overloading**](https://dotnettutorials.net/lesson/operator-overloading-in-csharp/)
3. [**Method Overriding**](https://dotnettutorials.net/lesson/function-overriding-csharp/)
4. [**Method Hiding**](https://dotnettutorials.net/lesson/function-hiding-csharp/)

**Note:** While working with Polymorphism in C#, we need to understand two things, i.e., what happens at the time of compilation and what happens at the time of execution for a given method call. Is the method going to be executed from the same class at run-time, which is bounded to the class at the compile time, or is the method going to be executed from a different class at run-time rather than the class bounded at compile time?


##### **What is Compile-Time Polymorphism in C#?**

The function call is bounded to the class at the time of compilation; if the function is going to be executed from the same bounded class at run-time, then it is called Compile-Time Polymorphism in C#. This happens in the case of Method Overloading because, in this case, each method will have a different signature, and based on the method call, we can easily recognize the method that matches the method signature.

In static polymorphism, the behavior of a method is decided at compile time. That means the C# compiler binds method calls with method definition/body during compilation time only. Therefore, this type of polymorphism is also called compile-time polymorphism in C#. As the binding (the link between the function call and function definition) is performed at compile time, it is also known as early binding.

##### **Example to Understand Compile Time Polymorphism in C#:**

In the below example, within the Program class, we have defined three overloaded versions of the Add method but with different signatures. In this case, at compilation time only, we will come to know, and the method binding is resolved at runtime, which method is going to be executed. If this is not clear at the moment, then don’t worry; we will discuss this concept in detail in our [**Method Overloading**](https://dotnettutorials.net/lesson/function-overloading-csharp/) article.

```C#
using System;
namespace MethodOverloading
{
    class Program
    {
        public void Add(int a, int b)
        {
            Console.WriteLine(a + b);
        }
        public void Add(float x, float y)
        {
            Console.WriteLine(x + y);
        }
        public void Add(string s1, string s2)
        {
            Console.WriteLine(s1 + " " + s2);
        }
        static void Main(string[] args)
        {
            Program obj = new Program();
            obj.Add(10, 20);
            obj.Add(10.5f, 20.5f);
            obj.Add("Pranaya", "Rout");
            Console.ReadKey();
        }
    }
}
```


##### **What is Runtime Polymorphism in C#?**

In dynamic polymorphism, the behavior of a method is decided at runtime. Therefore, the CLR (Common Language Runtime) binds the method call with the method definition/body at runtime and invokes the relevant method during runtime when the method is called.

The function call is bounded to the class at the time of compilation; if the function is going to be executed from a different class at run-time rather than the class bounded at compilation time, then it is called Run-Time Polymorphism. This happens in the case of Method Overriding because, in this case, we have multiple methods with the same signature, i.e., the Parent Class and the Child class have the same method implementation. So, in this case, we will be able to know at runtime from which class the method is going to be executed.

It is also called Dynamic Polymorphism or Late Binding, as at Run-time, we will be able to know from which class the method is going to be executed.

##### **Example to Understand Dynamic Polymorphism in C#:**

In the below example, we have created one virtual method in class Class1, and we have re-implemented that method inside class Class2. That means the same Show method implementation is available in both Parent and Child classes. In the Main method, we are creating an instance of the child class but storing that instance in the Parent class reference variable; in this case, from which class the Show method to be executed will be decided at runtime only. This is nothing but dynamic polymorphism. If this is not clear at the moment, then don’t worry; we will discuss this concept in detail in our [**Method Overriding**](https://dotnettutorials.net/lesson/function-overriding-csharp/) article.

```C#
using System;
namespace PolymorphismDemo
{
    class Class1
    {
        //Virtual Function (Overridable Method)
        public virtual void Show()
        {
            //Parent Class Logic Same for All Child Classes
            Console.WriteLine("Parent Class Show Method");
        }
    }

    class Class2 : Class1
    {
        //Overriding Method
        public override void Show()
        {
            //Child Class Reimplementing the Logic
            Console.WriteLine("Child Class Show Method");
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Class1 obj1 = new Class2();
            obj1.Show(); //Resolve at Runtime
            
            Console.ReadKey();
        }
    }
}

```

##### **What is Method Overloading or Function Overloading in C#?**

Method Overloading means it is an approach to defining multiple methods under the class with a single name. So, we can define more than one method with the same name in a class. But the point that you need to remember the parameters of all those methods should be different (different in terms of number, type, and order of the parameters).

So, if we are defining multiple methods with the same name but with a different signature in a class or in the Parent and Child Classes, then it is called Method Overloading in C#. That means C#.NET not only allows method overloading in the same class but also allows method overloading in Parent and Child classes. So, we can create a method in the Derived/Child class with the same name as the method name defined in the Base/Parent class in C#.

![[Method-Overloading-in-C.webp]]

```C#
using System;
namespace MethodOverloading
{
    class Program
    {
        static void Main(string[] args)
        {
            Program obj = new Program();
            obj.Method(); //Invoke the 1st Method
            obj.Method(10); //Invoke the 2nd Method
            obj.Method("Hello"); //Invoke the 3rd Method
            obj.Method(10, "Hello"); //Invoke the 4th Method
            obj.Method("Hello", 10); //Invoke the 5th Method

            Console.ReadKey();
        }

        public void Method()
        {
            Console.WriteLine("1st Method");
        }
        public void Method(int i)
        {
            Console.WriteLine("2nd Method");
        }
        public void Method(string s)
        {
            Console.WriteLine("3rd Method");
        }
        public void Method(int i, string s)
        {
            Console.WriteLine("4th Method");
        }
        public void Method(string s, int i)
        {
            Console.WriteLine("5th Method");
        }    
    }
}

```

##### **Why Return Type is not considered as part of Method Overloading in C#?**

Let us understand why return type is not considered as part of method overloading with an example. Please have a look at the following image. Here, I have written two methods with the same name but one method’s return type is void, and the other method’s return type is a string. See, as soon as we create the second method, the compiler itself gives the compile time error saying **Type ‘Program’ already defines a member called ‘Method’ with the same parameter types.**

##### **When should we Overload Methods in C#?**

We have understood what is Method Overloading and how to implement the Method Overloading in C#. But, the important question is when we need to implement or when we need to go for Method Overloading in C#. Let us understand this with an example.

The concept of Method Overloading falls under the Polymorphisms OOPs principle. Object Oriented Programming is based on four principles i.e. Encapsulation, Abstraction, Inheritance, and Polymorphism.

What is Polymorphism? Polymorphism is a mechanism of changing the behavior based on the inputs. That means when the input changes, automatically the output or behavior changes. The best example of polymorphism is ourselves. For example, when we hear something interesting or something which is good for us, we feel happy. And when we hear something which is not good for us, we feel sad. Suppose, you asked your father to purchase a bike, and if your father purchases a bike for you then you will feel happy. And if your father says that I am not going to purchase a bike for you, then you will feel sad. So, you are the same person, when you received something good, you feel happy and when you receive something which is not good, you feel sad. This is called polymorphism. Behaving in different ways based on the input received i.e. whenever the input changes the output automatically changes.

Here, the input changes mean don’t think that the values changes. Input changes mean when we change the number, type, and order of input the values are going to be changed. Don’t think that, if I pass 10, I will get a value, if I pass 20, I will get a different value. For this, if else condition is sufficient, overloading is not required. When you expect the output to be changed based on the number, type, and order of inputs, then only you need to go for Method overloading in C#.

For a better understanding, please have a look at the following example. Here, we have created three methods with the same name to perform the addition of two integers, two floats, and two strings. So, when we give two integer numbers we will get one output and when we provide two string values, then we will get a different output, and similarly, when we give two float numbers we will get another output. That means when the input changes the output or behavior also automatically changes. This is called polymorphism in C#.

```C#
using System;
namespace MethodOverloading
{
    class Program
    {
        public void Add(int a, int b)
        {
            Console.WriteLine(a + b);
        }
        public void Add(float x, float y)
        {
            Console.WriteLine(x + y);
        }
        public void Add(string s1, string s2)
        {
            Console.WriteLine(s1 +" "+ s2);
        }
        static void Main(string[] args)
        {
            Program obj = new Program();
            obj.Add(10, 20);
            obj.Add(10.5f, 20.5f);
            obj.Add("Pranaya", "Rout");
            Console.ReadKey();
        }
    }
}
```
![[What-is-Method-Overloading-or-Function-Overloading-in-C.webp]]

##### **When is a method considered an overloaded method in C#?**

If two methods have the same method name but with different signatures, then those methods are considered overloaded methods. Then the rule we should check is both methods must have different parameter **Types/Numbers/Orders**. But there is no rule on return type, access specifier and access modifier means overloading methods can have their own return type (void, float, int, string, etc), own access specifier (public, private, protected, etc.), and access modifier (sealed, static, virtual, etc.) because overloading methods are different methods


##### **What is Inheritance-Based Method Overloading in C#?**

A method that is defined in the parent class can also be overloaded under its child class. It is called Inheritance Based Method Overloading in C#. See the following example for a better understanding. As you can see in the below code, we have defined the Add method twice in the class Class1 and also defined the Add method in the child class Class1. Here, notice every Add method takes different types of parameters.

```C#
using System;
namespace MethodOverloading
{
    class Class1
    {
        public void Add(int a, int b)
        {
            Console.WriteLine(a + b);
        }
        public void Add(float x, float y)
        {
            Console.WriteLine(x + y);
        }
    }
    class Class2 : Class1
    {
        public void Add(string s1, string s2)
        {
            Console.WriteLine(s1 +" "+ s2);
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            Class2 obj = new Class2();
            obj.Add(10, 20);
            obj.Add(10.5f, 20.7f);
            obj.Add("Pranaya", "Rout");
            Console.ReadKey();
        }
    }
}
```

##### **Example to Understand Constructor Method Overloading in C#**

Please have a look at the following example. Here, we are creating three different versions of the Constructor, and each constructor takes a different number of parameters, and this is called Constructor Overloading in C#.

```C#
using System;
namespace ConstructorOverloading
{
    class ConstructorOverloading
    {
        int x, y, z;
        public ConstructorOverloading(int x)
        {
            Console.WriteLine("Constructor1 Called");
            this.x = 10;
        }
        public ConstructorOverloading(int x, int y)
        {
            Console.WriteLine("Constructor2 Called");
            this.x = x;
            this.y = y;
        }
        public ConstructorOverloading(int x, int y, int z)
        {
            Console.WriteLine("Constructor3 Called");
            this.x = x;
            this.y = y;
            this.z = z;
        }
        public void Display()
        {
            Console.WriteLine($"X={x}, Y={y}, Z={z}");
        }
    }
    class Test
    {
        static void Main(string[] args)
        {
            ConstructorOverloading obj1 = new ConstructorOverloading(10);
            obj1.Display();
            ConstructorOverloading obj2 = new ConstructorOverloading(10, 20);
            obj2.Display();
            ConstructorOverloading obj3 = new ConstructorOverloading(10, 20, 30);
            obj3.Display();
            Console.ReadKey();
        }
    }
}
```

##### **Method Overloading Realtime Example using C# Language:**

```c#
using System;
namespace MethodOverloading
{
    public class Logger
    {
        public static void Log(string ClassName, string MethodName, string Message)
        {
            Console.WriteLine($"DateTime: {DateTime.Now.ToString()}, ClassName: {ClassName}, MethodName:{MethodName}, Message:{Message}");
        }
        public static void Log(string uniqueId, string ClassName, string MethodName, string Message)
        {
            Console.WriteLine($"DateTime: {DateTime.Now.ToString()}, UniqueId: {uniqueId}, ClassName: {ClassName}, MethodName:{MethodName}, Message:{Message}");
        }
        public static void Log(string Message)
        {
            Console.WriteLine($"DateTime: {DateTime.Now.ToString()}, Message: {Message}");
        }
        public static void Log(string ClassName, string MethodName, Exception ex)
        {
            Console.WriteLine($"DateTime: {DateTime.Now.ToString()}, ClassName: {ClassName}, MethodName:{MethodName}, Exception Message:{ex.Message}, \nException StackTrace: {ex.StackTrace}");
        }

        //You create many overloaded versions as per your business requirements
    }
    
    class Program
    {
        static void Main(string[] args)
        {
            string ClassName = "Program";
            string MethodName = "Main";
            string UniqueId = Guid.NewGuid().ToString();
            Logger.Log(ClassName, MethodName, "Message 1");
            Logger.Log(UniqueId, ClassName, MethodName, "Message 2");
            Logger.Log("Message 3");

            try
            {
                int Num1 = 10, Num2 = 0;
                int result = Num1 / Num2;
                Logger.Log(UniqueId, ClassName, MethodName, "Message 4");
            }
            catch(Exception ex)
            {
                Logger.Log(ClassName, MethodName, ex);
            }
            
            Console.ReadKey();
        }
    }
}

```

# Method Overriding

##### **What is Method Overriding in C#?**

The process of re-implementing the superclass non-static, non-private, and non-sealed method in the subclass with the same signature is called Method Overriding in C#. The same signature means the name and the parameters (type, number, and order of the parameters) should be the same. 

##### **When do we need to override a method in C#?**

If the Super Class or Parent Class method logic is not fulfilling the Sub Class or Child Class business requirements, then the Sub Class or Child Class needs to override the superclass method with the required business logic. Usually, in most real-time applications, the Parent Class methods are implemented with generic logic which is common for all the next-level sub-classes.

##### **When is a Sub Class Method treated as an Overriding Method in C#?**

If a method in the sub-class or child class contains the same signature as the superclass non-private, non-static, and non-sealed method, then the subclass method is treated as the overriding method and the superclass method is treated as the overridden method.

##### **How can we Override a Parent Class Method under Child Class in C#?**

If you want to override the Parent class method in its Child classes, first the method in the parent class must be declared as virtual by using the virtual keyword**,** then only the child classes get permission for overriding that method. Declaring the method as virtual is marking the method as overridable. If the child class wants to override the parent class virtual method, then the child class can override it with the help of the override modifier. But overriding the parent class virtual methods under the child classes is not mandatory. The syntax is shown below to implement Method Overriding in C#.

![[word-image-27425-1-8.webp]]

As you can see in the above image, the Show method is declared as a Virtual method in the class Class1. Further Class1 is the Parent class for Class2 and Class2. Class2 overrides the Show method while class does not override the Show method as overriding the virtual method inside a child class is optional.

Suppose, on your birthday, your parents give you a mobile phone. Then your parents tell you, if you like it, it’s OK, you just use it. And if you don’t like the mobile phone, then you can exchange it. So, if you want to exchange it, take the bill, go and exchange the mobile phone. So, you have two options. What are these? The first option, whatever your parent gives you, you just use it. The second option, if you don’t like it, go and exchange and take whatever you like.

This is exactly the same as Method overriding. You have one method in the Parent class, and that method is given to the child class for consumption. Now, if the child class wants then the child class can consume the method else the child class can reimplement the method or override the method. By declaring the Parent method as virtual, it gives permission to the child classes to override the method and the child classes can override the method by using the override modifier.

##### **Example to Understand Method Overriding in C#**

```C#
using System;
namespace PolymorphismDemo
{
    class Class1
    {
        //Virtual Function (Overridable Method)
        public virtual void Show()
        {
            //Parent Class Logic Same for All Child Classes
            Console.WriteLine("Parent Class Show Method");
        }
    }

    class Class2 : Class1
    {
        //Overriding Method
        public override void Show()
        {
            //Child Class Reimplementing the Logic
            Console.WriteLine("Child Class Show Method");
        } 
    }
    
    class Program
    {
        static void Main(string[] args)
        {
            Class1 obj1 = new Class2();
            obj1.Show();

            Class2 obj2 = new Class2();
            obj2.Show();
            Console.ReadKey();
        }
    }
}

```


##### **Overriding the Virtual Method is Optional in C#:**

```C#
using System;
namespace PolymorphismDemo
{
    class Class1
    {
        //Virtual Function (Overridable Method)
        public virtual void Show()
        {
            //Parent Class Logic Same for All Child Classes
            Console.WriteLine("Parent Class Show Method");
        }
    }

    class Class3 : Class1
    {
        //Not Overriding the Virtual Method
    }
    
    class Program
    {
        static void Main(string[] args)
        {
            Class3 obj3 = new Class3();
            obj3.Show();

            Class1 obj4 = new Class3();
            obj4.Show();

            Console.ReadKey();
        }
    }
}

```
##### **How can we execute the superclass method if it is overridden in the sub-class in C#?**

Once we re-implement the parent class methods under the child classes, then the object of the child class calls its own method but not its parent class method. But if you want to still consume or call the parent class’s methods from the child class, then it can be done in two different ways.

By creating the parent class object under the child class, we can call the parent class methods from the child class, or by using the base keyword, we can call parent class methods from the child class, but this and the base keyword cannot be used under the static block.
##### **Using the base keyword to call the Parent Class Methods in C#:**
```C#
using System;
namespace PolymorphismDemo
{
    class Class1
    {
        //Virtual Function (Overridable Method)
        public virtual void Show()
        {
            //Parent Class Logic Same for All Child Classes
            Console.WriteLine("Parent Class Show Method");
        }
    }

    class Class2 : Class1
    {
        //Overriding Method
        public override void Show()
        {
            base.Show(); //Calling Parent Class Show method
            Console.WriteLine("Child Class Show Method");
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Class1 obj1 = new Class2();
            obj1.Show();

            Class2 obj2 = new Class2();
            obj2.Show();
            Console.ReadKey();
        }
    }
}

```

##### **Calling Parent Class Methods by creating the Parent Class Object under the Child Class:**

Let us see an example for a better understanding of how to create the parent class object and call the parent class methods from the child class method. As you can see in the below example, from the child class Show method, we are creating an instance of the Parent class and calling the Parent Class Show method.


```C#
using System;
namespace PolymorphismDemo
{
    class Class1
    {
        public virtual void Show()
        {
            Console.WriteLine("Parent Class Show Method");
        }
    }

    class Class2 : Class1
    {
        public override void Show()
        {
            //Creating an instance of Parent Class
            Class1 class1 = new Class1();
            //Calling Parent Class Show method
            class1.Show(); 
            Console.WriteLine("Child Class Show Method");
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Class1 obj1 = new Class2();
            obj1.Show();

            Class2 obj2 = new Class2();
            obj2.Show();
            Console.ReadKey();
        }
    }
}

```

##### **Method Overriding Real-Time Example in C#**

We need to develop an application to calculate bonuses based on the designation of the Employees. The management team has decided to give 50000 as a fixed bonus or based only salary they may get 20% or 25% as bonus whichever is higher. Here, we are taking the example of three different designations, but you can take as many as per your requirement.

1. If the designation is Developer, then the employee gets either 50000 or 20% of the Salary as a bonus (whichever is higher).
2. If the designation is Manager, then the employee gets either 50000 or 25% of the Salary as a bonus (whichever is higher).
3. If the designation is Admin, then the employee will get a fixed 50000 as a bonus.

The following example code does the same as per our requirement.

```C#
using System;
namespace MethodOverriding
{
    public class Employee
    {
        public int Id { get; set; }
        public string Name { get; set; }
        public string Designation { get; set; }
        public double Salary { get; set; }

        public virtual double CalculateBonus(double Salary)
        {
            return 50000;
        }
    }

    public class Developer : Employee
    {
        //50000 or 20% Bonus to Developers which is greater
        public override double CalculateBonus(double Salary)
        {
            double baseSalry = base.CalculateBonus(Salary);
            double calculatedSalary = Salary * .20;
            if (baseSalry >= calculatedSalary)
            {
                return baseSalry;
            }
                
            else
            {
                return calculatedSalary;
            }
        }
    }

    public class Manager : Employee
    {
        //50000 or 25% Bonus to Developers which is greater
        public override double CalculateBonus(double Salary)
        {
            double baseSalry = base.CalculateBonus(Salary);
            double calculatedSalary = Salary * .25;
            if (baseSalry >= calculatedSalary)
            {
                return baseSalry;
            }
            else
            {
                return calculatedSalary;
            }
        }
    }

    public class Admin : Employee
    {
        //return fixed bonus 50000
        //no need to overide the method
    }

    class Program
    {
        static void Main(string[] args)
        {
            Employee emp1 = new Developer
            {
                Id = 1001,
                Name = "Ramesh",
                Salary = 500000,
                Designation = "Developer"
            };
            double bonus = emp1.CalculateBonus(emp1.Salary);
            Console.WriteLine($"Name: {emp1.Name}, Designation: {emp1.Designation}, Salary: {emp1.Salary}, Bonus:{bonus}");
            Console.WriteLine();

            Employee emp2 = new Manager
            {
                Id = 1002,
                Name = "Sachin",
                Salary = 800000,
                Designation = "Manager"
            };
            bonus = emp2.CalculateBonus(emp2.Salary);
            Console.WriteLine($"Name: {emp2.Name}, Designation: {emp2.Designation}, Salary: {emp2.Salary}, Bonus:{bonus}");
            Console.WriteLine();

            Employee emp3 = new Admin
            {
                Id = 1003,
                Name = "Rajib",
                Salary = 300000,
                Designation = "Admin"
            };
            bonus = emp3.CalculateBonus(emp3.Salary);
            Console.WriteLine($"Name: {emp3.Name}, Designation: {emp3.Designation}, Salary: {emp3.Salary}, Bonus:{bonus}");
            Console.WriteLine();

            Employee emp4 = new Developer
            {
                Id = 1004,
                Name = "Priyanka",
                Salary = 200000,
                Designation = "Developer"
            };
            bonus = emp1.CalculateBonus(emp4.Salary);
            Console.WriteLine($"Name: {emp4.Name}, Designation: {emp4.Designation}, Salary: {emp4.Salary}, Bonus:{bonus}");
            
            Console.Read();
        }
    }
}

```

##### **What is the difference between Method Overloading and Method Overriding in C#?**

###### **Method Overloading in C#**

1. It is an approach to defining multiple methods with the same name but with a different signature means by changing the number, type, and order of parameters.
2. Overloading a method can be performed within a class as well as between the Parent-Child classes also.
3. To overload a parent class method under the child classes, the child class does not require to take any permission from the parent.
4. This is all about defining multiple behaviors to a method.
5. Used to implement static polymorphism.
6. No separate keywords are used to implement function overloading.

###### **Method Overriding in C#**

1. It is an approach to defining multiple methods with the same name and with the same signature means the same number, type, and order of parameters.
2. Overriding of methods is not possible within the same class it must be performed under the child classes only.
3. To override a parent class method under the child classes, first, the child class requires to take permission from its parent.
4. This is all about changing the behavior of a method.
5. Used to implement dynamic polymorphism.
6. Use the virtual keyword for the base class function and override keyword in the derived class function to implement function overriding.


# Method Hiding

##### **What is Method Hiding in C#?**

Method Overriding is an approach of re-implementing the parent class methods under the child class exactly with the same signature (same name and same parameters).

Method Hiding/Shadowing is also an approach of re-implementing the parent class methods under the child class exactly with the same signature (same name and same parameters).

##### **How we can Re-Implement a Parent Method in the Child Class in C#?**

We can re-implement the parent class methods under the child classes in two different approaches. They are as follows

1. **Method Overriding**
2. **Method Hiding**

Then what are the differences between them, let us understand.

In Method Overriding, the child classes re-implement their parent class methods which are declared as virtual. That means here, the child classes re-implement the parent class methods with the permission of the parent class because here in the parent class the method is declared as virtual giving permission to the child classes for overriding the methods using the override modifier.

In Method Hiding/Shadowing, the child classes can re-implement any method of its parent class methods even if they are not declared as virtual. That means here the child class re-implements the parent class methods without taking any permission from its parent.

##### **How to Implement Method Hiding/Shadowing in C#?**

Please have a look at the following image to understand the syntax of Method Hiding/Shadowing in C#. It does not matter whether the parent class method is virtual or not. We can hide both virtual and non-virtual methods under the child class. Again, we can hide the method in the child class in two ways i.e. by using the new keyword and also, without using the new keyword. If we are not using the new keyword then we will get a warning and the reason for the warning we will discuss later part of this article.


![[word-image-27425-1-9.webp]]

##### **Example to Understand Method Hiding/Shadowing in C#:**

```C#
using System;
namespace MethodHiding
{
    public class Parent
    {
        public virtual void Show()
        {
            Console.WriteLine("Parent Class Show Method");
        }
        public void Display()
        {
            Console.WriteLine("Parent Class Display Method");
        }
    }
    public class Child : Parent
    {
        
    }
    class Program
    {
        static void Main(string[] args)
        {
            Child obj = new Child();
            obj.Show();
            obj.Display();
            Console.ReadKey();
        }
    }
}

```
So, here, you can observe both Method Overriding and Method Hiding doing the same thing. That is re-implementing the Parent class methods under the Child class. Then what are the differences between them? With method overriding, you can re-implement only virtual methods. On the other hand, with Method Hiding, you can re-implement any methods.

For a better understanding, please have a look at the following example. Here, inside the Parent class, we have declared defined two virtual methods and two non-virtual methods. Inside the Child class, we are re-implementing both virtual and non-virtual methods using both Method Overriding and Method Hiding. Here, you will get a compile-time error while you are trying to re-implement the non-virtual method using the override modifier but you will not get an error when you are re-implementing the virtual and non-virtual method using the new keyword.
```C#
using System;
namespace MethodHiding
{
    public class Parent
    {
        public virtual void Method1()
        {
            Console.WriteLine("Parent Class Method1 Method");
        }
        public void Method2()
        {
            Console.WriteLine("Parent Class Method2 Method");
        }
        public virtual void Method3()
        {
            Console.WriteLine("Parent Class Method3 Method");
        }
        public void Method4()
        {
            Console.WriteLine("Parent Class Method4 Method");
        }
    }
    public class Child : Parent
    {
        //Overriding Virtual Method
        //Method Overriding
        public override void Method1()
        {
            Console.WriteLine("Child Class Method1 Method");
        }

        //Overriding Non-Virtual Method
        //Not Possible. Compile Time Error
        public override void Method2()
        {
            Console.WriteLine("Child Class Method2 Method");
        }
        
        //Method Hiding/Shadowing Virtual Method
        public new void Method3()
        {
            Console.WriteLine("Child Class Method3 Method");
        }

        //Method Hiding/Shadowing Non-Virtual Method
        public new void Method4()
        {
            Console.WriteLine("Child Class Method4 Method");
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            Child obj = new Child();
            obj.Method1();
            obj.Method2();
            obj.Method3();
            obj.Method4();
            Console.ReadKey();
        }
    }
}

```

##### **How to Invoke the Parent class Methods from the Child Class re-implemented methods?**

In C#, we can re-implement the Parent class methods under the child class in two ways. They are as follows:

1. **Method Overriding**
2. **Method Hiding**

In the first case, with permission, and in the second case, without permission. In Method Overriding and Method Hiding, after performing the re-implementation, a call to the method by using the child class instance always invokes the local methods i.e. child class methods. For a better understanding, please have a look at the following example. Here, we create an instance of the Child class and then invoke both the methods, and in this case, both the methods are going to be executed from the Child class only.

```c#
using System;
namespace MethodHiding
{
    public class Parent
    {
        public virtual void Show()
        {
            Console.WriteLine("Parent Class Show Method");
        }
        public void Display()
        {
            Console.WriteLine("Parent Class Display Method");
        }
    }
    public class Child : Parent
    {
        //Method Overriding
        public override void Show()
        {
            Console.WriteLine("Child Class Show Method");
        }
        
        //Method Hiding/Shadowing
        public new void Display()
        {
            Console.WriteLine("Child Class Display Method");
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            Child obj = new Child();
            obj.Show();
            obj.Display();
            Console.ReadKey();
        }
    }
}

```

After re-implementing the Parent classes methods under the child classes, the child class instance will start calling the local methods only i.e. the re-implemented methods, but if required in any case we can also call the Parent class methods from the child classes by using two approaches.

1. **Using the Parent Class Instance**
2. **Using the base keyword**

So, by creating the parent class object under the child class, we can call the parent class methods from the child class, or by using the base keyword, we can also call parent class methods from the child class, but the keyword like this and base cannot be used under the static block.

```C#
using System;
namespace MethodHiding
{
    public class Parent
    {
        public virtual void Show()
        {
            Console.WriteLine("Parent Class Show Method");
        }
        public void Display()
        {
            Console.WriteLine("Parent Class Display Method");
        }
    }
    public class Child : Parent
    {
        //Method Overriding
        public override void Show()
        {
            //Using Parent class instance to Invoke the Parent Methods
            Parent parent = new Parent();
            parent.Show();

            //Using base keyword to invoke the Parent method
            base.Display();
            Console.WriteLine("Child Class Show Method");
        }
        
        //Method Hiding/Shadowing
        public new void Display()
        {
            //Using Parent class instance to Invoke the Parent Methods
            Parent parent = new Parent();
            parent.Display();

            //Using base keyword to invoke the Parent method
            base.Show();
            Console.WriteLine("Child Class Display Method");
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            Child obj = new Child();
            obj.Show();
            obj.Display();
            Console.ReadKey();
        }
    }
}

```

##### **Differences Between Method Overriding and Method Hiding in C#:**

As of now, we have not found any major differences between Method Overriding and Method Hiding in C#. There are some differences in terms of implementation, but from the execution point of view, when we invoked the methods using the child class instance, then both the methods are going to be executed from the child class. Then what is the major difference between them, let us try to understand.

Can we create a Parent class reference variable using the Child class instance in C#? Yes, it is possible and we have already discussed this in our Inheritance article. So, a Parent class reference variable can hold the child class object reference.

For a better understanding, please have a look at the following example. Here, we are creating an instance of the Child class and storing that instance reference in the Parent class reference variable, and then invoking the two methods.

```C#
using System;
namespace MethodHiding
{
    public class Parent
    {
        public virtual void Show()
        {
            Console.WriteLine("Parent Class Show Method");
        }
        public void Display()
        {
            Console.WriteLine("Parent Class Display Method");
        }
    }
    public class Child : Parent
    {
        //Method Overriding
        public override void Show()
        {
            Console.WriteLine("Child Class Show Method");
        }
        
        //Method Hiding/Shadowing
        public new void Display()
        {
            Console.WriteLine("Child Class Display Method");
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            Parent obj = new Child();
            obj.Show();
            obj.Display();
            
            Console.ReadKey();
        }
    }
}

```

![[word-image-27425-9-8.webp]]

