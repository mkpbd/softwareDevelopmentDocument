
Most people will say that everything that you can see and touch in the world is an object and there is a class for it.  Classes come from classification. We define classes in our daily life. Any 4-wheeler vehicle in which there is a driver and some people are sitting at the back or beside the driver, then we say it’s a car. So, this is the classification depending on the property we are defining.

There’s a class human and you are an object of human being class. The BMW is a car and Toyota is also a car. These are the objects of class cars. So, class is a definition and objects are instances.

Design is nothing but the blueprint of the house object. So, the house will be having all those things that are defined in the design plan or in the blueprint.

So, every engineer does some paperwork or designing work, and based on that design the manufacturing is done. When you make a product, that product will be having all those things that are there in the design and you can then make many products based on that design.

A car company will design a new car. Then they will manufacture many cars based on that design. So, all those cars are objects and the design that the company is holding with them is a class. In the same way, we also want to write a class and create objects in our program.


##### **Class and Objects from Programming Language Point of View.**

###### **Class:**

A class is simply a user-defined data type that represents both state (variable or property  which contain data ) and behavior (method or action ). The state represents the properties and **behavior** is the action that objects can perform. In other words, we can say that a class is the blueprint/plan/template that describes the details of an object. A class is a blueprint from which the individual objects are created. In C#, a Class is composed of three things i.e. a name, attributes, and operations.

##### **Objects:**

It is an instance of a class. A class is brought live by creating objects. An object can be considered as a thing that can perform activities. The set of activities that the object performs defines the object’s behavior. All the members of a class can be accessed through the object. To access the class members, we need to use the dot (.) operator. The dot operator links the name of an object with the name of a member of a class.

##### **How can we create a Class and Object in C#?**

![[word-image-334.webp]]
template/ plan/ blueprint 


So, the point that you need to remember is, to create a class you need to use the class keyword while if you want to create an object of a class then you need to use the new keyword. Once you create the object then you can access the class members using the object.


```C#
using System;
namespace ClassObjectsDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            //Creating object
            Calculator calObject = new Calculator();

            //Accessing Calculator class member using Calculator class object
            int result = calObject.CalculateSum(10, 20);

            Console.WriteLine(result);
            Console.ReadKey();
        }
    }

    //Defining class or blueprint or template
    public class Calculator
    {
        public int CalculateSum(int no1, int no2)
        {
            return no1 + no2;
        }
    }
}

```

##### **Difference between Class and Objects in C#**

A Class is a template or blueprint for creating Objects, and every Object in C# must belong to a Class.
![[Difference-between-Class-and-Objects-in-C.webp]]

All the Employees have some properties such as employee id, name, salary, gender, department, etc. These properties are nothing but the attributes (properties or fields) of the Employee class.

If required you can also add some methods (functions) that are common to all Employees such as InsertData and DisplayData to insert and display the Employee Data.

So, the idea is that the template or blueprint of the Employee is not going to change. Each and every Object is going to build from the same template (Class) and therefore contains the same set of methods and properties. Here, all Objects share the same template but maintain a separate copy of the member data (Properties or fields).


##### **Types of Classes in C#:**

![[Types-of-Classes-in-C-768x252.webp]]

In C# we have the below types of classes

1. [**Abstract Class**](https://dotnettutorials.net/lesson/abstract-class-abstract-methods-csharp/)
2. **Concrete class**
3. [**Sealed Class**](https://dotnettutorials.net/lesson/sealed-class-methods-csharp/)
4. [**Partial Class**](https://dotnettutorials.net/lesson/partial-classes-partial-methods-csharp/)
5. [**Static Class**](https://dotnettutorials.net/lesson/static-class-in-csharp/)

##### **What is a Constructor in C#?**

It is a special method present inside a class responsible for initializing the variables of that class. We will come to this point later part of this article.

The name of the constructor method is exactly the same name as the class in which it was present. You cannot change the name. If your class name is Employee, then the name of the constructor method is going to be Employee, and if your class name is Student, then the constrictor name is also going to be Student.

The constructor method does not return any value. That means it is a non-value returning method. Generally, methods are of two types i.e. value returning and non-value returning and constructors are purely non-value returning. That is, they never return any value.


![[word-image-1122-1.webp]]

Every variable we declared inside a class and every field we declared inside a class has a default value. All numeric types are initialized with 0, Boolean types initialized with false, and string and object types initialized with null. For a better understanding, please have a look at the below image.

![[word-image-1122-2.webp]]

Like this, the initialization is performed for each and all variables present in the class and this is the responsibility of the constructor. That is why a constructor is very important for us inside a class.

##### **Example to Understand Implicitly Constructor in C#:**

we have not defined any constructor explicitly. So, here compiler will provide the implicit constructor and will initialize the variables with the default value. Then from the Main method, we create an instance of the class and print the values of the variables and it should print the default values based on the variable type. For example, for int, the default value is 0, for bool the default value is false, and for string or object the default is null. And this default initialization is done by the implicit constructor which is given by the compiler.

```C#
using System;
namespace ConstructorDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            Test obj = new Test();
            Console.WriteLine($"i = {obj.i}");
            Console.WriteLine($"b = {obj.b}");

            //value null will be printed, so here we checking the null
            if (obj.s == null)
            {
                Console.WriteLine("s = null");
            }

            Console.ReadKey();
        }
    }
    class Test
    {
        public int i;
        public bool b;
        public string s;
    }
}

```

##### **How to Define the Constructor Explicitly in C#?**

We can also define the constructor explicitly in C#. The following is the explicit constructor syntax.

![[How-to-Define-the-Constructor-Explicitly-in-C.webp]]

Whenever we are creating an instance, there will be a call to the class constructor.   Here, we defined one parameter less constructor explicitly, and then from the Main method, we create an instance. When we create the instance, it will make a call to the constructor, and the statements written inside the constructor will be executed. In this case, it will execute the print statement in the console.

```C#
using System;
namespace ConstructorDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            ExplicitConstructor obj = new ExplicitConstructor();
            
            Console.ReadKey();
        }
    }
    class ExplicitConstructor
    {
        public ExplicitConstructor()
        {
            Console.WriteLine("Explicit Constructor is Called!");
        }
    }
}

```


One more important point that you need to remember is, how many instances you created, and that many times the constructor is called for us. Let us prove this. Please modify the example code as follows. Here, I am creating the instance four times and it should and must call the constructor 4 times and we should see the print statement four times in the console window.

```C#
using System;
namespace ConstructorDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            ExplicitConstructor obj1 = new ExplicitConstructor();
            ExplicitConstructor obj2 = new ExplicitConstructor();
            ExplicitConstructor obj3 = new ExplicitConstructor();
            ExplicitConstructor obj4 = new ExplicitConstructor();

            Console.ReadKey();
        }
    }
    class ExplicitConstructor
    {
        public ExplicitConstructor()
        {
            Console.WriteLine("Explicit Constructor is Called!");
        }
    }
}

```

##### **We should not use the word Implicitly while calling the constructor in C#, why?**

See, if we are not defining any constructor explicitly, then the compiler will provide the constructor which is called Implicitly Constructor. See, the following example. If you move the mouse pointer over the Test class, then you will see the following. Here, Test is a class present under the ConsructorDemo namespace.


![[word-image-1122-5.webp]]

Now, move the mouse pointer to Test() as shown in the below image. Here, the first Test is the class name and the second Test() is the constructor. That means we are calling the constructor explicitly.

![[word-image-1122-6.webp]]

Now coming to the ExplicitConstructor example, we are also doing the same thing. Please have a look at the below example. If you move the mouse pointer over the ExplicitConstructor class, then you will see the following. Here, ExplicitConstructor is a class present under the ConsructorDemo namespace.

![[word-image-1122-7.webp]]

Now, move the mouse pointer to ExplicitConstructor() as shown in the below image. Here, the first ExplicitConstructor is the class name and the second ExplicitConstructor() is the constructor. That means we are calling the constructor explicitly.

![[word-image-1122-8.webp]]

##### **Defining and Calling Constructor in C#:**

**Defining:** Defining a constructor means implementing a constructor in your class. Defining can be two types i.e. Implicit and Explicit. Implicit means the compiler will define the constructor. Explicit means we as a programmer define the constructor. The following code shows defining a constructor explicitly.

![[word-image-1122-9.webp]]

**Calling:** Whenever we are creating the instance, we are calling the constructor. Calling is Explicit. We should only call. There is no implicit call to the constructor. For a better understanding, please have a look at the below code.

![[word-image-1122-10.webp]]

The calling should be done explicitly by us. That may be an implicit or explicit constructor but calling the constructor should be explicit.

##### **Types of Constructors in C#**

There are five types of constructors available in C#, they are as follows

1. **Default or Parameter Less Constructor**
2. **Parameterized Constructor**
3. **Copy Constructor**
4. **Static Constructor**
5. **Private Constructor**



##### **System-Defined Implicit or Default Constructor in C#:**
```C#
using System;
namespace ConstructorDemo
{
    class Employee
    {
        public int Id, Age;
        public string Address, Name;
        public bool IsPermanent;
    }
    class Test
    {
        static void Main(string[] args)
        {
            Employee e1 = new Employee();
            Console.WriteLine("Employee Id is:  " + e1.Id);
            Console.WriteLine("Employee Name is:  " + e1.Name);
            Console.WriteLine("Employee Age is:  " + e1.Age);
            Console.WriteLine("Employee Address is:  " + e1.Address);
            Console.WriteLine("Is Employee Permanent:  " + e1.IsPermanent);
            Console.ReadKey();
        }
    }
}

```

![[word-image-27825-2.webp]]

#####  **understand User-defined Default Constructor in C#**

```C#
using System;
namespace ConstructorDemo
{
    class Employee
    {
        public int Id, Age;
        public string Address, Name;
        public bool IsPermanent;

        //User Defined Default Constructor
        public Employee()
        {
            Id = 100;
            Age = 30;
            Address = "Bhubaneswar";
            Name = "Anurag";
            IsPermanent = true;
        }

        public void Display()
        {
            Console.WriteLine("Employee Id is:  " + Id);
            Console.WriteLine("Employee Age is:  " + Age);
            Console.WriteLine("Employee Address is:  " + Address);
            Console.WriteLine("Employee Name is:  " + Name);
            Console.WriteLine("Is Employee Permanent:  " + IsPermanent);
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Employee e1 = new Employee();
            e1.Display();

            Console.ReadKey();
        }
    }
}

```

![[word-image-27825-4.webp]]

##### **What is Parameterized Constructor in C#?**

If a constructor method is defined with parameters, we call it a Parameterized Constructor in C#, and these constructors are defined by the programmers only but never can be defined implicitly. So, in simple words, we can say that the developer-given constructor with parameters is called Parameterized Constructor in C#.

Let us understand Parameterized Constructor in C# with Examples. Please have a look at the below code. Here, we have a class called ParameterizedConstructor, and this class has one constructor which is taking one integer parameter. As this constructor takes a parameter, we call it a Parameterized Constructor. And in this constructor, we are printing the i value.

![[word-image-27825-6.webp]]

![[word-image-27825-8.webp]]

```C#
using System;
namespace ConstructorDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            ParameterizedConstructor obj = new ParameterizedConstructor(10);
            Console.ReadKey();
        }
    }

    public class ParameterizedConstructor
    {
        public ParameterizedConstructor(int i)
        {
            Console.WriteLine($"Parameterized Constructor is Called: {i}");
        }
    }
}

```

```C#
using System;
namespace ConstructorDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            ParameterizedConstructor obj1 = new ParameterizedConstructor(10);
            ParameterizedConstructor obj2 = new ParameterizedConstructor(20);
            Console.ReadKey();
        }
    }

    public class ParameterizedConstructor
    {
        public ParameterizedConstructor(int i)
        {
            Console.WriteLine($"Parameterized Constructor is Called : {i}");
        }
    }
}

```

##### **Copy Constructor in C#:**

If we want to create multiple instances with the same values then we need to use the copy constructor in C#, in a copy constructor the constructor takes the same class as a parameter to it.

```C#
using System;
namespace ConstructorDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            CopyConstructor obj1 = new CopyConstructor(10);
            obj1.Display();
            Console.ReadKey();
        }
    }

    public class CopyConstructor
    {
        int x;
        public CopyConstructor(int i)
        {
            x = i;
        }
        public void Display()
        {
            Console.WriteLine($"Value of X = {x}");
        }
    }
}

```

![[word-image-27825-16.webp]]

See, passing one parameter is not a difficult task. Suppose, the constructor takes 10 or 20 parameters, then it is a time-consuming and error-prone process to pass the same 10 or 20 parameters. We can overcome this problem by using Copy Constructor in C#. The copy constructor takes a parameter of the same class type. How we can pass a class name as a parameter. This is because a class is a user-defined data type. For a better understanding, please have a look at the below image.
![[word-image-27825-17.webp]]

With the above changes, now you can see we have two constructors as shown in the below image. One constructor takes an int as a parameter and the other constructor takes the CopyConstructor type as a parameter.

```C#
using System;
namespace ConstructorDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            CopyConstructor obj1 = new CopyConstructor(10);
            obj1.Display();
            CopyConstructor obj2 = new CopyConstructor(obj1);
            obj2.Display();
            Console.ReadKey();
        }
    }

    public class CopyConstructor
    {
        int x;

        //Parameterized Constructor
        public CopyConstructor(int i)
        {
            x = i;
        }

        //Copy Constructor
        public CopyConstructor(CopyConstructor obj)
        {
            x = obj.x;
        }

        public void Display()
        {
            Console.WriteLine($"Value of X = {x}");
        }
    }
}

```

```C#
using System;
namespace ConstructorDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            CopyConstructor obj1 = new CopyConstructor(10);
            obj1.Display();
            CopyConstructor obj2 = new CopyConstructor(obj1);
            obj2.Display();
            Console.ReadKey();
        }
    }

    public class CopyConstructor
    {
        int x;

        //Parameterized Constructor
        public CopyConstructor(int i)
        {
            x = i;
        }

        //Copy Constructor
        public CopyConstructor(CopyConstructor obj)
        {
            x = obj.x;
        }

        public void Display()
        {
            Console.WriteLine($"Value of X = {x}");
        }
    }
}

```

![[word-image-27825-20.webp]]

##### **Static Constructor in C#**

In C#, it is also possible to create a constructor as static and when we do so, it is called a Static Constructor. If a constructor is declared explicitly by using the static modifier, then it is called a static constructor in C#. All the constructors we defined till now are non-static or instance constructors.

![[word-image-27825-22.webp]]

But, when you will compile the above, the compiler will provide the default parameter less constructor. For a better understanding, please have a look at the below code.

![[word-image-27825-23.webp]]

```C#
using System;
namespace ConstructorDemo
{
    public class StaticConstructor
    {
        static StaticConstructor()
        {
            Console.WriteLine("Static Constructor Executed!");
        }
        static void Main(string[] args)
        {
            Console.WriteLine("Main Method Exceution Started...");
            Console.ReadKey();
        }
    }
}

```

##### **Can we initialize non-static data members within a static constructor in C#?**

It is not possible to initialize non-static data members within a static constructor, it raises a compilation error. For a better understanding, please have a look at the following example.

![[word-image-27825-26.webp]]
##### **Can we initialize static data fields within a non-static constructor in C#?**

Yes, we can initialize static data members within a non-static constructor. Consider the following example for better understanding:

![[word-image-27825-27.webp]]

##### **What is a Private Constructor in C#?**

In C#, it is also possible to create a constructor as private. The constructor whose accessibility is private is known as a private constructor. When a class contains a private constructor then we cannot create an object for the class outside of the class. So, private constructors are used to create an object for the class within the same class.

##### **Example to understand Private Constructor in C#**

```C#
using System;
namespace ConstructorDemo
{
    class Program
    {
        private Program()
        {
            Console.WriteLine("This is private constructor");
        }
        static void Main(string[] args)
        {
            Program p = new Program();
            Console.WriteLine("Main method");
            Console.ReadKey();
        }
    }
}

```

##### **Why do we need Constructors in C#?**

Every class requires a constructor to be present in it if we want to create the instance of that class. Every class contains an implicit constructor if not defined explicitly by the programmer and with the help of that implicit constructor, we can create the instance of that class.

If we don’t define any constructors, then an implicit constructor is there which is provided by the compiler at the time of compilation and using that implicit constructor we can create the instance, then the question is why do we need to define the constructor explicitly again or when do we need to define an explicit constructor in C#?

```c#
using System;
namespace ConstructorDemo
{
    class First
    {
    //Initialize with default value
        public int x = 100;
    }
    class Second
    {
        
        public int x;
        public Second(int _x){
         this.x = _x;
        }
        
    }
    class Test
    {
        static void Main(string[] args)
        {
            First f1 = new First();
            First f2 = new First();
            First f3 = new First();
            Console.WriteLine($"{f1.x}   {f2.x}   {f3.x}");

            Second s1 = new Second();
            Second s2 = new Second();
            Second s3 = new Second();
            Console.WriteLine($"{s1.x}   {s2.x}   {s3.x}");
            Console.ReadKey();
        }
    }
}

```


![[word-image-27828-3 1.webp]]

![[word-image-27828-4.webp]]

![[word-image-27828-5.webp]]
![[word-image-27828-6.webp]]

##### **Parameterized Constructor Real-time Example in C#**
```C#
using System;
namespace ConstructorDemo
{
    class Employee
    {
        public int Id, Age;
        public string Address, Name;
        public bool IsPermanent;

        //User Defined Parameterized Constructor
        public Employee(int id, int age, string name, string address, bool isPermanent)
        {
            Id = id;
            Age = age;
            Address = address;
            Name = name;
            IsPermanent = isPermanent;
        }

        public void Display()
        {
            Console.WriteLine("Employee Id is:  " + Id);
            Console.WriteLine("Employee Name is:  " + Age);
            Console.WriteLine("Employee Address is:  " + Address);
            Console.WriteLine("Employee Name is:  " + Name);
            Console.WriteLine("Is Employee Permanent:  " + IsPermanent);
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Employee e1 = new Employee(101, 30, "Pranaya", "Mumbai", true);
            e1.Display();
            Console.WriteLine();

            Employee e2 = new Employee(101, 28, "Rout", "BBSR", false);
            e2.Display();
            Console.ReadKey();
        }
    }
}

```

##### **Copy Constructor Real-time Example in C#**

```C#
using System;
namespace ConstructorDemo
{
    class Employee
    {
        public int Id, Age;
        public string Address, Name;
        public bool IsPermanent;

        //Parameterized Constructor
        public Employee(int id, int age, string name, string address, bool isPermanent)
        {
            Id = id;
            Age = age;
            Address = address;
            Name = name;
            IsPermanent = isPermanent;
        }

        //Copy Constructor
        public Employee(Employee emp)
        {
            Id = emp.Id;
            Age = emp.Age;
            Address = emp.Address;
            Name = emp.Name;
            IsPermanent = emp.IsPermanent;
        }

        public void Display()
        {
            Console.WriteLine("Employee Id is:  " + Id);
            Console.WriteLine("Employee Name is:  " + Age);
            Console.WriteLine("Employee Address is:  " + Address);
            Console.WriteLine("Employee Name is:  " + Name);
            Console.WriteLine("Is Employee Permanent:  " + IsPermanent);
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Employee e1 = new Employee(101, 30, "Pranaya", "Mumbai", true);
            e1.Display();
            Console.WriteLine();
            
            Employee e2 = new Employee(e1);
            e2.Display();
            Console.ReadKey();
        }
    }
}

```

##### **Static Constructor** **Real-time** **Example in C#**
```C#
using System;
namespace StaticConstructorDemo
{
    class Example
    {
        int i;
        static int j;

        //Default Constructor
        public Example()
        {
            Console.WriteLine("Default Constructor Executed");
            i = 100;
        }

        //static Constructor
        static Example()
        {
            Console.WriteLine("Static Constructor Executed");
            j = 100;
        }
        public void Increment()
        {
            i++;
            j++;
        }
        public void Display()
        {
            Console.WriteLine("Value of i : " + i);
            Console.WriteLine("Value of j : " + j);
        }
    }
    class Test
    {
        static void Main(string[] args)
        {
            Example e1 = new Example();
            e1.Increment();
            e1.Display();
            e1.Increment();
            e1.Display();
            Example e2 = new Example();
            e2.Increment();
            e2.Display();
            e2.Increment();
            e2.Display();
            Console.ReadKey();
        }
    }
}

```


##### **What is Singleton Pattern in C#?**

The Singleton Design Pattern ensures that only one instance of a particular class is going to be created and then provide simple global access to that instance for the entire application.

##### **How to Implement Singleton Design Pattern in C#?**

The following are the steps to implement the Singleton Design Pattern in C#.

1. You need to declare only a single constructor in your class and that constructor should be private and parameterless. This is required because it is not allowed the class to be instantiated from outside the class. It only instantiates from within the class.
2. The class should be declared sealed which will ensure that it cannot be inherited.
3. You need to create a private static variable that is going to hold a reference to the single created instance of the class.
4. You also need to create a public static property/method which will return the single-created instance of the singleton class. This method or property first checks if an instance of the singleton class is available or not. If the singleton instance is available, then it returns that singleton instance otherwise it will create an instance and then return that instance.

```C#
using System;
namespace PrivateConstructorDemo
{
    public sealed class Singleton
    {
        private static int counter = 0;
        private static Singleton instance = null;
        private static readonly object Instancelock = new object();
        public static Singleton GetSingletonInstance()
        {
            lock (Instancelock)
            {
                if (instance == null)
                {
                    instance = new Singleton();
                }
                return instance;
            }
        }

        private Singleton()
        {
            counter++;
            Console.WriteLine($"Singleton Constructor Executed {counter} Time");
        }
        public void SomeMethod(string Message)
        {
            Console.WriteLine($"Some Method Called : {Message}");
        }
    }
}

```

```C#
using System;
namespace PrivateConstructorDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            Singleton fromPlace1 = Singleton.GetSingletonInstance();
            fromPlace1.SomeMethod("From Place 1");
            Singleton fromPlace2 = Singleton.GetSingletonInstance();
            fromPlace2.SomeMethod("From Place 2");
            Console.ReadKey();
        }
    }
}

```

##### **What are Destructors in C#?**

According to **[MSDN](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/finalizers)**, Destructors which are also called Finalizers in C# are used to perform any necessary final clean-up when a class instance is being collected by the garbage collector.

The Destructor is also a special type of method present in a class, just like a constructor, having the same name as the class name but prefixed with **~** tilde. The Constructor in C# is Explicitly called when the object of the class is created. On the other hand, the Destructor in C# is Implicitly Called when the object of the class is destroyed.

The Constructor and destructor methods will exactly have the same name as the class to which they belong. So, to differentiate between these two, a tilde (~) symbol is used just before the destructor method. The syntax is shown below.

![[word-image-1131-1.webp]]

**Note:** The most important point that you need to keep in mind is that a destructor method cannot have any parameters as well as cannot be applied with any modifiers. As the destructor is not parameterized, so we cannot overload the destructor.

The object of a class in C# will be destroyed by the garbage collector in any of the following cases

1. At the end of the program execution, each and every object that is associated with the program will be destroyed by the garbage collector.
2. The Implicit calling of the garbage collector occurs sometime in the middle of the program execution provided the memory is full so the garbage collector will identify unused objects of the program and destroys them.
3. The Explicit calling of the garbage collector can also be done in the middle of program execution by the programmer with the help of the “**Collect()**” statement so that if there are any unused objects associated with the program will be destroyed in the middle of the program execution.
##### **Example to Understand Destructors in C#:**

In the below example, we have created one class called DestructorDemo with one constructor and one destructor. Then inside the Main method, we have created two instances of the DestructorDemo class and then made the obj1 value null which is eligible for garbage collection.

```C#
using System;
namespace DestructorExample
{
    class DestructorDemo
    {
        public DestructorDemo()
        {
            Console.WriteLine("Constructor Object Created");
        }
        ~DestructorDemo()
        {
            string type = GetType().Name;
            Console.WriteLine($"Object {type} is Destroyed");
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            DestructorDemo obj1 = new DestructorDemo();
            DestructorDemo obj2 = new DestructorDemo();

            //Making obj1 for Garbage Collection
            obj1 = null;
            Console.ReadKey();
        }
    }
}

```

If you want, then you can also make an explicit call to the garbage collector in the middle of the application execution to destroy the unused object. To do so, we need to call the **GC.Collect** method as shown in the below example.

```c#
using System;
namespace DestructorExample
{
    class DestructorDemo
    {
        public DestructorDemo()
        {
            Console.WriteLine("Constructor Object Created");
        }
        ~DestructorDemo()
        {
            string type = GetType().Name;
            Console.WriteLine($"Object {type} is Destroyed");
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            DestructorDemo obj1 = new DestructorDemo();
            DestructorDemo obj2 = new DestructorDemo();

            //Making obj1 for Garbage Collection
            obj1 = null;
            GC.Collect();
            Console.ReadKey();
        }
    }
}

```

##### **Can you prove the destructor method is Implicitly called by Garbage Collector?**
yes 

we have created an instance of the DestructorDemo class and then we are making the object null and calling the GC.Collect methods three times. The point that you need to observe is how many times, the destructor method or finalizer is executed and when executed.
```C#
using System;
namespace DestructorExample
{
    class DestructorDemo
    {
        public DestructorDemo()
        {
            Console.WriteLine("DestructorDemo Object Created");
        }
        ~DestructorDemo()
        {
            Console.WriteLine("DestructorDemo Object Destroyed");
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Main Method Execution Started");
            DestructorDemo obj1 = new DestructorDemo();
            
            //Making obj1 ready for Garbage Collection
            obj1 = null;
            GC.Collect();
            Console.WriteLine("Some Statement Executed Inside Main Method");

            obj1 = null;
            GC.Collect();
            Console.WriteLine("Some More Statement Executed Inside Main Method");

            GC.Collect();
            Console.WriteLine("Main Method Execution End");
            Console.ReadKey();
        }
    }
}
```

```C#

```

##### **Pints to Remember while working with Destructors in C#:**
**Point1:** Destructors (or Finalizers) cannot be defined in structs. In C#, they are only used with only classes.

![[word-image-1131-5.webp]]
**Point2:** In a class, we can only define one Destructor (or Finalizer). That means Destructors cannot be overloaded in a class.

![[word-image-1131-6.webp]]

**Point3:** Destructors cannot be called Explicitly. They are invoked automatically by the garbage collector. At most what we can do is, we can request the Garbage collector to execute the Destructor by calling the **GC.Collect()** method.

![[word-image-1131-7.webp]]

**Point4**: A Destructor does not take any modifiers or does not have any parameters. They are parameterless. For a better understanding, please have a look at the below code.

![[word-image-1131-8.webp]]

##### **How Destructors are Implemented in C#?**

```C#
using System;
namespace DestructorExample
{
    class Sample
    {
        //Destructor
        ~Sample()
        {
            //Clean-up Statements
        }
    }

    class Program
    {
        static void Main()
        {
        }
    }
}
```

As you can see, the Destructor implicitly calls the Finalize method on the base class of the object. Therefore, a call to a destructor is implicitly translated as follows:

![[word-image-1131-9.webp]]


```C#
using System;
namespace DestructorExample
{
    public class First
    {
        ~First()
        {
            Console.WriteLine("Destructor of First Called");
        }
    }

    public class Second : First
    {
        ~Second()
        {
            Console.WriteLine("Destructor of Second Called");
        }
    }

    public class Third : Second
    {
        ~Third()
        {
            Console.WriteLine("Destructor of Third Called");
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Third obj = new Third();
            obj = null;
            GC.Collect();
            Console.ReadKey();
        }
    }
}

```

**Note1:** Empty Destructors should not be used in our application. When a class contains a destructor, then an entry for that destructor is created in the Finalize queue. This is the queue that is processed by the garbage collector. When the Garbage Collector processes the Finalize queue, it will call each destructor. So, Unnecessary destructors, including empty destructors, destructors that only call the base class destructor, or destructors that only call conditionally emitted methods, cause a needless loss of performance.

**Note2:** As a developer, we have no control over when the destructor is called and executed. It is the garbage collector in .NET Framework who decides when to call destructors. The garbage collector periodically checks for objects that are no longer being used by the application. If it considers an object eligible for destruction, then it calls the destructor (if any) and reclaims the memory used to store the object. It is also possible to force garbage collection by calling the **GC.Collect** method, but most of the time, this call should be avoided because it may create performance issues.

##### **When to use Destructor in C#?**

You might have one question on your mind if the memory management is automatically managed by the garbage collector, then when do we need to use Destructor? In general, as C#.NET developers, we need not be much more worried about memory management. This is because the .NET garbage collector implicitly manages the allocation and deallocation of the memory for our objects.

However, when our application works with unmanaged resources, such as windows, files, and network connections, we should use a destructor to free the memory for those unmanaged resources. When the object is eligible for destruction, the garbage collector runs the Finalize method of the object. For a better understanding, please have a look at the following example.

```C#
using System;
namespace FileHandlinDemo
{
    public class UmmanagedResource
    {
        public UmmanagedResource()
        {
            //Creating Unmanaged Resources  
            Console.WriteLine("Unmanaged Resource Created");
        }
        ~UmmanagedResource()
        {
            //Clean up Unmanaged Resources  
            Console.WriteLine("Unmanaged Resource Destroyed");
        }
    }
    class Program
    {
        static void Main()
        {
            UmmanagedResource resource = new UmmanagedResource();
            Console.WriteLine("Using Unmanaged Resource");
            resource = null;
            GC.Collect();
            
            Console.ReadKey();
        }
    }
}

```

##### **Explicit Release of Resources using Dispose Pattern in C#:**

If our application is using an expensive external resource, then it is recommended to provide an explicit way to release the resources before the garbage collector frees the object. To release the resource, it is recommended to implement a Dispose method of the IDisposable interface that performs the necessary clean-up for the object. So, basically, we need our class to inherit from the IDisposable interface and provide the implementation for the Dispose methods as follows. So, here, please select Implement Interface with Dispose Pattern option as shown in the below image.

![[word-image-1131-12.webp]]

```C#
using System;
public class UmmanagedResource : IDisposable
{
    #region IDisposable Support
    private bool disposedValue = false; // To detect redundant calls

    protected virtual void Dispose(bool disposing)
    {
        if (!disposedValue)
        {
            if (disposing)
            {
                // TODO: dispose managed state (managed objects).
            }

            // TODO: free unmanaged resources (unmanaged objects) and override a finalizer below.
            // TODO: set large fields to null.

            disposedValue = true;
        }
    }

    // TODO: override a finalizer only if Dispose(bool disposing) above has code to free unmanaged resources.
    // ~UmmanagedResource() {
    //   // Do not change this code. Put cleanup code in Dispose(bool disposing) above.
    //   Dispose(false);
    // }

    // This code added to correctly implement the disposable pattern.
    public void Dispose()
    {
        // Do not change this code. Put cleanup code in Dispose(bool disposing) above.
        Dispose(true);
        // TODO: uncomment the following line if the finalizer is overridden above.
        // GC.SuppressFinalize(this);
    }
    #endregion
}
```


```c#
using System;
namespace DestructorDemo
{
    public class UmmanagedResource : IDisposable
    {
        #region IDisposable Support
        private bool disposedValue = false; // To detect redundant calls

        protected virtual void Dispose(bool disposing)
        {
            if (!disposedValue)
            {
                if (disposing)
                {
                    //Write Code Here to Destroy the Managed Resources
                    Console.WriteLine("Managed Resources Destroyed by Dispose Method");
                }

                //Write Code Here to Destroy the Umanaged Resources
                Console.WriteLine("Unmanaged Resources Destroyed by Dispose Method");
                disposedValue = true;
            }
            else
            {
                Console.WriteLine("Resources are Already Destroyed by Dispose Method");
            }
        }

        ~UmmanagedResource()
        {
            //Write Code here to Destroy the Object
            Console.WriteLine("Request Comes to Destructor to Destroy the Resources");
            Dispose(false);
        }

        // This code added to correctly implement the disposable pattern.
        public void Dispose()
        {
            //Write Code here to Destroy the Object
            Console.WriteLine("Request Comes to Dispose Method to Destroy the Resources");
            Dispose(true);
            GC.SuppressFinalize(this);
        }
        #endregion
    }
    class Program
    {
        static void Main()
        {
            UmmanagedResource resource = null;
            try
            {
                resource = new UmmanagedResource();
                Console.WriteLine("Using Resources");
            }
            finally
            {
                if (resource != null)
                {
                    Console.WriteLine("Calling Dispose Method to Destroy Resources");
                    resource.Dispose();
                }
            }

            //Trying to Call the Dispose Method again
            Console.WriteLine();
            Console.WriteLine("Trying to Call the Dispose Method Again To Destroy Resources");
            resource.Dispose();
            Console.ReadKey();
        }
    }
}
```

