##### **What are Delegates in C#?**

In simple words, we can say that the delegates in C# are the Type-Safe Function Pointer. It means they hold the reference of a method or function and then call that method for execution. If this is not clear at the moment, then don’t worry we will come to this point once we start discussing the examples using delegates.

##### **How to Create a Custom Delegates in C#?**

When it comes to creating a custom delegate, is a very simple process. So, a custom delegate can be defined by using the delegate keyword. And it is a kind of magic keyword because behind the scene, when the compiler sees the delegate keyword, it actually generates a class that inherits from some other .NET Framework delegate classes and that will be covered in a moment.

The syntax to create a delegate in C# is very much like the abstract method declaration. In abstract method declaration, we use the abstract keyword whereas, in delegate, we need to use the delegate keyword. The syntax for defining a delegate in C# is as follows:

`<Access Modifier> delegate <Return Type> <Delegate Name> (Parameter List);`

The following is an example of a delegate. Here, you can notice that we are using the delegate keyword. This particular delegate you can think of is a one-way pipeline. It’s void, nothing is going to return back. Data only goes forward. The name of the delegate is WorkPerformedHandler and it takes two parameters. The first parameter is integer hours and the second parameter is worktype which is going to be an Enumeration. Now, if you remove the delegate keyword, then it looks like a method.

**public delegate void WorkPerformedHandler(int hours, WorkType workType);**

In reality, a delegate is a blueprint for the method, which is going to dump the data into the event handler. Visually, it would look like the below image. The delegate is kind of a pipeline. And what we want then, is a way to dump some data from Point A to Point B which is going to be our Event Handler method.

![[word-image-29911-1-7.webp]]

Now, we have our data somewhere in our program and we want to route those data over to this Handler method. How we can route the data into the Handler Method? We are going to route the data which is stored somewhere in our program over to this Handler Method using the pipeline i.e. using a delegate. In delegate, we need to define the parameters which will route the data from point A to point B (i.e. Handler method).

![[word-image-29911-2-6.webp]]

In this case, the pipeline only accepts two parameters and it must be of type int and WorkType otherwise it will not compile. So, now we have one way to delegate the data from point A to Point B. So, the delegate knows how to pass data. So, defining a delegate is very simple as you can see here.

Now, let us try to understand what the Handler method must do in order for this to work. The delegate signature and handler method signature must be matched. As we have defined the delegate with two parameters or you can say our pipeline takes two parameters of int and WorkType type. Now, if the handler method wants to receive the data from the pipeline, then the handler must have the same number, type, and order of parameters as the delegate. For a better understanding, please have a look at the below image which shows the delegate and handler method.

![[word-image-29911-3-8.webp]]

As you can see in the above image, the first parameter of our delegate is int, and also int is the first parameter of our Handler. The second parameter of the delegate is WorkType and in order to receive the data from the pipeline, the second parameter of the Handler must and should also be WorkType. This is important and parameters type, order, and number must be the same, otherwise, the Handler Method will not receive the data from the pipeline. The parameter names do not matter. You can see that I have given the parameter name of the delegate as hours and workType and I have provided different names to the handler Method and that is fine.

**Note:** The point that you need to remember while working with C# Delegates is that the signature of the delegate and the method it points should be the same. So, when you create a delegate, then the **Access Modifier**, **Return Type**, and **Number, Type, and Order of Parameters** of the delegates must and should be the same as the **Access Modifier, Return Type, and Number, Type, and Order of Parameters** of the function that the delegate wants to refer. You can define the delegates either within a class or just like other types we defined under a namespace.

##### **What happens behind the scene with our delegate?**

Now, we are going to discuss what happens behind the scene with our delegate i.e. we are going to discuss the delegate base classes in .NET Framework.

##### **Delegate Base Class in C#:**

One of the really core classes in the .NET Framework is Delegate which provides some base functionalities. If you go to the definition of the Delegate class, then you will see that it is an abstract class as shown in the below image.

![[word-image-29911-4-4.webp]]

The Delegate class provides two important properties. They are as follows:

1. **public MethodInfo Method {get;}:** This property is used to get the method represented by the delegate. That means it returns a System.Reflection.MethodInfo describes the method represented by the delegate. It will throw MemberAccessException if the caller does not have access to the method represented by the delegate, for example, if the method is private.
2. **public object Target {get;}:** This property is used to get the class instance on which the current delegate invokes the instance method. That means it returns the object on which the current delegate invokes the instance method if the delegate represents an instance method; null if the delegate represents a static method.

**Note:** The pipeline has to dump the data somewhere, and the Method property defines the name of the method where the data is going to be dumped. And the Target would be the object instance where the method lives and null in the case of a static method. If the delegate invokes one or more instance methods, the Target property returns the target of the last instance method in the invocation list.

This Delegate abstract class also has one important virtual method called GetInvocationList.

1. **public virtual Delegate[] GetInvocationList():** This method returns the invocation list of the delegate. That means it returns an array of delegates representing the invocation list of the current delegate.

##### **MulticastDelegate Base Class in C#:**

Now, let us proceed and understand another important core class i.e. MulticastDelegate. If you will go to the definition of MulticastDelegate class, then you will see that this class is also an abstract class and this class is inherited from the Delegate abstract class as shown in the below image.

![[word-image-29911-5-5.webp]]

Now, every delegate that we create, once compiled, will inherit from the Multicast delegate. Once we start programming, I will show you this practically by showing the compiled code i.e. IL code by using the ILDASM tool.

So, Multicast Delegate is a way to hold multiple delegates. For example, I have one message that I want to send over multiple pipelines which will dump the same data into multiple Handler Methods. So, your custom delegate as we discussed earlier will inherit from the Multicast Delegate. The complete hierarchy is given below.

![[word-image-29911-6-4.webp]]
**Note:** The point that you need to remember is, in your code while declaring the delegate, you cannot directly inherit from the Delegate or Multicast Delegate classes. The way you need to do this is to use the delegate keyword and the rest of the things are done by the compiler. These are the special base classes that the compiler restricts us from directly inheriting. Once the compiler sees the delegate keyword in the signature, then it will automatically generate the class that inherits from the Multicast Delegate.

##### **How to use the Delegate in C#?**

How to use the delegate means how we are going to use the delegate to move the data. For this, we need to create an instance of the delegate. And while creating the instance we need to specify the Handler Method name where we want to dump the data. If the Handler Method is a static method, you can access that method directly or using the class name and if the Handler Method is a non-static method, then you need to access the Handler Method using the object name. For a better understanding, please have a look at the below image.


![[word-image-29911-7-2.webp]]

When we declare a delegate, behind the scene when the compiler sees the delegate keyword, it will create a class inheriting from the MulticastDelegate and as this is a class, we can create an instance of the delegate by using the new keyword. And notice to the constructor, that we are passing the Delegate handler Method name. In our example, as the Handler Method is a static method and as both method and the instance that we are creating are present in the same class, we can pass the method name without using the class name, even if you use the class name, then it would not be an issue. But if the method is non-static, then you need to create an instance of the class to which the method belongs, and using that instance, you need to call the method inside the delegate constructor.

##### **How to Invoke a delegate in C#?**

Invoking a delegate is very simple. The way we call a method, in the same way, we can call a delegate, and the values for the parameters we need to pass within the parenthesis are as follows. Here, we are passing 5 as the work hours and WorkType as Golf.

**del1(10, WorkType.Golf);**

And the above statement will invoke the handler method Manager_WorkPerformed dynamically at runtime. For a better understanding, please have a look at the below image

![[word-image-29911-8-2.webp]]

Once we create an instance of a delegate, then we need to call the delegate by providing the required values to the parameters so that the methods get executed internally which is bound with the delegates. We can also use Invoke method to execute the delegates. For example:

**del1.Invoke(10, WorkType.Golf);**

##### **The complete example code is given below.**

```C#
using System;
namespace DelegatesDemo
{
    public delegate void WorkPerformedHandler(int hours, WorkType workType);

    class Program
    {
        static void Main(string[] args)
        {
            WorkPerformedHandler del1 = 
                        new WorkPerformedHandler(Manager_WorkPerformed);
            del1(10, WorkType.Golf);
            //del1.Invoke(50, WorkType.GotoMeetings);

            Console.ReadKey();
        }

        public static void Manager_WorkPerformed(int workHours, WorkType wType)
        {
            Console.WriteLine("Work Performed by Event Handler");
            Console.WriteLine($"Work Hours: {workHours}, Work Type: {wType}");
        }
    }

    public enum WorkType
    {
        Golf,
        GotoMeetings,
        GenerateReports
    }
}

```

##### **How to Invoke Methods using Delegates in C#?**

If you want to invoke or call a method using delegates, then you need to follow the following three steps. 

1. **Declare a Delegate**
2. **Instantiating a Delegate**
3. **Invoking a Delegate**

##### **Another Example to Understand Delegates in C#:**

Delegates are used to invoke the call-back functions. What it means is we will invoke one function and we will pass the delegate instance as a parameter to that function and we expect that function to invoke the delegate at some point of time which will invoke the callback method referred by the delegate instance.

As you can see in the below example, we have two methods i.e. DoSomework and CallbackMethod. From our Main method, we want to invoke the DoSomework method but we also want to DoSomework method to invoke one method dynamically at runtime, and that method we will provide at runtime. To do so, we want the DoSomework method accepts the delegate as a parameter and at some point, we need to invoke the delegate within the DoSomework method. Here, we are creating an instance of the delegate within the main method which is referring to the CallbackMethod, and passing that delegate instance as a value to the DoSomework method and at runtime when the DoSomework method invokes the delegate, the method which is pointed by the delegate, in this case, CallbackMethod method is going to be executed.

```C#
using System;
namespace DelegatesDemo
{
    public delegate void CallbackMethodHandler(string message);

    class Program
    {
        static void Main(string[] args)
        {
            Program obj = new Program();
            CallbackMethodHandler del1 = new CallbackMethodHandler(obj.CallbackMethod);
            //Here, I am calling the DoSomework function and I want the 
            //DoSomework function to call the delegate at some point of time
            //which will invoke the CallbackMethod method
            DoSomework(del1);

            Console.ReadKey();
        }

        public static void DoSomework(CallbackMethodHandler del)
        {
            Console.WriteLine("Processing some Task");
            del("Pranaya");
        }

        public void CallbackMethod(string message)
        {
            Console.WriteLine("CallbackMethod Executed");
            Console.WriteLine($"Hello: {message}, Good Morning");
        }
    }
}

```

##### **Example to understand Delegate class Important Properties and Method in C#:**

At the beginning of this article we have discussed, two important properties i.e. Method and Target, and one important method of the Delegate class i.e. GetInvocationList. Now, let us see the use of these properties and method with an example. In the below example, we have created one delegate and we have created one instance method that is referred by the delegate. Then within the Main method, we create an instance and invoke the properties and method. Here, which method is pointed by the delegate, that method prototype is going to be returned by the Method property, in our example, it will be **Void DoSomework(System.String)**. The Target property will return the fully qualified class name from which the event handler method i.e. SomeMethod belongs which in our example is **DelegatesDemo.SomeClass**. The GetInvocationList method will return the list of delegates that are referred by the delegate and, in this case, only one delegate i.e. **DoSomeMethodHandler**. In our next article, we will understand multicast delegate and, in that case, it is going to return multiple delegates.


```C#
using System;
using System.Reflection;

namespace DelegatesDemo
{
    public delegate void DoSomeMethodHandler(string message);

    class Program
    {
        static void Main(string[] args)
        {
            SomeClass obj = new SomeClass();
            DoSomeMethodHandler del1 = new DoSomeMethodHandler(obj.DoSomework);

            MethodInfo Method = del1.Method;
            object Target = del1.Target;
            Delegate[] InvocationList = del1.GetInvocationList();

            Console.WriteLine($"Method Property: {Method}");
            Console.WriteLine($"Target Property: {Target}");
           
            foreach (var item in InvocationList)
            {
                Console.WriteLine($"InvocationList: {item}");
            }
            
            Console.ReadKey();
        }
    }

    public class SomeClass
    {
        public void DoSomework(string message)
        {
            Console.WriteLine("DoSomework Executed");
            Console.WriteLine($"Hello: {message}, Good Morning");
        }
    }
}
```

**Note:** If the method is a static method, then the Target property is going to return null.

##### **Rules of using Delegates in C#:**

1. A delegate in C# is a user-defined type and hence before invoking a method using a delegate, we must have to define that delegate first.
2. The signature of the delegate must match the signature of the method, the delegate points to otherwise we will get a compiler error. This is the reason why delegates are called type-safe function pointers.

##### **What are the Types of Delegates in C#?**

The Delegates in C# are classified into two types as

1. **Single Cast Delegate**
2. **Multicast Delegate**

If a delegate is used for invoking a single method, then it is called a single cast delegate or unicast delegate. In other words, we can say that the delegates that represent only a single function are known as single cast delegates.

If a delegate is used for invoking multiple methods, then it is known as the multicast delegate. Or the delegates that represent more than one function are called Multicast delegates.

##### **Where do we use Delegates in C#?**

Delegates are used in the following cases:

1. Event Handlers
2. Callbacks
3. Passing Methods as Method Parameters
4. LINQ
5. Multithreading

##### **How many ways we can call a method in C#?**

In C#, we can call a method that is defined in a class in two ways. They are as follows:

1. We can call the method using the object of the class if it is a non-static method or we can call the method through the class name if it is a static method.
2. We can also call a method in C# by using delegates. Calling a C# method using delegate will be faster in execution as compared to the first process i.e. either by using an object or by using the class name.


##### **What is Multicast Delegate in C#?**

A Multicast Delegate in C# is a delegate that holds the references of more than one handler function. When we invoke the multicast delegate, then all the functions which are referenced by the delegate are going to be invoked. If you want to call multiple methods using a delegate then all the method signatures should be the same. 

So, a multicast delegate is just an array of multiple pipelines or multiple delegates. The delegates are going to be invoked in the same order as they are placed in the invocation list. An InvocationList is nothing but an array of delegates or pipelines where each pipeline will dump data into a different method. If this is not clear at the moment don’t worry, we will try to understand this with multiple examples.

##### **Example to Understand Multicast Delegate in C#**

Let us see an example to understand the Multicast Delegate in C#. Please have a look at the following example which is without using delegates. In the below example, we created two methods, and then from the main method, we are creating the instance of the class and then invoke the two methods.

```c#
using System;
namespace MulticastDelegateDemo
{
    public class Rectangle
    {
        public void GetArea(double Width, double Height)
        {
            Console.WriteLine($"Area is {Width * Height}");
        }
        public void GetPerimeter(double Width, double Height)
        {
            Console.WriteLine($"Perimeter is {2 * (Width + Height)}");
        }
        static void Main(string[] args)
        {
            Rectangle rect = new Rectangle();
            rect.GetArea(23.45, 67.89);
            rect.GetPerimeter(23.45, 67.89);
            Console.ReadKey();
        }
    }
}
```

In the above example, we created an instance of the Rectangle class and then called the two methods. Now I want to create a single delegate that is going to invoke the above two methods (i.e. GetArea and GetPerimeter). The two methods have the same signature with different method names, so we can create a single delegate that holds the reference of the above two methods. And when we invoke the delegate, it is going to invoke the above two methods. And when we do so, then it is called a Multicast Delegate in C#.

##### **Multicast Delegate Example in C#:**

In the below example, we have created one delegate whose signature is the same as the two methods i.e. GetArea and GetPerimeter. Then we created the instance of delegate and bind the two methods using the += operator. Similarly, you can use the -= operator to remove a function from the delegate. Once we bind the two methods with the delegate instance and when we call the delegate, both methods are going to be executed. In this case, behind the scene, when we add multiple methods to the delegate, then multiple pipelines are added. In other words, we can now say that the InvocationList now contains two delegates or two pipelines in the same order we add the methods. In this case, the first delegate or pipeline will dump the data into the GetArea method and the second pipeline will dump the data into the GetPerimeter method, and when you will run the application, then you will see that the GetArea method is first executed, and then the GetPerimeter method is going to be executed. And in InvocationList, you will see that we have two pipelines or delegates having the same name in this example.


```C#
using System;
namespace MulticastDelegateDemo
{
    public delegate void RectangleDelegate(double Width, double Height);
    public class Rectangle
    {
        public void GetArea(double Width, double Height)
        {
            Console.WriteLine($"Area is {Width * Height}");
        }
        public void GetPerimeter(double Width, double Height)
        {
            Console.WriteLine($"Perimeter is {2 * (Width + Height)}");
        }
        static void Main(string[] args)
        {
            Rectangle rect = new Rectangle();
            RectangleDelegate rectDelegate = new RectangleDelegate(rect.GetArea);
            // RectangleDelegate rectDelegate = rect.GetArea;

            // binding a method with delegate object
            // In this example rectDelegate is a multicast delegate. 
            // You use += operator to chain delegates together.

            rectDelegate += rect.GetPerimeter;

            Delegate[] InvocationList = rectDelegate.GetInvocationList();
            Console.WriteLine("InvocationList:");
            foreach (var item in InvocationList)
            {
                Console.WriteLine($"  {item}");
            }

            Console.WriteLine();
            Console.WriteLine("Invoking Multicast Delegate:");
            rectDelegate(23.45, 67.89);
            //rectDelegate.Invoke(13.45, 76.89);
            
            Console.WriteLine();
            Console.WriteLine("Invoking Multicast Delegate After Removing one Pipeline:");
            //Removing a method from delegate object
            rectDelegate -= rect.GetPerimeter;
            rectDelegate.Invoke(13.45, 76.89);

            Console.ReadKey();
        }
    }
}

```

##### **Another Approach to Creating Multicast Delegates in C#:**

In the below example, I am going to show you the use of both static and non-static methods along with different ways to create and invoke multicast delegates in C#. Please have a look at the below example. Here, we created one delegate which takes two integer parameters and returns nothing. Then within the program class, we define four methods and all these four methods take two integer parameters and return nothing i.e. void. Then we created four instances of the delegate and bind the four methods. Finally, we create the fifth delegate instance and to this instance, we are binding all four delegate instances using the + operator. Now, the fifth delegate becomes a multicast delegate. In this case, for delegate 5, the InvocationList has 4 delegates or you can say 4 pipelines where each pipeline or delegate is going to dump the data into a different method. And when we invoke the fifth delegate instance then all four methods are going to be executed. If you want to remove one method binding, then simply you need to use the -= operator and specify the delegate instance which you want to remove.
```C#
using System;

namespace MulticastDelegateDemo
{
    public delegate void MathDelegate(int No1, int No2);

    public class Program
    {
        //Static Method
        public static void Add(int x, int y)
        {
            Console.WriteLine($"Addition of {x} and {y} is : {x + y}");
        }
        //Static Method
        public static void Sub(int x, int y)
        {
            Console.WriteLine($"Subtraction of {x} and {y} is : {x - y}");
        }
        //Non-Static Method
        public void Mul(int x, int y)
        {
            Console.WriteLine($"Multiplication of {x} and {y} is : {x * y}");
        }
        //Non-Static Method
        public void Div(int x, int y)
        {
            Console.WriteLine($"Division of {x} and {y} is : {x / y}");
        }

        static void Main(string[] args)
        {
            Program p = new Program();
            //Static Method within the same class can be access directly
            MathDelegate del1 = new MathDelegate(Add);
            //Static Method can be access using class name
            MathDelegate del2 = new MathDelegate(Program.Sub);
            //Non-Static Method must be access through object 
            MathDelegate del3 = new MathDelegate(p.Mul); 
            MathDelegate del4 = new MathDelegate(p.Div); ;

            //In this example del5 is a multicast delegate. 
            //We can use +(plus) operator to chain delegates together and 
            //-(minus) operator to remove a delegate.
            MathDelegate del5 = del1 + del2 + del3 + del4;

            Delegate[] InvocationList = del5.GetInvocationList();
            Console.WriteLine("InvocationList:");
            foreach (var item in InvocationList)
            {
                Console.WriteLine($" {item}");
            }
            Console.WriteLine();

            Console.WriteLine("Invoking Multicast Delegate::");
            del5.Invoke(20, 5);
            Console.WriteLine();

            Console.WriteLine("Invoking Multicast Delegate After Removing one Delegate:");
            del5 -= del2;
            del5(22, 7);

            Console.ReadKey();
        }
    }
}
```

##### **Multicast Delegates with Return Type in C#:**

A multicast delegate invokes the methods in the same order in which they are added to the Invocation List and that we have already seen. As of now, the examples we have discussed using Multicast delegate, are not returning anything i.e. the return type is void. Now, what happens if the delegate has a return type?

If the delegate has a return type other than void, and if the delegate is a multicast delegate, then only the value of the last invoked method will be returned. Along the same lines, if the delegate has an out parameter, the value of the output parameter will be the value assigned by the last invoked method from the Invocation List.

##### **Example to Understand Multicast Delegates with Return Type in C#**

Let’s understand Multicast Delegates with Return Type in C# with an example. Please have a look at the below example. Here, we created one delegate which does not take any parameter but its return type is int. Then we created two static methods, the first static method returns 1 and the second static method returns 2. Then we created the delegate instance and first we bind MethodOne and then we bind MethodTwo. And when we invoke the delegate, first MethodOne is executed and then MethodTwo is executed and it returns 2 as the last invoked method in the InvocationList is MethodTwo which returns 2.

```C#
using System;
namespace MulticastDelegateDemo
{
    // Deletegate's return type is int
    public delegate int SampleDelegate();
    public class Program
    {
        static void Main()
        {
            SampleDelegate del = new SampleDelegate(MethodOne);
            del += MethodTwo;
            
            // The Value Returned By Delegate will be 2, returned by the MethodTwo(),
            // as it is the last method in the invocation list.
            int ValueReturnedByDelegate = del();
            Console.WriteLine($"Returned Value = {ValueReturnedByDelegate}");

            Console.ReadKey();
        }
        // This method returns one
        public static int MethodOne()
        {
            Console.WriteLine("MethodOne is Executed");
            return 1;
        }

        // This method returns two
        public static int MethodTwo()
        {
            Console.WriteLine("MethodTwo is Executed");
            return 2;
        }
    }
}
```

##### **Example to Understand Multicast Delegates using out Parameter in C#:**

Now we will see an example of a Multicast delegate in C# using the out parameter. Please have a look at the below example. Here, we created one delegate which takes one out parameter and returns nothing i.e. void. Then we created two static methods and both the static methods take one out parameter. The first static method assigns value 1 to the out parameter and the second static method assigns value 2 to the out parameter. Then we created the delegate instance and first bind MethodOne and then bind MethodTwo. And when we invoke the delegate, first MethodOne is executed and then MethodTwo is executed and it returns 2 as the last invoked method is MethodTwo which assigns value 2 to the out parameter.

```C#
using System;
namespace MulticastDelegateDemo
{
    // Deletegate has an int output parameter
    public delegate void SampleDelegate(out int Integer);

    public class Program
    {
        static void Main()
        {
            SampleDelegate del = new SampleDelegate(MethodOne);
            del += MethodTwo;

            // The ValueFromOutPutParameter will be 2, initialized by MethodTwo(),
            // as it is the last method in the invocation list.
            int ValueFromOutPutParameter = -1;
            del(out ValueFromOutPutParameter);

            Console.WriteLine($"Returned Value = {ValueFromOutPutParameter}");
            Console.ReadKey();
        }

        // This method sets ouput parameter Number to 1
        public static void MethodOne(out int Number)
        {
            Console.WriteLine("MethodOne is Executed");
            Number = 1;
        }

        // This method sets ouput parameter Number to 2
        public static void MethodTwo(out int Number)
        {
            Console.WriteLine("MethodTwo is Executed");
            Number = 2;
        }
    }
}

```

##### **Delegate Real-Time Example1 in C#:**

Let’s say we have a class called Worker and this class has a method called DoWork. What our business requirement is when we invoke the DoWork method, we need to send a notification about the percentage of work done to the consumer as well as once the work is completed, we also need to send the notification. For example, how much work is done in 1 hour, how much work is done in 2 hours, how much work is done in 3 hours, and so on until the work is completed? And the DoWork method has no idea to whom to send the notifications. The caller of the DoWork method should decide to whom to send the notification. That means here we need to use call-back functions.

This is an ideal scenario where we need to use delegates. So, create a class file with the name Worker,cs and then copy and paste the following code into it. Here, you can see that we have created two delegates. You can create delegates anywhere and you can also create delegates within the class or directly inside the namespace. This is because behind the scene the delegates are classes only. The DoWork method takes four parameters, out of the four, two parameters are of the delegate type. Then within the method, we are using a for loop and each time the loop executes, we are processing some work and notifying the user by invoking the delegate. Once. The loop execution is completed, which means our work is done, and then we are invoking the work completed delegate to notify the user that the work has been done.

```C#
using System.Threading;
namespace DelegatesRealTimeExample
{
    public delegate void WorkPerformedHandler(int hours, string workType);
    public delegate void WorkCompletedHandler(string workTyp);
    public class Worker
    {
        public void DoWork(int hours, string workType, WorkPerformedHandler del1, WorkCompletedHandler del2)
        {
            //Do Work here and notify the consumer that work has been performed
            for (int i = 0; i < hours; i++)
            {
                //Do Some Processing
                Thread.Sleep(1000);
                //Notfiy how much works have been done
                del1(i+1, workType);
            }

            //Notfiy the consumer that work has been completed
            del2(workType);
        }
    }
}

```

Now, modify the Program class as follows. Here, we are creating two call-back methods with the same signature as our delegates. Then we are creating instances of delegate and also we are creating an instance of the Worker class and invoking the DoWork method by passing the required values along with the two delegate instances.

```C#
using System;
namespace DelegatesRealTimeExample
{
    class Program
    {
        static void Main(string[] args)
        {
            WorkPerformedHandler del1 = new WorkPerformedHandler(Worker_WorkPerformed);
            WorkCompletedHandler del2 = new WorkCompletedHandler(Worker_WorkCompleted);

            Worker worker = new Worker();
            worker.DoWork(5, "Generating Report", del1, del2);
            Console.ReadKey();
        }

        //Delegate Signature must match with the method signature
        static void Worker_WorkPerformed(int hours, string workType)
        {
            Console.WriteLine($"{hours} Hours compelted for {workType}");
        }

        static void Worker_WorkCompleted(string workType)
        {
            Console.WriteLine($"{workType} work compelted");
        }
    }
}

```

That is working fine. Now, if you go to the Worker class and within the DoWork method, then it allows you to make the delegate instance null.

```C#
using System.Threading;
namespace DelegatesRealTimeExample
{
    public delegate void WorkPerformedHandler(int hours, string workType);
    public delegate void WorkCompletedHandler(string workTyp);
    public class Worker
    {
        public void DoWork(int hours, string workType, WorkPerformedHandler del1, WorkCompletedHandler del2)
        {
            del1 = null; //Allowing to set null
            del2 = null; //Allowing to set null

            //Do Work here and notify the consumer that work has been performed
            for (int i = 0; i < hours; i++)
            {
                //Do Some Processing
                Thread.Sleep(1000);
                //Notfiy how much works have been done
                del1(i + 1, workType);
            }

            //Notfiy the consumer that work has been completed
            del2(workType);
        }
    }
}

```

So, here, if the Worker class not creating the instance and if the Worker class has no idea about the methods to whom he sends notifications, then it should not allow making the delegate instance null. How we can restrict this? By using [**Events in C#**](https://dotnettutorials.net/lesson/events-in-csharp/) and which we will discuss in our next article.

##### **Delegates Real-Time Example2 in C#:**

Now, we will see another real-time example of delegates in C#. Let us say we have a class called Employee as shown below.

```C#
namespace DelegateRealtimeExample
{
    public class Employee
    {
        public int ID { get; set; }
        public string Name { get; set; }
        public string Gender { get; set; }
        public int Experience { get; set; }
        public int Salary { get; set; }
    }
}

```

The above Employee class has the following properties. 

1. **Id**
2. **Name**
3. **Gender**
4. **Experience**
5. **Salary**

Now I want to write a method in the Employee class which can be used to promote the employees. The method that we are going to write will take a list of Employee objects as a parameter and then should print the names of all those employees who are eligible for a promotion.

But the logic based on which the employee gets promoted should not be hard coded. At times we may promote employees based on their experience and at times we may promote the employees based on their salary or maybe based on some other reason like the performance of the employee. So, the logic to promote the employees should not be hard-coded within the method.

How we can achieve this? This can be achieved very easily with the help of delegates. So, now I need to design my Employee class as shown below.

```C#
using System;
using System.Collections.Generic;

namespace DelegateRealtimeExample
{
    public delegate bool EligibleToPromotion(Employee EmployeeToPromotion);

    public class Employee
    {
        public int ID { get; set; }
        public string Name { get; set; }
        public string Gender { get; set; }
        public int Experience { get; set; }
        public int Salary { get; set; }

        public static void PromoteEmployee(List<Employee> lstEmployees, EligibleToPromotion IsEmployeeEligible)
        {
            foreach (Employee employee in lstEmployees)
            {
                if (IsEmployeeEligible(employee))
                {
                    Console.WriteLine($"Employee {employee.Name} Promoted");
                }
            }
        }
    }
}

```

In the above code, we have created a delegate called EligibleToPromotion. This delegate takes the Employee object as a parameter and returns a boolean value indicating whether the employee is promoted or not. In the Employee class, we also created the PromoteEmpoloyee method and this method takes a list of Employees and a Delegate of the type EligibleToPromotion as parameters.

Then, the PromoteEmployee method loops through each employee’s object and passes it to the delegate. If the delegate returns true, then the Employee is promoted, else not promoted. So, within the method, we have not hardcoded any logic on how we want to promote employees.

Now the client who uses the Employee class has the flexibility of determining the logic of how they want to promote their employees. First create the employee objects – emp1, emp2, and emp3. Populate the properties for the respective objects. Then create an employee List to hold all the 3 employees as shown below.

```C#
using System;
using System.Collections.Generic;

namespace DelegateRealtimeExample
{
    public class Program
    {
        static void Main()
        {
            Employee emp1 = new Employee()
            {
                ID = 101,
                Name = "Pranaya",
                Gender = "Male",
                Experience = 5,
                Salary = 10000
            };

            Employee emp2 = new Employee()
            {
                ID = 102,
                Name = "Priyanka",
                Gender = "Female",
                Experience = 10,
                Salary = 20000
            };

            Employee emp3 = new Employee()
            {
                ID = 103,
                Name = "Anurag",
                Experience = 15,
                Salary = 30000
            };

            List<Employee> lstEmployess = new List<Employee>();
            lstEmployess.Add(emp1);
            lstEmployess.Add(emp2);
            lstEmployess.Add(emp3);

            EligibleToPromotion eligibleTopromote = new EligibleToPromotion(Program.Promote);
            Employee.PromoteEmployee(lstEmployess, eligibleTopromote);

            Console.ReadKey();
        }

        public static bool Promote(Employee employee)
        {
            if (employee.Salary > 10000)
            {
                return true;
            }
            else
            {
                return false;
            }
        }
    }
}

```

Notice the Promote method that we have created. This method has the logic of how we want to promote our employees. The method is then passed as a parameter to the delegate. Also, note this method has the same signature as that of the EligibleToPromotion delegate. This is very important because the Promote method cannot be passed as a parameter to the delegate if the signature differs. This is the reason why delegates are called type-safe function pointers.

So, if we did not have the concept of delegates, it would not have been possible to pass a function as a parameter. As Promote method in the Employee class makes use of delegates, it is possible to dynamically decide the logic of how we want to promote employees.

In C# 3.0 Lambda expressions are introduced. So, you can make use of lambda expressions instead of creating a function and then an instance of a delegate and then passing the function as a parameter to the delegate. The following example is rewritten using the Lambda expression. The Private Promote method is no longer required now.

```c#
using System;
using System.Collections.Generic;
namespace DelegateRealtimeExample
{
    public class Program
    {
        static void Main()
        {
            Employee emp1 = new Employee()
            {
                ID = 101,
                Name = "Pranaya",
                Gender = "Male",
                Experience = 5,
                Salary = 10000
            };

            Employee emp2 = new Employee()
            {
                ID = 102,
                Name = "Priyanka",
                Gender = "Female",
                Experience = 10,
                Salary = 20000
            };

            Employee emp3 = new Employee()
            {
                ID = 103,
                Name = "Anurag",
                Experience = 15,
                Salary = 30000
            };

            List<Employee> lstEmployess = new List<Employee>();
            lstEmployess.Add(emp1);
            lstEmployess.Add(emp2);
            lstEmployess.Add(emp3);

            Employee.PromoteEmployee(lstEmployess, x => x.Experience > 5);
            Console.ReadKey();
        }
    }
} 

```

# Generic Delegates

The Generic Delegates in C# were introduced as part of .NET Framework 3**.**5 which doesn’t require defining the delegate instance in order to invoke the methods. To understand the Generic Delegates in C# you should have the basic knowledge of [**Delegates**](https://dotnettutorials.net/lesson/delegates-csharp/).

##### **Types of Generic Delegates in C#**

C# provides three built-in generic delegates, they are as follows:

1. **Func**
2. **Action**
3. **Predicate**

##### **Why do we need the Generic Delegates in C#?**

Let us understand the need for Generic Delegates in C# with an example. In order to understand this, let us first understand how we use delegates to invoke methods. Let us say we have the following three methods and we want to invoke these methods using delegates.

![[word-image-29911-1-9.webp]]

As you can see in the above code, the **AddNumber1** method takes three parameters and returns a value of double type. Similarly, the **AddNumber2** method takes three parameters but it does not return any value and here the return type is void. The third method i.e. the **CheckLength** method takes one string parameter and returns a Boolean value. If the string length is greater than 5, then it will return true else it will return false.

Now, if we want to invoke the above three methods using delegates in C#, then we need to create three delegates whose signatures should match the signatures of the above three methods as shown in the below image.

![[word-image-29911-2-7-1024x140.webp]]

As you can see in the above image, we create three delegates. Now, once we have created the delegates. then we can invoke the methods by creating instances of each delegate referring to the respective methods and then we can invoke the delegate as shown in the below code.

![[word-image-29911-3-9.webp]]
##### **Example to Invoke Methods using Custom Delegate in C#:**

Whatever we have discussed as of now, the complete code is given below.

```C#
using System;
namespace GenericDelegatesDemo
{
    public class GenericDelegates
    {
        public delegate double AddNumber1Delegate(int no1, float no2, double no3);
        public delegate void AddNumber2Delegate(int no1, float no2, double no3);
        public delegate bool CheckLengthDelegate(string name);

        static void Main(string[] args)
        {
            AddNumber1Delegate obj1 = new AddNumber1Delegate(AddNumber1);
            double Result = obj1.Invoke(100, 125.45f, 456.789);
            Console.WriteLine(Result);

            AddNumber2Delegate obj2 = new AddNumber2Delegate(AddNumber2);
            obj2.Invoke(50, 255.45f, 123.456);

            CheckLengthDelegate obj3 = new CheckLengthDelegate(CheckLength);
            bool Status = obj3.Invoke("Pranaya");
            Console.WriteLine(Status);

            Console.ReadKey();
        }

        public static double AddNumber1(int no1, float no2, double no3)
        {
            return no1 + no2 + no3;
        }

        public static void AddNumber2(int no1, float no2, double no3)
        {
            Console.WriteLine(no1 + no2 + no3);
        }

        public static bool CheckLength(string name)
        {
            if (name.Length > 5)
                return true;
            return false;
        }
    }
}


```

As of now, this is the way, we use delegates to invoke methods. The question that comes to our mind is do we really need to create custom Delegates to invoke the methods in C#?

##### **Do we really need to create Custom Delegates to Invoke Methods in C#?**

The answer is no. C#.NET Framework provides some generic delegates who can do the job for us. C# provides three Generic Delegates; they are as follows

1. **Func**
2. **Action**
3. **Predicate**

Now, let us proceed and try to understand all the above three generic delegates. Let us try to understand what are all these delegates, when, and how to use all these generic delegates in C# with examples.

##### **What is Func Generic Delegate in C#?**

The Func Generic Delegate in C# is present in the System namespace. This delegate takes one or more input parameters and returns one out parameter. The last parameter is considered as the return value. The Func Generic Delegate in C# can take up to 16 input parameters of different or the same data types. It must have one return type. The return type is mandatory but the input parameter is not mandatory.

**Note:** Whenever your delegate returns some value, whether by taking any input parameter or not, you need to use the Func Generic delegate in C#.

##### **What is Action Generic Delegate in C#?**

The Action Generic Delegate in C# is also present in the System namespace. It takes one or more input parameters and returns nothing. This delegate can take a maximum of 16 input parameters of the different or same data types.

**Note:** Whenever your delegate does not return any value, whether by taking any input parameter or not, then you need to use the Action Generic delegate in C#.

##### **What is Predicate Generic Delegate in C#?**

The Predicate Generic Delegate in C# is also present in the System namespace. This delegate is used to verify certain criteria of the method and returns the output as Boolean, either True or False. It takes one input parameter and always returns a Boolean value which is mandatory. This delegate can take a maximum of 1 input parameter and always return the value of the Boolean type.

**Note:** Whenever your delegate returns a Boolean value, by taking only one input parameter, then you need to use the Predicate Generic delegate in C#.

##### **Examples to understand Generic Delegates in C#.**

Let us understand the above three generic delegates in C# with an example. In our first example, we created three methods,

1. The **AddNumber1** method takes three parameters and returns a **double** value. Here we will use the **Func Generic Delegate** to achieve the same thing as we achieve in the first example.
2. Similarly, the **AddNumber2** method takes three parameters but does not return any value. Here we will use the **Action Generic Delegate** to achieve the same thing as we achieve in the first example.
3. The **CheckLength** method takes one string input parameter and returns a boolean value. Here we will use the **Predicate Generic Delegate** to achieve the same thing as we achieve in the first example.

Let us first remove the three Delegates that we created in our application and see how can we convert the same application using the generic delegates.

##### **How to use Func Generic Delegate in C#?**

The Func Generic Delegate in C# is used whenever your delegate returns some value, whether by taking any input parameter or not. In our example, the AddNumber1 method takes some input and returns one output. So, the AddNumber1 method signature is matched with the Func generic delegate signature. So, here, instead of creating our own delegate to invoke the AddNumber1 method, we can use the Func generic delegate to invoke the AddNumber1 method as shown in the below code.

![[word-image-29911-5-6.webp]]

As shown in the above code, the Func Generic Delegate takes four parameters, the first three are input parameters and the last one is the return value. To the Func Generic Delegate constructor, we pass the AddNumber1 method which is going to execute when we invoke the Func delegate.

##### **How to use Action Generic Delegate in C#?**

The Action Generic Delegate in C# is used whenever your delegate does not return any value, whether by taking any input parameter or not. In our example, the AddNumber2 method takes some input but does not return any value. So, the AddNumber2 method signature is matched with the Action generic delegate signature. So, here, instead of creating our own delegate to invoke the AddNumber2 method, we can use the Action generic delegate to invoke the AddNumber2 method as shown in the below code.

![[word-image-29911-6-5.webp]]

As shown in the above code, the Action Generic Delegate takes three input parameters. To the Action Generic Delegate constructor, we pass the AddNumber2 method which is going to execute when we invoke the Action delegate. The Action Generic Delegate never going to return any value.

##### **How to use Predicate Generic Delegate in C#?**

The Predicate Generic Delegate in C# is used whenever your delegate returns a Boolean value, by taking only one input parameter. In our example, the CheckLength method takes one input parameter of string type and returns a Boolean value. So, the CheckLength method signature is matched with the Predicate generic delegate signature. So, here, instead of creating our own delegate to invoke the CheckLength method, we can use the Predicate generic delegate to invoke the CheckLength method as shown in the below code.

![[word-image-29911-7-3.webp]]
As shown in the above code, the Predicate Generic Delegate takes one string input parameter. To the Predicate Generic Delegate constructor, we pass the CheckLength method which is going to execute when we invoke the Predicate Generic delegate. This delegate can take a maximum of 1 input parameter and 0 return values. By default, it returns a Boolean value.

##### **Example to Understand Func, Action, and Predicate Generic Delegates in C#:**

Whatever we have discussed, let us put all these things into our application. In the following example, we are using the three generic delegates instead of our own custom delegate to invoke the three methods.


```C#
using System;
namespace GenericDelegateDemo
{
    public class GenericDelegates
    {
        static void Main(string[] args)
        {
            Func<int, float, double, double> obj1 = new Func<int, float, double, double>(AddNumber1);
            double Result = obj1.Invoke(100, 125.45f, 456.789);
            Console.WriteLine(Result);

            Action<int, float, double> obj2 = new Action<int, float, double>(AddNumber2);
            obj2.Invoke(50, 255.45f, 123.456);

            Predicate<string> obj3 = new Predicate<string>(CheckLength);
            bool Status = obj3.Invoke("Pranaya");
            Console.WriteLine(Status);

            Console.ReadKey();
        }

        public static double AddNumber1(int no1, float no2, double no3)
        {
            return no1 + no2 + no3;
        }

        public static void AddNumber2(int no1, float no2, double no3)
        {
            Console.WriteLine(no1 + no2 + no3);
        }

        public static bool CheckLength(string name)
        {
            if (name.Length > 5)
                return true;
            return false;
        }
    }
}

```

##### **Generic Delegates with Lambda Expression in C#:**

Let us see how to use Lambda Expression along with Generic Delegates in C#. The following is the same example as the previous example. But in this case, while creating the instance of generic delegates, instead of the methods, we are using lambda expressions and when we invoke the delegate, the respective lambda expression is going to be executed.

```C#
using System;
namespace GenericDelegateDemo
{
    public class GenericDelegates
    {
        static void Main(string[] args)
        {
            Func<int, float, double, double> obj1 = (x, y, z) =>
            {
                return x + y + z;
            };

            double Result = obj1.Invoke(100, 125.45f, 456.789);
            Console.WriteLine(Result);

            Action<int, float, double> obj2 = (x, y, z) =>
            {
                Console.WriteLine(x + y + z);
            };
            obj2.Invoke(50, 255.45f, 123.456);

            Predicate<string> obj3 = new Predicate<string>(CheckLength);
            bool Status = obj3.Invoke("Pranaya");
            Console.WriteLine(Status);

            Console.ReadKey();
        }
        public static bool CheckLength(string name)
        {
            if (name.Length > 5)
                return true;
            return false;
        }
    }
}

```


##### **Points to Remember while working with C# Generic Delegates:**

1. Func, Action, and Predicate are Generic Inbuilt delegates that are present in the System namespace which is introduced in C# 3.
2. All these three delegates can be used with the method, [**Anonymous Method**](https://dotnettutorials.net/lesson/anonymous-method-c-sharp/), and [**Lambda Expressions**](https://dotnettutorials.net/lesson/lambda-expression-csharp/) in C#.
3. The Func delegates can contain a maximum of 16 input parameters and must have one return type and that will be the last parameter in the parameter list.
4. Action delegate can contain a maximum of 16 input parameters and does not have any return type.
5. The Predicate delegate should satisfy some criteria of a method and must have only one input parameter. By default, it is having one output parameter of return type and we don’t have to pass the output parameter to the Predicate.
