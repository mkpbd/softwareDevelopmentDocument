##### **What is Thread Class in C#?**

The Thread class in C# is responsible for creating custom threads. With the help of the Thread class, we can create both foreground and background threads. What are the [**foreground and background threads**](https://dotnettutorials.net/lesson/foreground-and-background-threads-in-csharp/) that we are going to discuss in our coming articles? The Thread class also allowed us to set the priority of a thread. In our coming session, we will discuss [**how to set the priority of a thread**](https://dotnettutorials.net/lesson/threads-priorities-in-csharp/).

If you go to the definition of the Thread class, then you will see that is a sealed class and as it is a sealed class, this class cannot be inherited i.e. further inheritance is not possible. The Thread class in C# provides lots of useful properties, methods, and constructors, which we are going to discuss in this article.

##### **Thread Class Properties in C#:**

The Thread class in C# provides lots of properties. Some of the important properties are as follows:

1. **CurrentThread**: This property is used to get the currently running thread. It returns a Thread that is the representation of the currently running thread.
2. **IsAlive**: This property is used to get a value indicating the execution status of the current thread. It returns true if this thread has been started and has not terminated normally or aborted; otherwise, false.
3. **IsBackground**: This property is used to get or set a value indicating whether or not a thread is a background thread. It returns true if this thread is or is to become a background thread; otherwise, false.
4. **ManagedThreadId**: This property is used to get a unique identifier for the current managed thread. It returns an integer that represents a unique identifier for this managed thread.
5. **Name**: This property is used to get or set the name of the thread. It returns a string containing the name of the thread, or null if no name was set.
6. **Priority**: This property is used to get or set a value indicating the scheduling priority of a thread. It returns one of the System.Threading.ThreadPriority values. The default value is System.Threading.ThreadPriority.Normal.
7. **ThreadState**: This property is used to get a value containing the states of the current thread. It returns one of the System.Threading.ThreadState values indicate the state of the current thread. The initial value is Unstarted.
8. **IsThreadPoolThread**: This property is used to get a value indicating whether or not a thread belongs to the managed thread pool. It returns true if this thread belongs to the managed thread pool; otherwise, false.

##### **Thread Class Methods in C#:**

The Thread class in C# provides lots of methods. Some of the important methods are as follows:

1. **Abort():** This method is used to terminate the thread. Raises a ThreadAbortException in the thread on which it is invoked, to begin the process of terminating the thread. Calling this method usually terminates the thread.
2. **Interrupt():** This method is used to interrupt a thread that is in the WaitSleepJoin thread state.
3. **Join():** This method is used to block the calling thread until the thread represented by this instance terminates while continuing to perform standard COM and SendMessage pumping.
4. **ResetAbort():** This method is used to an System.Threading.Thread.Abort(System.Object) requested for the current thread.
5. **Resume():** This method is used to resume a thread that has been suspended.
6. **Sleep(Int32):** This method is used to suspend the current thread for the specified number of milliseconds.
7. **Start():** This method causes the operating system to change the state of the current instance to System.Threading.ThreadState.Running.
8. **Suspend():** This method is used to either suspend the thread or if the thread is already suspended, have no effect
9. **Yield():** This method causes the calling thread to yield execution to another thread that is ready to run on the current processor. The operating system selects the thread to yield to. It returns true if the operating system switched execution to another thread; otherwise, false.

##### **Thread Class Constructors in C#:**

The Thread class in C# provides the following 4 constructors.

1. **Thread(ThreadStart start):** It initializes a new instance of the Thread class. Here, the parameter start specifies a ThreadStart delegate that represents the methods to be invoked when this thread begins executing. It will throw ArgumentNullException, the start parameter is null.
2. **Thread(ParameterizedThreadStart start):** It initializes a new instance of the Thread class, specifying a delegate that allows an object to be passed to the thread when the thread is started. Here, the parameter start specifies a delegate that represents the methods to be invoked when this thread begins executing. It will throw ArgumentNullException, the start parameter is null.
3. **Thread(ThreadStart start, int maxStackSize):** It initializes a new instance of the Thread class, specifying the maximum stack size for the thread. Here, the parameter start specifies a ThreadStart delegate that represents the methods to be invoked when this thread begins executing. And the parameter maxStackSize specifies the maximum stack size, in bytes, to be used by the thread, or 0 to use the default maximum stack size specified in the header for the executable. Important For partially trusted code, maxStackSize is ignored if it is greater than the default stack size. No exception is thrown.
4. **Thread(ParameterizedThreadStart start, int maxStackSize):** It initializes a new instance of the Thread class, specifying a delegate that allows an object to be passed to the thread when the thread is started and specifies the maximum stack size for the thread.

**Note:** In this article, I am going to discuss the Thread class constructors in detail with examples and the methods and properties of thread class are going to be discussed in our subsequent articles.

##### **Example to Understand Constructors of Thread Class in C#.**

Let us understand the constructors of the thread class in C# with an example. Please have a look at the following code. It’s a very simple program and here we are executing the DisplayNumbers function using a different thread.

```C#
using System.Threading;
using System;
namespace ThreadingDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            Thread t1 = new Thread(DisplayNumbers);
            t1.Start();
            Console.Read();
        }

        static void DisplayNumbers()
        {
            for (int i = 1; i <= 5; i++)
            {
                Console.WriteLine("Method1 :" + i);
            }
        }
    }
}

```

As you can see in the above code, here, we created an instance of the Thread class and to the constructor of the Thread class, we passed the method name that we want the thread to execute. The following line of code exactly does the same.

**Thread t1 = new Thread(DisplayNumbers);**

##### **Constructors of Thread Class in C#:**

As discussed earlier, in C#, the Thread class contains four constructors. If you go to the definition of Thread class then you will see the Constructors as shown below.

![[word-image-29911-1-12.webp]]
Now you may have one question, the Thread class constructor which takes one parameter is either of the type ThreadStart or ParameterizedThreadStart, but in our example, we are passing the method name as a parameter to the Thread class Constructor and it works, how? To understand this, let us go to the definition of ThreadStart and you will see that ThreadStart is actually a delegate as shown in the below image.
![[threadstart-delegate-in-c.webp]]
##### **Why is the Constructor of the Thread class Taking a Parameter of Delegate Type?**

As we already discussed, the main objective of creating a Thread in C# is to execute a function. A delegate is a type-safe function pointer. It means the delegate points to a function and when we invoke the delegate, the function which is pointed by the delegate is going to be executed.

In simple words, we can say that all the threads that we create require an entry point (i.e. a pointer to the function) from where it should execute. This is the reason why threads always require a delegate. If you want to learn [**Delegates in C#**](https://dotnettutorials.net/lesson/delegates-csharp/) with Examples, then I strongly recommended you read our [**Delegates in C#**](https://dotnettutorials.net/lesson/delegates-csharp/) article.

**Note:** We already discussed in our Delegates article that the signature of the delegate should and must be the same as the signature of the method it points to.

As you can see, the ThreadStart delegate does not take any parameter and the return type is void. In our example, the DisplayNumbers() function signature is the same as the ThreadStart delegate signature as the DisplayNumbers() function return type is void as well as it does not take any parameters.

**Thread t1 = new Thread(DisplayNumbers);**

So, the above thread instance creation statement is implicitly converted to the ThreadStart delegate instance. So, you can write the above statement as shown in the below image and it will work.

![Thread Class in C#](https://dotnettutorials.net/wp-content/uploads/2022/09/word-image-29911-3-12.png?ezimgfmt=rs:545x170/rscb8/ng:webp/ngcb8 "Thread Class in C#")

As you can see in the above image, it is a two steps process. First, we need to create the ThreadStart Delegate Instance and while creating the instance, to its constructor we need to pass the method name that we want to execute. In the second step, to the Constructor of Thread class, we need to pass the ThreadStart instance as a parameter. And when we start the Thread execution by calling the Start method on the thread instance, internally it will invoke the ThreadStart delegate instance which internally start the execution of the DisplayNumbers method.

##### **Example to Understand ThreadStart Delegate in C#:**

In the below example, first, we are creating an instance of ThreadStart delegate and to the constructor of ThreadStart delegate, we pass the DisplayNumbers function as a parameter. Then we create an instance of the Thread class and to the constructor of the Thread class, we pass the ThreadStart delegate instance as a parameter that points to the DisplayNumbers function. Finally, when we call the Start method on the Thread instance, which will invoke the ThreadStart delegate instance and the delegate instance will invoke the method it points to i.e. the DisplayNumbers function is going to start its execution.

```C#
using System.Threading;
using System;
namespace ThreadingDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            //Creating the ThreadStart Delegate instance by passing the
            //method name as a parameter to its constructor
            ThreadStart obj = new ThreadStart(DisplayNumbers);

            //Passing the ThreadStart Delegate instance as a parameter to its constructor
            Thread t1 = new Thread(obj);

            t1.Start();
            Console.Read();
        }

        static void DisplayNumbers()
        {
            for (int i = 1; i <= 5; i++)
            {
                Console.WriteLine("Method1 :" + i);
            }
        }
    }
}

```

![[threadstart-delegate-with-a-single-statement.webp]]
##### **Creating Thread Class Instance using Anonymous Method in C#:**

It is also possible to create a Thread class instance by using the anonymous method as shown in the below example. We know that Anonymous methods are created by using the delegate keyword and they are assigned to a type of delegate.

```C#
using System.Threading;
using System;
namespace ThreadingDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            //Creating Thread Class Instance using Lambda Expression
            Thread t1 = new Thread(delegate ()
            {
                for (int i = 1; i <= 5; i++)
                {
                    Console.WriteLine("Method1 :" + i);
                }
            });
            t1.Start();
            Console.Read();
        }
    }
}

```

##### **Creating Thread Class Instance using Lambda Expression in C#:**

It is also possible to create the thread class instance by using the lambda expression as shown in the below example. We know that Lambda Expressions are created by using the => Lambda Operator.
```C#
using System.Threading;
using System;
namespace ThreadingDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            //Creating Thread Class Instance using Lambda Expression
            Thread t1 = new Thread(() =>
            {
                for (int i = 1; i <= 5; i++)
                {
                    Console.WriteLine("Method1 :" + i);
                }
            });
            t1.Start();
            Console.Read();
        }
    }
}

```

##### **Thread Function with Parameter in C#:**

The examples that we have worked on so far do not take any parameters. That is the method that we want to execute by the custom thread that does not take any parameter. Now, let us proceed and try to understand how to work with the thread function which takes the input parameter.

Let’s change the DisplayNumbers() method implementation to take one parameter. Now, this method takes one input parameter of the object type. And then convert that object type to an integer value and then print the numbers up to that value starting from 1. For a better understanding, please have a look at the below example.

```C#
using System.Threading;
using System;
namespace ThreadingDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            //DisplayNumbers is now a non-static method, so we need to
            //refer it by using the instannce
            Program obj = new Program();
            Thread t1 = new Thread(obj.DisplayNumbers);
            t1.Start(5);
            Console.Read();
        }

        public void DisplayNumbers(object Max)
        {
            int Number = Convert.ToInt32(Max);
            for (int i = 1; i <= Number; i++)
            {
                Console.WriteLine("Method1 :" + i);
            }
        }
    }
}

```

When the thread method or thread function (the function which is going to be executed by the custom thread) takes one parameter, then the Thread class uses the ParameterizedThreadStart delegate internally. The definition of the ParameterizedThreadStart delegate in C# is shown in the below image.

![[parameterizedthreadstart-delegate-definition.webp]]

As you can see the ParameterizedThreadStart delegate is taking one parameter of object type and like the ThreadStart delegate it also does not return any value. Now the DisplayNumbers() method signature is the same as the signature of this ParameterizedThreadStart delegate. So, the .NET Framework internally converts the statements as shown in the below image.

![[constructors-of-thread-class-in-c.webp]]
##### **Creating the ParameterizedThreadStart Instance Manually in C#:**

Let us see how to create the ParameterizedThreadStart delegate instance manually and pass that instance to the Thread class Constructor. For a better understanding, please have a look at the below example. In the below example, first, we are creating an instance of ParameterizedThreadStart delegate and to the constructor of ParameterizedThreadStart delegate, we pass the DisplayNumbers function as a parameter. Then we create an instance of the Thread class and to the constructor of the Thread class, we pass the ParameterizedThreadStart delegate instance as a parameter that points to the DisplayNumbers function. Finally, when we call the Start method by passing the value 5 on the Thread instance, it will invoke the delegate instance by passing the same value 5 and that delegate instance when invoked, will execute the DisplayNumbers function by passing the value 5.

```C#
using System.Threading;
using System;
namespace ThreadingDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            Program obj = new Program();
            ParameterizedThreadStart PTSD = new ParameterizedThreadStart(obj.DisplayNumbers);
            Thread t1 = new Thread(PTSD);
            t1.Start(5);

            Console.Read();
        }

        public void DisplayNumbers(object Max)
        {
            int Number = Convert.ToInt32(Max);
            for (int i = 1; i <= Number; i++)
            {
                Console.WriteLine("Method1 :" + i);
            }
        }
    }
}


```

##### **When to use ParameterizedThreadStart Delegate over ThreadStart Delegate in C#?**

You need to use the ParameterizedThreadStart delegate if your method takes any values else you just need to use the ThreadStart delegate which does not take any parameter.

##### **What are the Problems with the ParameterizedThreadStart delegate in C#?**

As you can see, the parameter type of the ParameterizedThreadStart delegate is an object type. So, the parameter of the thread function is also going to be the object data type. And you cannot change the data type from object to any other type and if you try then it will give you a compile-time error. As the thread function operates on object data type, so we can pass any type of value and it accepts. As a result, the function is not going to be type-safe as we can pass any type of value. Again, as it operates on object data type, so boxing and unboxing will come into the picture and we already discussed in our [**Boxing and Unboxing**](https://dotnettutorials.net/lesson/boxing-and-unboxing-in-csharp/) article how it degrades our application performance. So, we should avoid object types.

##### **Example to Pass String Value to a Thread Function in C#:**

Let us try to pass a string value to the thread function and see what happens as shown below in the below example.

```C#
using System.Threading;
using System;
namespace ThreadingDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            Program obj = new Program();
            ParameterizedThreadStart PTSD = new ParameterizedThreadStart(obj.DisplayNumbers);
            Thread t1 = new Thread(PTSD);

            t1.Start("Hi");
            Console.Read();
        }

        public void DisplayNumbers(object Max)
        {
            int Number = Convert.ToInt32(Max);
            for (int i = 1; i <= Number; i++)
            {
                Console.WriteLine("Method1 :" + i);
            }
        }
    }
}

```

![[word-image-29911-8-5.webp]]

##### **How to Pass Data to the Thread Function in C#**

Let us understand this with an example. In the below example, the DisplayNumbers function takes an argument of the object type. Then in the main method, we created an instance of the ParameterizedThreadStart delegate, and to the constructor of the ParameterizedThreadStart delegate, we pass the DisplayNumbers function. Next, we created an instance of the Thread class and to the constructor of the Thread class, we pass the ParameterizedThreadStart delegate instance as a parameter that points to the DisplayNumbers function. Finally, we call the Start method and pass a string value “Hi”, and here we will not get any compile-time error.

```C#
using System.Threading;
using System;
namespace ThreadingDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            Program obj = new Program();
            ParameterizedThreadStart PTSD = new ParameterizedThreadStart(obj.DisplayNumbers);
            Thread t1 = new Thread(PTSD);
           
            t1.Start("Hi"); 
            Console.Read();
        }

       public void DisplayNumbers(object Max)
        {
            int Number = Convert.ToInt32(Max);
            for (int i = 1; i <= Number; i++)
            {
                Console.WriteLine("Method1 :" + i); 
            }  
        }
    }
}
```

![[c-users-pranaya-pictures-type-unsafe-in-parameter-1-768x401.webp]]
This is because the thread function is not type-safe as it operates on the object data type. Let’s see how to make the thread function type-safe so that we can pass the data in a type-safe manner. So, whenever we are saying type safe means there should be any kind of boxing and unboxing.

##### **How to Make the Thread Function Type-Safe in C#?**

When we are saying type-safe, it means we should not use the object data type. Here in our example, we need to use the data type as an integer. So at the time of compilation, if we pass any data other than an integer, then it should give us a compile-time error. Let us see how to achieve this step by step.

###### **Step1:**

In order to pass the data in a type-safe manner to a Thread function in C#, first, you need to encapsulate the thread function and the data it requires in a helper class. So, create a class file with the NumberHelper.cs and then copy and paste the following code into it.

```C#
using System;
namespace ThreadingDemo
{
    public class NumberHelper
    {
        int _Number;
        
        public NumberHelper(int Number)
        {
            _Number = Number;
        }
        
        public void DisplayNumbers()
        {
            for (int i = 1; i <= _Number; i++)
            {
                Console.WriteLine("value : " + i);
            }
        }
    }
}
```
As you can see, we have created the above NumberHelper class with one private variable i.e. _Number, one parameterized constructor, and one method i.e. DisplayNumbers. The private variable _Number is going to hold the target number. The constructor takes one input parameter of integer type and then assigns that value to the private variable. So, while we are creating the instance of NumberHelper class we need to supply the Number value. Finally, the DisplayNumbers function is used to display the values starting from 1 to the value that is present in the _Number variable.

###### **Step2:**

In the main method, we need to create an instance of NumberHelper class and to its constructor, we need to pass the integer value. Then create the ThreadStart delegate instance and pass the DisplayNumbers function as a parameter to its constructor. So, please modify the Program.cs class file as shown below.

```c#
using System.Threading;
using System;
namespace ThreadingDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            int Max = 10;
            NumberHelper obj = new NumberHelper(Max);
            
            Thread T1 = new Thread(new ThreadStart(obj.DisplayNumbers));
            
            T1.Start();
            Console.Read();
        }
    }
} 

```

##### **How to Retrieve Data from a Thread Function in C#?**

As of now, we have discussed the uses of ThreadStart and ParameterizedThreadStart delegates. If you notice. the return type of these two delegates is void as shown in the below image.

![[Pasted image 20240418182422.png]]

So, using the above two delegates we cannot return any data from a method as the return type is void. Then the question that comes to our mind is how to retrieve the data from a thread function in C#? The answer is by using a callback method.

##### **How to Retrieve Data from a Thread Function using Callback Method in C#:**

Let us see an example with step by step procedure to understand how we can use a callback method to retrieve the data from a thread function in C#. Please follow the below steps.

##### **Step1:**

In order to retrieve the data from a thread function, first, you need to encapsulate the thread function and the data it requires in a helper class. To the constructor of the Helper class, you need to pass the required data if any as well as a delegate representing the callback method.

From the thread function body, you need to invoke the callback delegate just before the thread function ends. And one more thing you need to take care that the callback delegate and the actual callback method signature should be the same.

So, create a class file with the **NumberHelper.cs** and then copy and paste the following code into it. The code is explained through comments, so please go through the comment lines.

```C#
using System;
namespace ThreadingDemo
{
    // First Create the callback delegate with the same signature of the callback method.
    public delegate void ResultCallbackDelegate(int Results);

    //Creating the Helper class
    public class NumberHelper
    {
        //Creating two private variables to hold the Number and ResultCallback instance
        private int _Number;
        private ResultCallbackDelegate _resultCallbackDelegate;

        //Initializing the private variables through constructor
        //So while creating the instance you need to pass the value for Number and callback delegate
        public NumberHelper(int Number, ResultCallbackDelegate resultCallbackDelagate)
        {
            _Number = Number;
            _resultCallbackDelegate = resultCallbackDelagate;
        }

        //This is the Thread function which will calculate the sum of the numbers
        public void CalculateSum()
        {
            int Result = 0;
            for (int i = 1; i <= _Number; i++)
            {
                Result = Result + i;
            }

            //Before the end of the thread function call the callback method
            if (_resultCallbackDelegate != null)
            {
                _resultCallbackDelegate(Result);
            }
        }
    }
}
```
##### **Step2:**

In the second step, we need to create the callback method whose signature should be the same as the signature of the CallBack Delegate. In our example, ResultCallBackMethod is the callback method and its signature is the same as the signature of the ResultCallbackDelegate delegate. Within the Main method, we need to create an instance of the ResultCallbackDelegate delegate and while creating the instance we need to pass the ResultCallBackMethod as the parameter to its constructor. So when we invoke the delegate it will call the ResultCallBackMethod method.

Please modify the Program class code as shown below. The example code is self-explained. So, please go through the comment lines for a better understanding.

```C#
using System.Threading;
using System;
namespace ThreadingDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            //Create the ResultCallbackDelegate instance and to its constructor 
            //pass the callback method name
            ResultCallbackDelegate resultCallbackDelegate = new ResultCallbackDelegate(ResultCallBackMethod);

            int Number = 10;

            //Creating the instance of NumberHelper class by passing the Number
            //the callback delegate instance
            NumberHelper obj = new NumberHelper(Number, resultCallbackDelegate);

            //Creating the Thread using ThreadStart delegate
            Thread T1 = new Thread(new ThreadStart(obj.CalculateSum));
            
            T1.Start();
            Console.Read();
        }

        //Callback method and the signature should be the same as the callback delegate signature
        public static void ResultCallBackMethod(int Result)
        {
            Console.WriteLine("The Result is " + Result);
        }
    }
}
```

##### **What is a Callback Function in C#?**

We can define a callback function as a function pointer that is being passed as an argument to another function. And then it is expected to call back that function at some point in time.

In our example, we call the thread function of NumberHelper class from the Main method of the Program class. While creating the instance of NumberHelper class we pass the callback function as an argument to that class constructor. And then we expected that callback method to be called at some point in time by the NumberHelper method.

##### **Join Method of Thread Class in C#.**

Let us understand the use of the Join Method of Thread Class in C# with Examples. For a better understanding, please have a look at the following example. In the below example we have created three methods and then execute these three methods using three different threads. The point that you need to remember is the threads thread1, thread2, and thread3 are called the child threads of the main thread. This is because these three threads are created by the main thread only. Here, thread1 executes Method1, thread2 executes Method2, and thread3 executes Method3. Further, if you notice, we have delayed the execution of Method1 by 3 seconds, Method2 execution by 2 seconds, and Method3 execution by 5 seconds using the Thread class static Sleep method which takes the time in milliseconds and will make the current thread sleep for that millisecond. Here, we are using the overloaded version of the Thread class constructor which takes the ThreadStart delegate as a parameter.

```C#
using System.Threading;
using System;
namespace ThreadingDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Main Thread Started");

            //Main Thread creating three child threads
            Thread thread1 = new Thread(Method1);
            Thread thread2 = new Thread(Method2);
            Thread thread3 = new Thread(Method3);

            thread1.Start();
            thread2.Start();
            thread3.Start();

            Console.WriteLine("Main Thread Ended");
            Console.Read();
        }

        static void Method1()
        {
            Console.WriteLine("Method1 - Thread1 Started");
            Thread.Sleep(3000);
            Console.WriteLine("Method1 - Thread 1 Ended");
        }

        static void Method2()
        {
            Console.WriteLine("Method2 - Thread2 Started");
            Thread.Sleep(2000);
            Console.WriteLine("Method2 - Thread2 Ended");
        }

        static void Method3()
        {
            Console.WriteLine("Method3 - Thread3 Started");
            Thread.Sleep(5000);
            Console.WriteLine("Method3 - Thread3 Ended");
        }
    }
}
```

As you can see from the above output, the Main thread is not waiting for all the child threads to complete their execution or task. If you want the Main thread should not be exited until and unless all the child thread or any of the child threads completes their task then you need to use the Join method of the Thread class in C#.

##### **Join Method of Thread Class in C#:**

The Join Method of the Thread Class in C# blocks the current thread and makes it wait until the child thread on which the Join method invoked completes its execution. There are three overloaded versions available for the Join Method in Thread class as shown below.

![[c-users-pranaya-pictures-join-method-of-thread-cl.webp]]

The following are the definitions of the above three overloaded versions of the Join Method of Thread class in C# provided by Microsoft:

1. **Join():** This method blocks the calling thread until the thread represented by this instance terminates while continuing to perform standard COM and SendMessage pumping. It will throw ThreadStateException if the caller attempted to join a thread that is in the System.Threading.ThreadState.Unstarted state.
2. **Join(int millisecondsTimeout):** This method blocks the calling thread until the thread represented by this instance terminates or the specified time elapses while continuing to perform standard COM and SendMessage pumping. The parameter millisecondsTimeout specifies the number of milliseconds to wait for the thread to terminate. It returns true if the thread has terminated; false if the thread has not terminated after the amount of time specified by the millisecondsTimeout parameter has elapsed. It will throw ArgumentOutOfRangeException if the value of millisecondsTimeout is negative and is not equal to System.Threading.Timeout.Infinite in milliseconds. It will throw ThreadStateException if the thread has not been started.
3. **Join(TimeSpan timeout):** This method blocks the calling thread until the thread represented by this instance terminates or the specified time elapses while continuing to perform standard COM and SendMessage pumping. Here, the parameter timeout specifies a System.TimeSpan is set to the amount of time to wait for the thread to terminate. It returns true if the thread is terminated; false if the thread has not terminated after the amount of time specified by the timeout parameter has elapsed. It throws ArgumentOutOfRangeException if the value of timeout is negative and is not equal to System.Threading.Timeout.Infinite in milliseconds, or greater than System.Int32.MaxValue milliseconds. It throws ThreadStateException if the caller attempted to join a thread that is in the System.Threading.ThreadState.Unstarted state.

**We can simplify the above definitions as follows:**

**Join():** The first version of the Join method which does not take any parameter will block the calling thread (i.e. the Parent thread) until the thread (child thread) completes its execution. In this case, the calling thread is going to wait for an indefinite time until the thread on which the Join Method is invoked is completed.

**Join(int millisecondsTimeout):** The second version of the Join Method allows us to specify the time out. It means it will block the calling thread until the child thread terminates or the specified time elapses. This overloaded takes time in milliseconds. This method returns true if the thread has terminated and returns false if the thread has not terminated after the amount of time specified by the millisecondsTimeout parameter has elapsed.

**Join(TimeSpan timeout):** The third overloaded version of this method is the same as the second overloaded version. The only difference is that here we need to use TimeSpan to set the amount of time to wait for the thread to terminate.

##### **Example to Understand the Join Method of Thread Class in C#**

For a better understanding of how to use the Thread Class Join Method in C#, please have a look at the below example. In the below example, we have called the Join method on all three threads which means it will block the main thread until all the child threads complete their tasks.


```C#
using System.Threading;
using System;
namespace ThreadingDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Main Thread Started");

            //Main Thread creating three child threads
            Thread thread1 = new Thread(Method1);
            Thread thread2 = new Thread(Method2);
            Thread thread3 = new Thread(Method3);

            thread1.Start();
            thread2.Start();
            thread3.Start();

            thread1.Join(); //Block Main Thread until thread1 completes its execution
            thread2.Join(); //Block Main Thread until thread2 completes its execution
            thread3.Join(); //Block Main Thread until thread3 completes its execution

            Console.WriteLine("Main Thread Ended");
            Console.Read();
        }

        static void Method1()
        {
            Console.WriteLine("Method1 - Thread1 Started");
            Thread.Sleep(1000);
            Console.WriteLine("Method1 - Thread 1 Ended");
        }

        static void Method2()
        {
            Console.WriteLine("Method2 - Thread2 Started");
            Thread.Sleep(2000);
            Console.WriteLine("Method2 - Thread2 Ended");
        }

        static void Method3()
        {
            Console.WriteLine("Method3 - Thread3 Started");
            Thread.Sleep(5000);
            Console.WriteLine("Method3 - Thread3 Ended");
        }
    }
}
```

```C#
using System.Threading;
using System;
namespace ThreadingDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Main Thread Started");

            //Main Thread creating three child threads
            Thread thread1 = new Thread(Method1);
            Thread thread2 = new Thread(Method2);
            Thread thread3 = new Thread(Method3);

            thread1.Start();
            thread2.Start();
            thread3.Start();

            thread1.Join(); //Block Main Thread until thread1 completes its execution
            thread2.Join(); //Block Main Thread until thread2 completes its execution
            //Now, Main Thread will not wait for thread3 to complete its execution

            Console.WriteLine("Main Thread Ended");
            Console.Read();
        }

        static void Method1()
        {
            Console.WriteLine("Method1 - Thread1 Started");
            Thread.Sleep(1000);
            Console.WriteLine("Method1 - Thread 1 Ended");
        }

        static void Method2()
        {
            Console.WriteLine("Method2 - Thread2 Started");
            Thread.Sleep(2000);
            Console.WriteLine("Method2 - Thread2 Ended");
        }

        static void Method3()
        {
            Console.WriteLine("Method3 - Thread3 Started");
            Thread.Sleep(5000);
            Console.WriteLine("Method3 - Thread3 Ended");
        }
    }
}

```

##### **Other Overloaded Versions of Thread Class Join Method in C#:**

You need to use the second and third overloaded version of the Thread Class Join Method in C# when you want the main thread to wait for a specified amount of time. For example, you want the main thread to wait for 3 seconds for thread2 and thread3 to complete their task. Then you need to use the Join method as shown below in the below example. Remember the overloaded versions which take time in milliseconds and TimeSpan returns a boolean value indicating whether the thread completes its execution or not. Boolean true means method execution completed and false means method execution not completed.

```C#
using System.Threading;
using System;
namespace ThreadingDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Main Thread Started");

            //Main Thread creating three child threads
            Thread thread1 = new Thread(Method1);
            Thread thread2 = new Thread(Method2);
            Thread thread3 = new Thread(Method3);

            thread1.Start();
            thread2.Start();
            thread3.Start();
            
            //Now, Main Thread will block for 3 seconds and wait thread2 to complete its execution
            if (thread2.Join(TimeSpan.FromSeconds(3)))
            {
                Console.WriteLine("Thread 2 Execution Completed in 3 second");
            }
            else
            {
                Console.WriteLine("Thread 2 Execution Not Completed in 3 second");
            }

            //Now, Main Thread will block for 3 seconds and wait thread3 to complete its execution
            if (thread3.Join(3000))
            {
                Console.WriteLine("Thread 3 Execution Completed in 3 second");
            }
            else
            {
                Console.WriteLine("Thread 3 Execution Not Completed in 3 second");
            }

            Console.WriteLine("Main Thread Ended");
            Console.Read();
        }

        static void Method1()
        {
            Console.WriteLine("Method1 - Thread1 Started");
            Thread.Sleep(1000);
            Console.WriteLine("Method1 - Thread 1 Ended");
        }

        static void Method2()
        {
            Console.WriteLine("Method2 - Thread2 Started");
            Thread.Sleep(2000);
            Console.WriteLine("Method2 - Thread2 Ended");
        }

        static void Method3()
        {
            Console.WriteLine("Method3 - Thread3 Started");
            Thread.Sleep(5000);
            Console.WriteLine("Method3 - Thread3 Ended");
        }
    }
}

```

##### **IsAlive Property of Thread Class in C#:**

The IsAlive property gets a value indicating the execution status of the current thread. It returns true if the thread has been started and has not terminated normally or aborted; otherwise, false. That means the IsAlive property of the Thread class returns true if the thread is still executing else returns false. Let us understand this with an example.

```C#
using System.Threading;
using System;
namespace ThreadingDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Main Thread Started");

            Thread thread1 = new Thread(Method1);
            thread1.Start();

            if (thread1.IsAlive)
            {
                Console.WriteLine("Thread1 Method1 is still Executing");
            }
            else
            {
                Console.WriteLine("Thread1 Method1 Completed its work");
            }
            //Wait Till thread1 to complete its execution
            thread1.Join();
            if (thread1.IsAlive)
            {
                Console.WriteLine("Thread1 Method1 is still Executing");
            }
            else
            {
                Console.WriteLine("Thread1 Method1 Completed its work");
            }

            Console.WriteLine("Main Thread Ended");
            Console.Read();
        }

        static void Method1()
        {
            Console.WriteLine("Method1 - Thread1 Started");
            //Making thread to sleep for 2 seconds
            Thread.Sleep(TimeSpan.FromSeconds(2));
            Console.WriteLine("Method1 - Thread 1 Ended");
        }
    }
}

```

