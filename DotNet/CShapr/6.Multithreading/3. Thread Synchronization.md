##### **What is Thread Synchronization in C#?**

Data inconsistency occurs when more than one threads access a shared resource such as in-memory data (instance or class variables) and external objects such as files at the same time. Let us understand this with an example. Consider that we have two threads Thread1 and Thread2, and both the threads access a shared resource let’s say Resource1 simultaneously. If Thread1 is trying to read data from the shared resource Resource1 when Thread2 is attempting to write data onto the shared resource Resource1, then there would be data inconsistency. Hence, in situations like this thread synchronization comes into the picture.

Synchronization in C# language is a process that allows access to shared resources smoothly. Synchronization in C# ensures that only one thread is accessing the shared resource at any given point in time, preventing other threads from doing the same at the same time.

Thread Synchronization in C# is a mechanism that is used to restrict multiple threads from accessing a shared resource at the same time. In simple words, we can also say that thread synchronization can help us to prevent multiple threads from gaining access to a shared resource simultaneously. As a result, we can have one and only one thread entering a critical section to access the shared resource at any given point in time.

##### **How Thread Synchronization is Achieved in C#?**

Synchronization in C# can be achieved in multiple ways. One of the ways to achieve Synchronization in C# is by using the feature of lock, which locks the access to a block of code within the locked object. When a thread locks an object, no other thread can access the block of code within the locked object. Only when a thread releases the lock, then it is available for other threads to access it.

In C# Language, every object has a built-in lock. By using the feature of Synchronization, we can lock an object. Locking an object can be done by using the lock keyword, and the following is the syntax to use the lock.

**lock(object)**  
**{**  
      **//Statement1**  
      **//Statement2**  
      **//And more statements to be synchronized**  
**}**

So, when a thread acquires a lock over an object, then that particular thread can only access the block of statements within the locked object. Now, all the other threads wishing to access the same block of statements within the same locked object will have to wait until, the thread that has got the lock on the object, releases the lock, by exiting the block of statements.

##### **Example without Thread Synchronization in C#:**

Before we show you the example of how to use the synchronization between threads by locking an object and its practical use, let us first see what actually happens without using synchronization on executing multiple threads, which are trying to access the same resource.

In the below example, we are creating three different threads that are going to going to access the same resource i.e. in this case the shared resource is SomeMethod. As you can see, we have delayed the SomeMethod execution by 1 second, and all three threads trying to execute the same method and they will execute it. The first thread which executes the method does not get its sole access, this thread executes the method for a while and after some time, other threads will come and execute the same method. So, here, we will not get the output as expected.

```C#
using System;
using System.Threading;

namespace ThreadStateDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            Thread thread1 = new Thread(SomeMethod)
            {
                Name = "Thread 1"
            };

            Thread thread2 = new Thread(SomeMethod)
            {
                Name = "Thread 2"
            };

            Thread thread3 = new Thread(SomeMethod)
            {
                Name = "Thread 2"
            };

            thread1.Start();
            thread2.Start();
            thread3.Start();

            Console.ReadKey();
        }

        public static void SomeMethod()
        {
            Console.Write("[Welcome To The ");
            Thread.Sleep(1000);
            Console.WriteLine("World of Dotnet!]");
        }
    }
}

```

##### **Example using Thread Synchronization in C#**

In the below example, we are creating three threads that are going to access the SomeMethod, but this time access to SomeMethod will be synchronized because we are going to use the lock, to lock the object within which the method is going to be accessed by multiple threads. The first thread to enter the method gets its sole access until it exits the method, thereby avoiding the collision between multiple threads trying to access a method.

```C#
using System;
using System.Threading;

namespace ThreadStateDemo
{
    class Program
    {
        static object lockObject = new object();
        static void Main(string[] args)
        {
            Thread thread1 = new Thread(SomeMethod)
            {
                Name = "Thread 1"
            };

            Thread thread2 = new Thread(SomeMethod)
            {
                Name = "Thread 2"
            };

            Thread thread3 = new Thread(SomeMethod)
            {
                Name = "Thread 2"
            };

            thread1.Start();
            thread2.Start();
            thread3.Start();

            Console.ReadKey();
        }

        public static void SomeMethod()
        {
            // Locking the Shared Resource for Thread Synchronization
            lock (lockObject)
            {
                Console.Write("[Welcome To The ");
                Thread.Sleep(1000);
                Console.WriteLine("World of Dotnet!]");
            }
        }
    }
}

```

The first thread enters the SomeMethod locked the method (code written within the lock (object)), and gets its sole access and once this thread has finished its execution of the method, then only another thread will come and acquire a lock on the critical section i.e. the code written within the lock object. In this way, the lock object will make sure that at any given point in time, only one thread can access the shared resource which will also ensure data consistency.

##### **Realtime Example to Understand Thread Synchronization in C#:**

Let us see one real-time example to understand thread synchronization and why it is important to protect shared resources in our application. In the below example, I am going to show you how to protect a shared variable from concurrent access in a multithread environment.

In the below example, we are implementing the ticket booking functionality for a movie. Let us assume the number of available tickets is 3 and three different threads tried to book tickets. Thread1 tries to book 1 ticket, thread2 tries to book 2 tickets and thread3 tries to book 3 tickets. Let us first see the problem without thread synchronization. In the below code, we are not implementing thread synchronization and hence sometime you will see that all three threads are able to book tickets. See, the available tickets are 3 and we are able to book 6 tickets and this is the issue without thread synchronization.

```C#
using System;
using System.Threading;

namespace ThreadStateDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            BookMyShow bookMyShow = new BookMyShow();
            Thread t1 = new Thread(bookMyShow.TicketBookig)
            {
                Name = "Thread1"
            };
            Thread t2 = new Thread(bookMyShow.TicketBookig)
            {
                Name = "Thread2"
            };
            Thread t3 = new Thread(bookMyShow.TicketBookig)
            {
                Name = "Thread3"
            };
            
            t1.Start();
            t2.Start();
            t3.Start();
            Console.ReadKey();
        }
    }

    public class BookMyShow
    {
        int AvailableTickets = 3;
        static int i = 1, j = 2, k = 3;
        public void BookTicket(string name, int wantedtickets)
        {
            if (wantedtickets <= AvailableTickets)
            {
                Console.WriteLine(wantedtickets + " booked to " + name);
                AvailableTickets = AvailableTickets - wantedtickets;
            }
            else
            {
                Console.WriteLine("No tickets Available to book");
            }
        }
        public void TicketBookig()
        {
            string name = Thread.CurrentThread.Name;
            if (name.Equals("Thread1"))
            {
                BookTicket(name, i);
            }
            else if (name.Equals("Thread2"))
            {
                BookTicket(name, j);
            }
            else
            {
                BookTicket(name, k);
            }
        }
    }
}

```

As you can see in the above output, all the threads are able to book the tickets. This is possible because all the threads are able to access the critical section code of the program simultaneously. Now, let us proceed and see how we can restrict this i.e. how we can allow only one thread to execute the critical section code.

##### **Real-Time Example using Thread Synchronization in C#**

In the below example, we have used the thread synchronization mechanism to lock the critical section code by using the lock object. Now, the lock object will make sure that only one thread can execute the critical section code, and once the thread completes the execution of the critical section code, then another thread can enter and execute the critical section code. With this, now you will get the output as expected and you will see that you cannot book more than 3 tickets.

```C#
using System;
using System.Threading;

namespace ThreadStateDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            BookMyShow bookMyShow = new BookMyShow();
            Thread t1 = new Thread(bookMyShow.TicketBookig)
            {
                Name = "Thread1"
            };
            Thread t2 = new Thread(bookMyShow.TicketBookig)
            {
                Name = "Thread2"
            };
            Thread t3 = new Thread(bookMyShow.TicketBookig)
            {
                Name = "Thread3"
            };
            
            t1.Start();
            t2.Start();
            t3.Start();
            Console.ReadKey();
        }
    }

    public class BookMyShow
    {
        private object lockObject = new object();

        int AvailableTickets = 3;
        static int i = 1, j = 2, k = 3;
        public void BookTicket(string name, int wantedtickets)
        {
            lock(lockObject)
            {
                if (wantedtickets <= AvailableTickets)
                {
                    Console.WriteLine(wantedtickets + " booked to " + name);
                    AvailableTickets = AvailableTickets - wantedtickets;
                }
                else
                {
                    Console.WriteLine("No tickets Available to book");
                }
            }
        }
        public void TicketBookig()
        {
            string name = Thread.CurrentThread.Name;
            if (name.Equals("Thread1"))
            {
                BookTicket(name, i);
            }
            else if (name.Equals("Thread2"))
            {
                BookTicket(name, j);
            }
            else
            {
                BookTicket(name, k);
            }
        }
    }
}

```

So, by using the feature of synchronization (lock), we can avoid a conflict between threads trying to access the same resource simultaneously. We can achieve thread synchronization in C# by using the followings. From our next article onwards, we are going to discuss the following in detail.

1. [**Lock**](https://dotnettutorials.net/lesson/locking-in-multithreading/)
2. [**Monitor**](https://dotnettutorials.net/lesson/multithreading-using-monitor/)
3. [**Mutex**](https://dotnettutorials.net/lesson/mutex-in-multithreading/)
4. [**Semaphore**](https://dotnettutorials.net/lesson/semaphore-in-multithreading/)
5. **SemaphoreSlim**

**Note:** Thread Synchronization in C# is a mechanism that ensures that two or more concurrent processes or threads do not execute some particular section of the program, especially the critical section. In this technique, one thread executes the critical section of a program and the other thread waits until the thread finished its execution. If a proper synchronization mechanism will be not applied then race conditions will happen.

##### **Why do we need Thread Synchronization in Multithreading?**

We need Thread Synchronization in Multithreading because of the following:

1. **Atomicity:** Thread Synchronization supports atomicity, which ensures that multiple threads in the application are not allowed to access a shared resource concurrently to prevent data inconsistency. The code section of our program which causes data inconsistency is known as the critical section. The critical section of our program is executed atomically by one and only one thread which ensures Atomicity. The Ticket booking example is an example of Atomicity.
2. **Ordering:** We generally want two or more threads to perform a task in a particular order or we want to restrict access to shared resources to a particular number of threads only. Usually, we don’t have much control over all this, which is one reason for race conditions. Thread synchronization provides support for ordering so that you can have control over your threads to perform the tasks as per your requirement. The first example that we discussed in this article is the example of ordering.

##### **What is Exclusive Lock and Non-Exclusive Lock in C#?**

When a process or a thread wants to access an object, it requests a lock on that object. There are two types of locks that determine access to shared resources – Exclusive Lock and Non-Exclusive lock.

1. **Exclusive Lock:** An exclusive lock makes sure that only one thread can gain access or enter a critical section at any given point in time. In C#, we can implement Exclusive Lock using the lock keyword, Monitor class, Mutex Class, and SpinLock class.
2. **Non-Exclusive Lock:** Non-Exclusive locks provide read-only access to a shared resource and limit concurrency, i.e., limit the number of concurrent accesses to a shared resource. In C#, we can implement Non-Exclusive Lock using the Semaphore, SemaphoreSlim, and ReaderWriterLockSlim classes.

# Lock in C#

##### **Why do we need to Protect the Shared Resources in Multithreading in C#?**

In a multithreading application, it is very important for us to handle multiple threads for executing critical section code or you can say shared resources. For example, if we have a shared resource, and multiple threads want to access the shared resource, then we need to protect the shared resource from concurrent access otherwise we will get some inconsistent behavior or output.

In C#, we can use Lock and Monitor to provide thread safety in a multithreaded application. Both lock and monitor provide a mechanism that ensures that only one thread is executing the critical section code at any given point in time to avoid any functional breaking of code or to avoid inconsistent behavior or output.

In this article, I am going to discuss how to protect the shared resource in a multithread environment using the lock and in the next article, I am going to discuss how to do the same thing using the [**Monitor in C#**](https://dotnettutorials.net/lesson/multithreading-using-monitor/).

##### **Accessing a Shared Resource in a Single-Threaded Environment in C#:**

Before understanding how to use the lock to protect the shared resource in a multithread environment in C#, let us first understand the problem if we are not protecting the shared resource in a multithread environment. In the following example, we have a shared resource i.e. DisplayMessage() method and we call that method three times from the Main method as shown below.

```C#
using System.Threading;
using System;
namespace ThreadingDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            DisplayMessage();
            DisplayMessage();
            DisplayMessage();

            Console.Read();
        }

        static void DisplayMessage()
        {
            Console.Write("[Welcome to the ");
            Thread.Sleep(1000);
            Console.WriteLine("world of dotnet!]");
        }
    }
}
```

##### **Accessing a Shared Resource in a Multithreaded Environment in C#:**

In the following example, we have created three different threads and then invoke the same DisplayMessage() method using all these three different threads. Here, DisplayMessage() method is the shared resource and this shared resource is simultaneously or concurrently invoked by three different threads. Here, we are not protecting the shared resource, and all three threads accessing the shared resource which results in inconsistent output.

```C#
using System.Threading;
using System;
namespace ThreadingDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            Thread t1 = new Thread(DisplayMessage);
            Thread t2 = new Thread(DisplayMessage);
            Thread t3 = new Thread(DisplayMessage);

            t1.Start();
            t2.Start();
            t3.Start();

            Console.Read();
        }

        static void DisplayMessage()
        {
            Console.Write("[Welcome to the ");
            Thread.Sleep(1000);
            Console.WriteLine("world of dotnet!]");
        }
    }
}

```

As you can see, here we are not getting the output as expected. So, the point that you need to keep in mind is that if the shared resource is not protected in a multithreaded environment from concurrent access, then the output or the behavior of the application becomes inconsistent.

##### **How to Protect a Shared Resource in a Multithread Environment from Concurrent Access in C#?**

We can protect the shared resources in a multithread environment from concurrent access by using the concept Monitor and Locking in C#. Let us see how to protect the shared resource using the lock statement in C# and see the output. In the following example, we have created one readonly object i.e LockDisplayMethod, and then we created a block using the lock keyword. To the lock keyword, we pass the LockDisplayMethod object, and the section or block or particular resource that we want to protect should be placed inside the lock block which is shown in the below example.

```C#
using System.Threading;
using System;
namespace ThreadingDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            Thread t1 = new Thread(DisplayMessage);
            Thread t2 = new Thread(DisplayMessage);
            Thread t3 = new Thread(DisplayMessage);

            t1.Start();
            t2.Start();
            t3.Start();

            Console.Read();
        }

        private static readonly object LockDisplayMethod = new object();
        static void DisplayMessage()
        {
            lock(LockDisplayMethod)
            {
                Console.Write("[Welcome to the ");
                Thread.Sleep(1000);
                Console.WriteLine("world of dotnet!]");
            }
        }
    }
}

```

##### **What is the lock statement in C#?**

According to [**Microsoft**](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/statements/lock), the lock statement acquires the mutual-exclusion lock for a given object, executes a statement block, and then releases the lock. While a lock is held, the thread that holds the lock can again acquire and release the lock. Any other thread is blocked from acquiring the lock and waits until the lock is released.

**Note:** When you want to synchronize thread access to a shared resource, you should lock the shared resource on a dedicated object instance (for example, **private readonly object _lockObject = new object(); or private static readonly object _lockObject = new object();**). Avoid using the same lock object instance for different shared resources, as it might result in a deadlock.

##### **How is the lock Statement internally work in C#?**

The lock statement in C# was internally converted to a try-finally block when we compiled the code. The compiled code of the lock statement will look like the below. You can see, it is internally using the Monitor class Enter and Exit method. In our next article, we will discuss the [**Monitor Class Enter and Exit Methods**](https://dotnettutorials.net/lesson/multithreading-using-monitor/) in detail, for now, to understand, what we can say is, it acquires an exclusive lock within the try block by invoking the Monitor class Enter method and it releases the exclusive lock within the finally block by calling the Monitor class Exit method.

![[How-Lock-Statement-Internally-Works-in-C.webp]]
##### **Protecting Shared Variable using Lock Statement in C# with Examples:**

The section or block or particular resource that you want to protect should be placed inside the lock block. Let us understand this with an example. In the below example, we are only protecting the shared Count variable from concurrent access.

```C#
using System.Threading;
using System;
namespace ThreadingDemo
{
    class Program
    {
        static int Count = 0;

        static void Main(string[] args)
        {
            Thread t1 = new Thread(IncrementCount);
            Thread t2 = new Thread(IncrementCount);
            Thread t3 = new Thread(IncrementCount);

            t1.Start();
            t2.Start();
            t3.Start();

            //Wait for all three threads to complete their execution
            t1.Join();
            t2.Join();
            t3.Join();

            Console.WriteLine(Count);
            Console.Read();
        }

        private static readonly object LockCount = new object();
        static void IncrementCount()
        {
            for (int i = 1; i <= 1000000; i++)
            {
                //Only protecting the shared Count variable
                lock (LockCount)
                {
                    Count++;
                }
            }
        }
    }
}
```
When you run the above program, it will give you the output as expected as 3000000. Now, let us see what happens if we are not protecting our shared variable Count. In the below example, we are not protecting the Count shared variable and hence all three threads simultaneously access the variable and try to increment the value, and hence we will get some unexpected output.

```C#
using System.Threading;
using System;
namespace ThreadingDemo
{
    class Program
    {
        static int Count = 0;

        static void Main(string[] args)
        {
            Thread t1 = new Thread(IncrementCount);
            Thread t2 = new Thread(IncrementCount);
            Thread t3 = new Thread(IncrementCount);

            t1.Start();
            t2.Start();
            t3.Start();

            //Wait for all three threads to complete their execution
            t1.Join();
            t2.Join();
            t3.Join();

            Console.WriteLine(Count);
            Console.Read();
        }
        
        static void IncrementCount()
        {
            for (int i = 1; i <= 1000000; i++)
            {
                Count++;
            }
        }
    }
}
```
# Monitor Class in C#


##### **Understanding the Monitor Class in C#:**

According to [**Microsoft**](https://learn.microsoft.com/en-us/dotnet/api/system.threading.monitor?view=net-6.0), the Monitor Class in C# Provides a mechanism that synchronizes access to objects. Let us simplify the above definition. In simple words, we can say that, like the lock, we can also use this Monitor Class to protect the shared resources in a multi-threaded environment from concurrent access. This can be done by acquiring an exclusive lock on the object so that only one thread can enter the critical section at any given point in time.

The Monitor class is a static class belonging to the System.Threading namespace. As a static class, it provides a collection of static methods, as shown in the image below. Using these static methods, we can provide synchronized access to the critical section associated with a particular object.
![[Protecting-Shared-Resources-in-Multithreading-Using-Monitor-Class-in-C.webp]]


Let’s understand the roles and responsibilities of each method in the Monitor class. The following is the list of important methods in the Monitor class.

1. **Enter():** When we invoke the Enter method of the Monitor class, it acquires an exclusive lock on the specified object. This also marks the beginning of a critical section or the beginning of a shared resource.
2. **Exit():** When the Monitor class’s Exit method is invoked, it releases the lock on the specified object. This marks the end of a critical section or the end of the shared resource protected by the locked object.
3. **Pulse():** When the Pulse method is invoked of the Monitor class, it sends a signal to a thread in the waiting queue of a change in the locked object’s state.
4. **Wait():** When the Monitor class’s Wait method is invoked, it releases the lock on an object and blocks the current thread until it reacquires the lock.
5. **PulseAll():** When the Monitor class’s PulseAll method is invoked, it sends signals to all waiting threads about a change in the locked object’s state.
6. **TryEnter():** When we invoke the Monitor class’s TryEnter method, it attempts to acquire an exclusive lock on the specified object.

**Note:** If this is not clear at the moment, don’t worry. We will try to understand all the above methods with examples, and you will also see that many overloaded versions of the above methods are available.

##### **Example to understand Monitor Class in C# to Protect Shared Resource from Concurrent Access:**

The following is the syntax for using the Enter and Exit methods of the Monitor class to protect a shared resource in a multithreaded environment from concurrent access in C#. All the methods of the Monitor class are static. So, you can see here that we are accessing the Enter and Exit methods using the class name, i.e., Monitor.

![[Monitor-Class-in-C-Multithreading.webp]]
Let us see an example to understand how to use the Monitor class Enter and Exit method to protect a shared resource in a multithreaded environment in C# from concurrent access. In the example below, we have one shared resource, and we are accessing that resource concurrently using three different threads. Then, we used the Monitor class Enter and Exit Methods to protect the critical section code. In this case, all three threads will try to acquire an exclusive lock, but at any given point in time, only one thread gets an exclusive lock and will enter into the critical section, and all other threads will wait until the thread releases the lock.

```C#
using System;
using System.Threading;
namespace MonitorDemo
{
    class Program
    {
        private static readonly object lockPrintNumbers = new object();

        public static void PrintNumbers()
        {
            Console.WriteLine(Thread.CurrentThread.Name + " Trying to enter into the critical section");
            
            try
            {
                Monitor.Enter(lockPrintNumbers);
                Console.WriteLine(Thread.CurrentThread.Name + " Entered into the critical section");
                for (int i = 0; i < 5; i++)
                {
                    Thread.Sleep(100);
                    Console.Write(i + ",");
                }
                Console.WriteLine();
            }
            finally
            {
                Monitor.Exit(lockPrintNumbers);
                Console.WriteLine(Thread.CurrentThread.Name + " Exit from critical section");
            }
        }

        static void Main(string[] args)
        {
            Thread[] Threads = new Thread[3];
            for (int i = 0; i < 3; i++)
            {
                Threads[i] = new Thread(PrintNumbers)
                {
                    Name = "Child Thread " + i
                };
            }

            foreach (Thread t in Threads)
            {
                t.Start();
            }

            Console.ReadLine();
        }
    }
}
```


##### **How does the Monitor Class work in C#?**

The Monitor class in C# provides a wait-based synchronization mechanism that allows only one thread to access the critical section code at a time to avoid the race condition. All the other threads must wait and halt the execution until the locked object is released.

To understand how the Monitor class works in C#, please have a look at the following diagram. As shown in the image below, as soon as a thread executes the Enter method of the Thread class, it will be in the Ready Queue, and in the same way, many threads can be in the Ready Queue. Then, one of the threads from the Ready Queue will acquire an Exclusive Lock on the Object and will enter inside the Critical Section and execute the code, and at that time, no other threads can get a chance to enter into the Critical Section. When we execute the Exit method of the thread class, the currently executing thread will move into the waiting queue and send one signal to the threads in the ready queue. One of the Threads from the Ready queue will acquire the lock, and enter the Critical section, and start executing the code of the Critical Section. This is how the Monitor class works in C#.

![[Monitor-Class-in-C.webp]]

##### **Monitor.Enter(lockObject, ref IslockTaken) Method in C#:**

Let us understand the other overloaded version of the Enter method. The **Monitor.Enter(lockObject, ref IslockTaken)** acquires an exclusive lock on the specified object. It then automatically sets a value that indicates whether the lock was taken or not. The second parameter, which is a Boolean parameter, returns true if the lock is acquired; otherwise, it returns false. The syntax for using this overloaded version is given below.

![[Monitor.EnterlockObject-ref-IslockTaken-Method-in-C-1.webp]]

The following example shows how to use **Enter(lockObject, ref IslockTaken)** method of the Monitor class in C#. The following example is the same as the previous example, except here, we are using the overloaded version of the Enter method, which takes two parameters. The second boolean parameter specifies whether the thread acquires a lock or not, true indicates that it acquires a lock on the object and false indicates that it does not acquire a lock on the object and again in the finally block we are checking the boolean value and accordingly we are releasing the lock.

```C#
using System;
using System.Threading;
namespace MonitorDemo
{
    class Program
    {
        private static readonly object lockPrintNumberst = new object();

        public static void PrintNumbers()
        {
            Console.WriteLine(Thread.CurrentThread.Name + " Trying to enter into the critical section");
            bool IsLockTaken = false;
            
            try
            {
                Monitor.Enter(lockPrintNumberst, ref IsLockTaken);
                if(IsLockTaken)
                {
                    Console.WriteLine(Thread.CurrentThread.Name + " Entered into the critical section");
                    for (int i = 0; i < 5; i++)
                    {
                        Thread.Sleep(100);
                        Console.Write(i + ",");
                    }
                    Console.WriteLine();
                }
            }
            finally
            {
                if (IsLockTaken)
                {
                    Monitor.Exit(lockPrintNumberst);
                    Console.WriteLine(Thread.CurrentThread.Name + " Exit from critical section");
                }
            }
        }

        static void Main(string[] args)
        {
            Thread[] Threads = new Thread[3];
            for (int i = 0; i < 3; i++)
            {
                Threads[i] = new Thread(PrintNumbers)
                {
                    Name = "Child Thread " + i
                };
            }

            foreach (Thread t in Threads)
            {
                t.Start();
            }

            Console.ReadLine();
        }
    }
}
```

##### **Example to Understand TryEnter(Object, TimeSpan, Boolean) Method of Monitor Class in C#:**

This method attempts to acquire an exclusive lock on the specified object for a specified amount of time. It automatically sets a value that indicates whether the lock was taken or not. The syntax for using the **TryEnter(Object, TimeSpan, Boolean)** Method of Monitor Class in C# is given below.

![[TryEnterObject-TimeSpan-Boolean-Method-of-Monitor-Class-in-C.webp]]

```C#
using System;
using System.Threading;

namespace MonitorDemo
{
    class Program
    {
        private static readonly object lockPrintNumbers = new object();

        public static void PrintNumbers()
        {
            TimeSpan timeout = TimeSpan.FromMilliseconds(1000);
            bool lockTaken = false;

            try
            {
                Console.WriteLine(Thread.CurrentThread.Name + " Trying to enter into the critical section");
                Monitor.TryEnter(lockPrintNumbers, timeout, ref lockTaken);
                if (lockTaken)
                {
                    Console.WriteLine(Thread.CurrentThread.Name + " Entered into the critical section");
                    for (int i = 0; i < 5; i++)
                    {
                        Thread.Sleep(100);
                        Console.Write(i + ",");
                    }
                    Console.WriteLine();
                }
                else
                {
                    // The lock was not acquired.
                    Console.WriteLine(Thread.CurrentThread.Name + " Lock was not acquired");
                }
            }
            finally
            {
                // To Ensure that the lock is released.
                if (lockTaken)
                {
                    Monitor.Exit(lockPrintNumbers);
                    Console.WriteLine(Thread.CurrentThread.Name + " Exit from critical section");
                }
            }
        }

        static void Main(string[] args)
        {
            Thread[] Threads = new Thread[3];
            for (int i = 0; i < 3; i++)
            {
                Threads[i] = new Thread(PrintNumbers)
                {
                    Name = "Child Thread " + i
                };
            }

            foreach (Thread t in Threads)
            {
                t.Start();
            }

            Console.ReadLine();
        }
    }
}
```

##### **Example to Understand Wait() and Pulse() Methods of Monitor Class in C#:**

The Wait() Method of Monitor Class is used to Release the lock on an object in order to permit other threads to lock and access the object. The calling thread waits while another thread accesses the object. The Pulse signals are used to notify waiting threads about changes to a locked object’s state. 

Let us understand this with one real-time example. Our business requirement is to print the even and Odd number sequence using two different threads. One thread will print the even numbers, and another thread will print the odd numbers.  
**Thread T1: 0,2,4,6,8…**  
**Thread T2: 1,3,5,7,9…**  
**Output: 0,1,2,3,4,5,6,7,8,9…**

To solve the above problem, let us use the signaling mechanism using the Monitor Class Wait() and Pulse() Methods in C#. In the following example, we use the Monitor.Wait() method to make the thread waiting and Monitor.Pulse() method is used to signal other threads. The process is as follows:

1. First, the Even thread will start to print the number on the console.
2. Then, the Even thread will signal the Odd thread to be ready to print the number using the Monitor.Pulse() method.
3. Then, the Event thread will call the Monitor.Wait() method, which will allow the current thread to block and the Odd thread to start execution.
4. The Odd Thread will also do the same thing.
5. The Odd thread will start to print the number on the console.
6. Then, the Odd thread will signal the Even thread to be ready to print the number using the Monitor.Pulse() method.
7. Then the Odd thread will call the Monitor.Wait() method, which will allow the current thread to block and allow the Even thread to start execution.
8. The same process is going on.

Since both the Odd and Even threads share the same console window to print the number, we need to put a lock on the console IO. We want the sequence to start with the even number, so the Even thread must run first. Once we start the Even thread, we need to pause for a moment before starting the Odd thread using the Sleep() method of the Thread class in C# to avoid any chance of starting the Odd thread first.

```C#
using System;
using System.Threading;

namespace odd_even_sequence
{
    class Program
    {
        //Upto the limit numbers will be printed on the Console
        const int numberLimit = 20;

        static readonly object _lockMonitor = new object();

        static void Main(string[] args)
        {
            Thread EvenThread = new Thread(PrintEvenNumbers);
            Thread OddThread = new Thread(PrintOddNumbers);

            //First Start the Even thread.
            EvenThread.Start();

            //Puase for 10 ms, to make sure Even thread has started 
            //or else Odd thread may start first resulting different sequence.
            Thread.Sleep(100);

            //Next, Start the Odd thread.
            OddThread.Start();

            //Wait for all the childs threads to complete
            OddThread.Join();
            EvenThread.Join();

            Console.WriteLine("\nMain method completed");
            Console.ReadKey();
        }

        //Printing of Even Numbers Function
        static void PrintEvenNumbers()
        {
            try
            {
                //Implement lock as the Console is shared between two threads
                Monitor.Enter(_lockMonitor);
                for (int i = 0; i <= numberLimit; i = i + 2)
                {
                    //Printing Even Number on Console)
                    Console.Write($"{i} ");

                    //Notify Odd thread that I'm done, you do your job
                    //It notifies a thread in the waiting queue of a change in the 
                    //locked object's state.
                    Monitor.Pulse(_lockMonitor);

                    //I will wait here till Odd thread notify me 
                    //Monitor.Wait(monitor);
                    //Without this logic application will wait forever

                    bool isLast = false;
                    if (i == numberLimit)
                    {
                        isLast = true;
                    }

                    if (!isLast)
                    {
                        //I will wait here till Odd thread notify me
                        //Releases the lock on an object and blocks the current thread 
                        //until it reacquires the lock.
                        Monitor.Wait(_lockMonitor);
                    }
                }
            }
            finally
            {
                //Release the lock
                Monitor.Exit(_lockMonitor);
            }

        }

        //Printing of Odd Numbers Function
        static void PrintOddNumbers()
        {
            try
            {
                //Hold lock as the Console is shared between two threads
                Monitor.Enter(_lockMonitor);
                for (int i = 1; i <= numberLimit; i = i + 2)
                {
                    //Printing the odd numbers on the console
                    Console.Write($"{i} ");

                    //Notify Even thread that I'm done, you do your job
                    Monitor.Pulse(_lockMonitor);

                    // I will wait here till even thread notify me
                    // Monitor.Wait(monitor);
                    // without this logic application will wait forever

                    bool isLast = false;
                    if (i == numberLimit - 1)
                    {
                        isLast = true;
                    }

                    if (!isLast)
                    {
                        //I will wait here till Even thread notify me
                        Monitor.Wait(_lockMonitor);
                    }
                }
            }
            finally
            {
                //Release lock
                Monitor.Exit(_lockMonitor);
            }
        }
    }
}
```

##### **Difference Between Monitor and Lock in C#**

The Difference between monitor and lock in C# is that lock internally wraps the Enter and Exit methods in a try…finally block with exception handling. For the Monitor class in C#, we need to use the try and finally block explicitly to release the lock properly. So, Lock = Monitor + try-finally.

The lock provides the basic functionality to acquire an exclusive lock on a synchronized object. But, If you want more control to implement advanced multithreading solutions using TryEnter(), Wait(), Pulse(), and PulseAll() methods, then the Monitor class is your option.

##### **Limitations of Locks and Monitors in C#:**

Locks and Monitors help us ensure that our code is thread-safe. That means when we run our code in a multi-threaded environment, we don’t end up with inconsistent results. For a better understanding, please have a look at the image below.

![[Lock-and-Monitor-in-C.webp]]

However, there are some limitations to locks and monitors. The locks and monitors ensure thread safety for threads that are in process, i.e., the threads that are generated by the application itself, i.e., Internal Threads. But if the threads come from external applications (Out-Process) or External Threads, then Locks and Monitors have no control over them. So, in a situation like this, we need to use Mutex. In our next article, we will discuss Mutex.

##### **Monitor class Methods in Detail:**

Let us understand the Roles and Responsibilities of each method of the Monitor class according to Microsoft.

1. **Enter(object obj):** This method acquires an exclusive lock on the specified object. It takes one object parameter to acquire the monitor lock. If the parameter obj is null, it will throw an ArgumentNullException.
2. **Enter(object obj, ref bool lockTaken):** This method also acquires an exclusive lock on the specified object and atomically sets a value that indicates whether the lock was taken. Here, the parameter obj specifies the object on which to wait. The parameter lockTaken specifies the result of the attempt to acquire the lock passed by reference. The input must be false. The output is true if the lock is acquired; otherwise, the output is false. The output is set even if an exception occurs during the attempt to acquire the lock. If no exception occurs, the output of this method will always be true. It will throw ArgumentException if the input to lockTaken is true. It will throw ArgumentNullException if the obj parameter is null.

##### **TryEnter Methods:**

There are six overloaded versions of the TryEnter method available in the Monitor class. They are as follows:

1. **public static bool TryEnter(object obj, TimeSpan timeout):** Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object.
2. **public static void TryEnter(object obj, int millisecondsTimeout, ref bool lockTaken):** Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object and atomically sets a value that indicates whether the lock was taken.
3. **public static void TryEnter(object obj, ref bool lockTaken):** Attempts to acquire an exclusive lock on the specified object and atomically sets a value that indicates whether the lock was taken.
4. **public static bool TryEnter(object obj):** Attempts to acquire an exclusive lock on the specified object.
5. **public static bool TryEnter(object obj, int millisecondsTimeout):** Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object.
6. **public static void TryEnter(object obj, TimeSpan timeout, ref bool lockTaken):** Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object and atomically sets a value that indicates whether the lock was taken.

All these methods are also used to acquire an exclusive lock on the specified object. Further, if you notice, all these methods return a type of bool. So, the TryEnter() method returns true if the current thread acquires the lock; otherwise, false. The following are the parameters used in the TryEnter method.

1. **object obj:** All the six overloaded versions take one object type parameter which specifies the object on which to acquire the lock. If the object parameter this method takes is null, then it will throw ArgumentNullException.
2. **TimeSpan timeout:** Some TryEnter() methods take TimeSpan timeout as a parameter, and this parameter specifies a System.TimeSpan represents the amount of time to wait for the lock. A value of -1 millisecond specifies an infinite wait. It will throw ArgumentOutOfRangeException if the value of timeout in milliseconds is negative and is not equal to System.Threading.Timeout.Infinite (-1 millisecond), or is greater than System.Int32.MaxValue.
3. **int millisecondsTimeout:** Again, two overloaded versions take int millisecondsTimeout as a parameter and this parameter specifies the number of milliseconds to wait for the lock. It will throw ArgumentOutOfRangeException if millisecondsTimeout is negative, and not equal to System.Threading.Timeout.Infinite.
4. **ref bool lockTaken:** Also three overloaded versions take ref bool lockTaken as a parameter and this parameter specifies the result of the attempt to acquire the lock, passed by reference. The input must be false. The output is true if the lock is acquired; otherwise, the output is false. The output is set even if an exception occurs during the attempt to acquire the lock. It will ArgumentException if the input to lockTaken is true.

**Note:** Both Enter and TryEnter methods are used to acquire an exclusive lock for an object. This action marks the beginning of a critical section. No other thread can enter the critical section unless it executes the instructions in the critical section using a different locked object.

##### **Wait Methods of Monitor Class in C#:**

There are five overloaded versions of the Wait method available in the Monitor class. They are as follows:

1. **public static bool Wait(object obj):** It Releases the lock on an object and blocks the current thread until it reacquires the lock.
2. **public static bool Wait(object obj, TimeSpan timeout):** Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue.
3. **public static bool Wait(object obj, int millisecondsTimeout):** It releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue.
4. **public static bool Wait(object obj, TimeSpan timeout, bool exitContext):** It releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue. Optionally exits the synchronization domain for the synchronized context before the wait and reacquires the domain afterward.
5. **public static bool Wait(object obj, int millisecondsTimeout, bool exitContext):** It releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue. This method also specifies whether the synchronization domain for the context (if in a synchronized context) is exited before the wait and reacquired afterward.

All these Wait Methods are used to release the lock on an object and block the current thread until it reacquires the lock. All these methods return type is boolean. So, these methods return true if the call is returned because the caller reacquired the lock for the specified object. This method does not return if the lock is not reacquired. Following are the parameters used in the Wait method.

1. **object obj:** The object on which to wait. If the obj parameter is null, it will throw an ArgumentNullException.
2. **TimeSpan timeout:** A System.TimeSpan represents the amount of time to wait before the thread enters the ready queue. It will throw ArgumentOutOfRangeException if the value of the timeout parameter in milliseconds is negative and does not represent System.Threading.Timeout.Infinite (-1 millisecond), or is greater than System.Int32.MaxValue.
3. **int millisecondsTimeout:** The number of milliseconds to wait before the thread enters the ready queue. If the value of the millisecondsTimeout parameter is negative and not equal to System.Threading.Timeout.Infinite, it will throw ArgumentOutOfRangeException.
4. **bool exitContext:** true to exit and reacquire the synchronization domain for the context (if in a synchronized context) before the wait; otherwise, false.
5. **ref bool lockTaken:** The result of the attempt to acquire the lock, passed by reference. The input must be false. The output is true if the lock is acquired; otherwise, the output is false. The output is set even if an exception occurs during the attempt to acquire the lock.

**Note:** The Wait methods are used to release the lock on an object and permit other threads to lock and access the object by blocking the current thread until it reacquires the lock. The calling thread waits while another thread accesses the object. Pulse signals are used to notify waiting threads about changes to an object’s state.

##### **Pulse and PulseAll Method of Monitor Class in C#:**

The following two methods are used to send a signal to one or more waiting threads. The signal notifies a waiting thread that the state of the locked object has changed, and the owner of the lock is ready to release the lock.

1. **Pulse(object obj):** This method notifies a thread in the waiting queue of a change in the locked object’s state. The obj parameter specifies the object a thread is waiting for. If the obj parameter is null, then it will throw ArgumentNullException.
2. **PulseAll(object obj):** This method notifies all waiting threads of a change in the object’s state. The obj parameter specifies the object that sends the pulse. If the obj parameter is null, then it will throw ArgumentNullException.

###### **Exit():**

The Exit method is used to release the exclusive lock from the specified object. This action marks the end of a critical section protected by the locked object.

1. **Exit(object obj):** This method releases an exclusive lock on the specified object. The parameter obj specifies the object on which to release the lock. If the obj parameter is null, it will throw an ArgumentNullException.

##### **IsEntered() Method:** 

1. **IsEntered(object obj):** This function determines whether the current thread holds the lock on the specified object. The parameter obj specifies the object to test. It returns true if the current thread holds the lock on obj; otherwise, it returns false. If the obj is null, it will throw an ArgumentNullException.

