
.NET-এ ডেলিগেট (Delegate) হলো একটি রেফারেন্স টাইপ ভেরিয়েবল যা কোনো মেথডকে নির্দেশ করে। সহজ ভাষায় বলতে গেলে, ডেলিগেট হলো একটি অবজেক্ট যা কোনো মেথডের রেফারেন্স বা ঠিকানা নিজের কাছে ধরে রাখে।  এটিকে সি বা সি++ এর ফাংশন পয়েন্টারের সাথে তুলনা করা যেতে পারে, তবে এটি টাইপ-সেফ এবং অবজেক্ট-ওরিয়েন্টেড।

**সহজ উপমা:**

মনে করুন, আপনার একজন ব্যক্তিগত সহকারী (Personal Assistant) আছে। আপনি তাকে বিভিন্ন সময়ে বিভিন্ন কাজের দায়িত্ব দেন, যেমন - "আমার জন্য এক কাপ কফি নিয়ে আসো" অথবা "আমার মিটিংগুলো সাজিয়ে রাখো"। এখানে, আপনার সহকারী নিজে কাজটি করছে না, বরং সে জানে কাজটি কাকে দিয়ে করাতে হবে এবং কীভাবে করাতে হবে।

.NET-এ ডেলিগেট ঠিক এই সহকারীর মতোই কাজ করে। ডেলিগেট নিজে কোনো কাজ করে না, কিন্তু সে জানে কোন মেথডটিকে কল করতে হবে। আপনি একটি ডেলিগেট তৈরি করে তাকে একটি নির্দিষ্ট সিগনেচারের (অর্থাৎ, একই রকম প্যারামিটার এবং রিটার্ন টাইপ) যেকোনো মেথডের দায়িত্ব দিতে পারেন। 

**ডেলিগেটের সুবিধা:**

*   **ফ্লেক্সিবিলিটি (Flexibility):** ডেলিগেট ব্যবহার করে আপনি রানটাইমে মেথড কল পরিবর্তন করতে পারেন। 
*   **কলব্যাক মেথড (Callback Methods):** ডেলিগেট কলব্যাক মেথড তৈরির জন্য আদর্শ। এর মাধ্যমে একটি মেথড অন্য একটি মেথডকে প্যারামিটার হিসেবে গ্রহণ করতে পারে এবং পরে সেই মেথডটিকে কল করতে পারে।
*   **ইভেন্ট হ্যান্ডলিং (Event Handling):** .NET-এ ইভেন্ট হ্যান্ডলিং ডেলিগেটের উপর ভিত্তি করে তৈরি।  যেমন, একটি বাটনে ক্লিক করলে কোন মেথডটি কল হবে, তা ডেলিগেটের মাধ্যমে নির্ধারণ করা হয়। 
*   **মাল্টিকাস্টিং (Multicasting):** একটি ডেলিগেট একই সাথে একাধিক মেথডকে নির্দেশ করতে পারে। যখন ডেলিগেটটিকে কল করা হয়, তখন সবগুলো মেথড পর্যায়ক্রমে কল হয়। 

**বাংলায় উদাহরণ:**

ধরুন, আমরা একটি ক্যালকুলেটর তৈরি করতে চাই যেখানে যোগ এবং বিয়োগ করার জন্য আলাদা মেথড থাকবে। আমরা একটি ডেলিগেট ব্যবহার করে এই মেথডগুলোকে কল করতে পারি।

**ধাপ ১: ডেলিগেট ঘোষণা করা**

প্রথমে, আমাদের একটি ডেলিগেট ঘোষণা করতে হবে যা দুটি পূর্ণসংখ্যা (integer) প্যারামিটার হিসেবে নিবে এবং একটি পূর্ণসংখ্যা রিটার্ন করবে।

```csharp
// ডেলিগেট ঘোষণা
public delegate int Calculation(int a, int b);
```

**ধাপ ২: মেথড তৈরি করা**

এখন, আমরা ডেলিগেটের সিগনেচারের সাথে মিলে এমন দুটি মেথড তৈরি করব।

```csharp
public class Calculator
{
    public int Add(int x, int y)
    {
        return x + y;
    }

    public int Subtract(int x, int y)
    {
        return x - y;
    }
}```

**ধাপ ৩: ডেলিগেট ইনস্ট্যান্স তৈরি এবং ব্যবহার করা**

শেষে, আমরা `Main` মেথডের ভিতরে ডেলিগেটের ইনস্ট্যান্স তৈরি করব এবং তাকে আমাদের তৈরি করা মেথডগুলোর রেফারেন্স দিব।

```csharp
using System;

// ডেলিগেট ঘোষণা
public delegate int Calculation(int a, int b);

public class Calculator
{
    public int Add(int x, int y)
    {
        Console.WriteLine("যোগ করা হচ্ছে:");
        return x + y;
    }

    public int Subtract(int x, int y)
    {
        Console.WriteLine("বিয়োগ করা হচ্ছে:");
        return x - y;
    }
}

public class Program
{
    public static void Main(string[] args)
    {
        Calculator calc = new Calculator();

        // Add মেথডের জন্য ডেলিগেট ইনস্ট্যান্স তৈরি
        Calculation addDelegate = new Calculation(calc.Add);

        // ডেলিগেটের মাধ্যমে Add মেথড কল করা
        int sum = addDelegate(10, 5);
        Console.WriteLine("যোগফল: " + sum);

        Console.WriteLine();

        // Subtract মেথডের জন্য ডেলিগেট ইনস্ট্যান্স তৈরি
        Calculation subtractDelegate = new Calculation(calc.Subtract);

        // ডেলিগেটের মাধ্যমে Subtract মেথড কল করা
        int difference = subtractDelegate(10, 5);
        Console.WriteLine("বিয়োগফল: " + difference);
    }
}```

**আউটপুট:**

```
যোগ করা হচ্ছে:
যোগফল: 15

বিয়োগ করা হচ্ছে:
বিয়োগফল: 5
```

এই উদাহরণে, `Calculation` নামের ডেলিগেটটি `Add` এবং `Subtract` উভয় মেথডকেই নির্দেশ করতে পারছে কারণ তাদের উভয়েরই দুটি `int` প্যারামিটার এবং একটি `int` রিটার্ন টাইপ রয়েছে। ডেলিগেট ব্যবহার করে আমরা ডাইনামিকভাবে নির্ধারণ করতে পারছি কোন মেথডটি কল হবে।

.NET ফ্রেমওয়ার্কে এমন কিছু বিল্ট-ইন ডেলিগেট রয়েছে যা সাধারণভাবে ব্যবহৃত হয়। এর ফলে আপনাকে প্রত্যেকবার নতুন করে ডেলিগেট টাইপ ঘোষণা করতে হয় না। এই বিল্ট-ইন ডেলিগেটগুলো জেনেরিক (generic) হওয়ায় বিভিন্ন ধরনের ডেটা টাইপের সাথে কাজ করতে পারে। সবচেয়ে বেশি ব্যবহৃত তিনটি বিল্ট-ইন ডেলিগেট হলো: `Action`, `Func`, এবং `Predicate`।

আসুন এগুলো সম্পর্কে বিস্তারিত জেনে নেওয়া যাক:

### ১. Action ডেলিগেট

`Action` ডেলিগেট এমন মেথডকে নির্দেশ করে যা কোনো মান রিটার্ন করে না (অর্থাৎ, `void` রিটার্ন টাইপ)। 

*   **বৈশিষ্ট্য:**
    *   এটি কোনো মান রিটার্ন করে না (return type is `void`)।
    *   এটি ০ থেকে ১৬টি পর্যন্ত ইনপুট প্যারামিটার গ্রহণ করতে পারে। 
    *   এটি `System` নেমস্পেসের অধীনে থাকে। 

**উদাহরণ:**

`Action` ডেলিগেটের বিভিন্ন সংস্করণ রয়েছে, যেমন `Action` (কোনো প্যারামিটার ছাড়া), `Action<T>` (একটি প্যারামিটার), `Action<T1, T2>` (দুটি প্যারামিটার), ইত্যাদি।

**C# কোড:**

```csharp
using System;

public class Program
{
    public static void PrintMessage(string message)
    {
        Console.WriteLine(message);
    }

    public static void AddAndPrint(int a, int b)
    {
        Console.WriteLine($"The sum is: {a + b}");
    }

    public static void Main(string[] args)
    {
        // 1. Action<T> ডেলিগেট যা একটি string প্যারামিটার নেয়
        Action<string> printAction = PrintMessage;
        printAction("Hello from Action delegate!");

        // 2. Action<T1, T2> ডেলিগেট যা দুটি int প্যারামিটার নেয়
        Action<int, int> addAction = AddAndPrint;
        addAction(10, 20);

        // 3. ল্যামডা এক্সপ্রেশন (lambda expression) দিয়ে Action ব্যবহার
        Action<string> greetAction = (name) => Console.WriteLine($"Good morning, {name}!");
        greetAction("John");
    }
}
```

**আউটপুট:**

```
Hello from Action delegate!
The sum is: 30
Good morning, John!
```

### ২. Func ডেলিগেট

`Func` ডেলিগেট এমন একটি মেথডকে নির্দেশ করে যা একটি মান রিটার্ন করে। এটিও `Action`-এর মতোই একাধিক ইনপুট প্যারামিটার নিতে পারে। 

*   **বৈশিষ্ট্য:**
    *   এটি সবসময় একটি মান রিটার্ন করে। 
    *   এর জেনেরিক টাইপ প্যারামিটারের মধ্যে শেষেরটি সবসময় রিটার্ন টাইপ হয়। 
    *   এটি ০ থেকে ১৬টি পর্যন্ত ইনপুট প্যারামিটার গ্রহণ করতে পারে।
    *   এটি `System` নেমস্পেসের অধীনে থাকে। 

**উদাহরণ:**

`Func<TResult>` (কোনো ইনপুট ছাড়া, শুধু রিটার্ন), `Func<T, TResult>` (একটি ইনপুট, একটি রিটার্ন), `Func<T1, T2, TResult>` (দুটি ইনপুট, একটি রিটার্ন), ইত্যাদি।

**C# কোড:**

```csharp
using System;

public class Program
{
    public static int Add(int a, int b)
    {
        return a + b;
    }

    public static string GetCurrentDateTime()
    {
        return DateTime.Now.ToString();
    }

    public static void Main(string[] args)
    {
        // 1. Func<T1, T2, TResult> ডেলিগেট যা দুটি int নিয়ে একটি int রিটার্ন করে
        Func<int, int, int> addFunc = Add;
        int result = addFunc(15, 25);
        Console.WriteLine($"The result of addition is: {result}");

        // 2. Func<TResult> ডেলিগেট যা কোনো ইনপুট নেয় না কিন্তু string রিটার্ন করে
        Func<string> dateTimeFunc = GetCurrentDateTime;
        string currentTime = dateTimeFunc();
        Console.WriteLine($"Current time is: {currentTime}");

        // 3. ল্যামডা এক্সপ্রেশন দিয়ে Func ব্যবহার
        Func<double, double, double> multiplyFunc = (x, y) => x * y;
        double product = multiplyFunc(5.5, 10.0);
        Console.WriteLine($"The product is: {product}");
    }
}
```

**আউটপুট:**

```
The result of addition is: 40
Current time is: 8/6/2025 5:12:35 AM (আউটপুট আপনার সময় অনুযায়ী ভিন্ন হবে)
The product is: 55
```

### ৩. Predicate ডেলিগেট

`Predicate` ডেলিগেট `Func`-এর একটি বিশেষ রূপ। এটি এমন মেথডকে নির্দেশ করে যা একটি প্যারামিটার গ্রহণ করে এবং একটি বুলিয়ান (`bool`) মান (হয় `true` অথবা `false`) রিটার্ন করে। এটি সাধারণত কোনো শর্ত বা মানদণ্ড পরীক্ষা করার জন্য ব্যবহৃত হয়। 

*   **বৈশিষ্ট্য:**
    *   এটি সবসময় একটি `bool` মান রিটার্ন করে।
    *   এটি শুধুমাত্র একটি ইনপুট প্যারামিটার গ্রহণ করে।
    *   এটি `System` নেমস্পেসের অধীনে থাকে।
    *   এটি কালেকশনের আইটেম ফিল্টার করার জন্য খুব উপযোগী (যেমন `List<T>.FindAll` মেথডে)। 

**উদাহরণ:**

**C# কোড:**

```csharp
using System;
using System.Collections.Generic;

public class Program
{
    public static bool IsEven(int number)
    {
        return number % 2 == 0;
    }

    public static void Main(string[] args)
    {
        // Predicate<int> ডেলিগেট ব্যবহার করে একটি সংখ্যা জোড় কিনা তা পরীক্ষা করা
        Predicate<int> isEvenPredicate = IsEven;
        bool result1 = isEvenPredicate(10);
        bool result2 = isEvenPredicate(7);

        Console.WriteLine($"Is 10 an even number? {result1}");
        Console.WriteLine($"Is 7 an even number? {result2}");

        // List<T>.FindAll মেথডে Predicate ব্যবহার
        List<int> numbers = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

        // ল্যামডা এক্সপ্রেশন দিয়ে Predicate ব্যবহার
        List<int> evenNumbers = numbers.FindAll(n => n % 2 == 0);

        Console.Write("Even numbers in the list: ");
        foreach (var num in evenNumbers)
        {
            Console.Write(num + " ");
        }
        Console.WriteLine();
    }
}
```

**আউটপুট:**

```
Is 10 an even number? True
Is 7 an even number? False
Even numbers in the list: 2 4 6 8 10
```

এই বিল্ট-ইন ডেলিগেটগুলো কোডকে আরও সংক্ষিপ্ত, পঠনযোগ্য এবং কার্যকরী করে তোলে, কারণ আপনাকে সাধারণ কাজের জন্য বারবার ডেলিগেট ঘোষণা করার প্রয়োজন হয় না।