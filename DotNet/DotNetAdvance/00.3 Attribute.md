

C#-এ সরাসরি "অ্যানোটেশন" (Annotation) নামে কোনো ফিচার নেই, যেমনটি জাভাতে (Java) আছে। C#-এ এই একই ধারণার বাস্তবায়ন করা হয় **অ্যাট্রিবিউট (Attribute)** ব্যবহার করে। সুতরাং, যখন কেউ C#-এ অ্যানোটেশনের কথা বলে, তখন তিনি মূলত অ্যাট্রিবিউটকেই বোঝান। [১, ২]

### অ্যাট্রিবিউট (Attribute) কী?

**অ্যাট্রিবিউট** হলো এক ধরনের ডিক্লারেটিভ ট্যাগ বা ঘোষণামূলক তথ্য যা কোডের বিভিন্ন উপাদান যেমন— ক্লাস, মেথড, প্রপার্টি, অ্যাসেম্বলি ইত্যাদির সাথে অতিরিক্ত মেটাডেটা (metadata) বা তথ্য যুক্ত করার জন্য ব্যবহৃত হয়। [৩, ৪, ৬] এই মেটাডেটা কম্পাইলারকে বা অন্য কোনো টুলকে কোড সম্পর্কে বিশেষ নির্দেশনা দেয় অথবা রানটাইমে কোডের আচরণ পরিবর্তন করতে সাহায্য করে। [৩, ৫]

সহজ কথায়, অ্যাট্রিবিউট হলো কোডের উপর লাগানো একটি "লেবেল" যা কোডের নিজের কার্যকারিতা পরিবর্তন না করে তার সম্পর্কে অতিরিক্ত তথ্য প্রদান করে। [২]

### অ্যাট্রিবিউট কেন ব্যবহার করা হয়?

১.  **কম্পাইলারকে নির্দেশনা দেওয়া:** কিছু অ্যাট্রিবিউট কম্পাইলারকে বিশেষ বার্তা বা সতর্কবার্তা দিতে সাহায্য করে। যেমন, একটি মেথডকে পুরোনো বা অবসরে যাওয়া (obsolete) হিসেবে চিহ্নিত করা। [৮]
২.  **রানটাইমে তথ্য প্রদান:** অ্যাট্রিবিউট ব্যবহার করে রানটাইমে একটি ক্লাস বা মেথডের বৈশিষ্ট্য সম্পর্কে জানা যায়। এই প্রক্রিয়াটিকে "রিফ্লেকশন" (Reflection) বলা হয়। যেমন, একটি অবজেক্টকে কীভাবে সিরিয়ালাইজ (serialize) করতে হবে তা নির্ধারণ করা। [১১]
৩.  **ফ্রেমওয়ার্কের আচরণ নিয়ন্ত্রণ:** ASP.NET, Entity Framework, এবং অন্যান্য ফ্রেমওয়ার্ক অ্যাট্রিবিউট ব্যবহার করে কোডের আচরণ নিয়ন্ত্রণ করে। যেমন, একটি মডেলের প্রপার্টি ডাটাবেসের কলামের সাথে কীভাবে ম্যাপ হবে বা ওয়েব এপিআই-তে রাউটিং কীভাবে কাজ করবে তা নির্ধারণ করা। [৯]

---

### বাংলায় উদাহরণসহ ব্যাখ্যা

C#-এ অ্যাট্রিবিউট তৃতীয় বন্ধনীর (`[]`) মধ্যে লেখা হয় এবং যে উপাদানের উপর এটি প্রয়োগ করা হবে তার ঠিক আগে বসানো হয়। [৭]

#### উদাহরণ ১: `[Obsolete]` অ্যাট্রিবিউট

এই অ্যাট্রিবিউটটি কম্পাইলারকে বলার জন্য ব্যবহৃত হয় যে একটি নির্দিষ্ট মেথড বা ক্লাস এখন পুরোনো হয়ে গেছে এবং ভবিষ্যতে সরিয়ে ফেলা হতে পারে। এটি ব্যবহার করলে কম্পাইলার একটি সতর্কবার্তা (warning) দেখায়। [৮, ১০]

**C# কোড:**

```csharp
using System;

public class MyCalculator
{
    // এই মেথডটি এখন পুরোনো, এর পরিবর্তে AddNew মেথড ব্যবহার করা উচিত
    [Obsolete("এই মেথডটি আর ব্যবহার করবেন না। এর পরিবর্তে AddNew ব্যবহার করুন।")]
    public int AddOld(int a, int b)
    {
        return a + b;
    }

    public int AddNew(int a, int b)
    {
        return a + b;
    }
}

public class Program
{
    public static void Main()
    {
        MyCalculator calculator = new MyCalculator();

        // পুরোনো মেথডটি কল করার সময় কম্পাইলার একটি সতর্কবার্তা দেখাবে
        int sum = calculator.AddOld(5, 10);
        
        Console.WriteLine($"পুরাতন পদ্ধতিতে যোগফল: {sum}");

        int newSum = calculator.AddNew(5, 10);
        Console.WriteLine($"নতুন পদ্ধতিতে যোগফল: {newSum}");
    }
}
```

**কোডের ব্যাখ্যা:**
এখানে `AddOld` মেথডের উপরে `[Obsolete]` অ্যাট্রিবিউটটি যোগ করা হয়েছে। এর ফলে, যখনই কোনো ডেভেলপার `AddOld` মেথডটি ব্যবহার করার চেষ্টা করবেন, তখন Visual Studio-তে একটি সতর্কবার্তা দেখা যাবে এবং তাতে লেখা থাকবে: "এই মেথডটি আর ব্যবহার করবেন না। এর পরিবর্তে AddNew ব্যবহার করুন।" এটি কোডকে পরিষ্কার এবং আপ-টু-ডেট রাখতে সাহায্য করে।

---

#### উদাহরণ ২: `[Required]` অ্যাট্রিবিউট (ASP.NET Core / Entity Framework)

ওয়েব অ্যাপ্লিকেশন বা ডাটাবেস মডেলিংয়ে এই অ্যাট্রিবিউটটি খুব জনপ্রিয়। এটি নির্দেশ করে যে একটি প্রপার্টির মান অবশ্যই দিতে হবে (অর্থাৎ, এটি `null` হতে পারবে না)।

**C# কোড (একটি মডেল ক্লাসের জন্য):**

```csharp
using System.ComponentModel.DataAnnotations; // এই নেমস্পেসটি প্রয়োজন

public class User
{
    public int Id { get; set; }

    [Required(ErrorMessage = "ব্যবহারকারীর নাম অবশ্যই দিতে হবে।")]
    public string Name { get; set; }

    // EmailAddress অ্যাট্রিবিউটটি ইমেইলের ফরম্যাট সঠিক কিনা তা যাচাই করে
    [Required]
    [EmailAddress]
    public string Email { get; set; }

    public int Age { get; set; }
}
```

**কোডের ব্যাখ্যা:**
এই `User` ক্লাসে `Name` এবং `Email` প্রপার্টির উপরে `[Required]` অ্যাট্রিবিউট ব্যবহার করা হয়েছে।

*   **ASP.NET Core-এ:** যখন কোনো ব্যবহারকারী ফর্ম পূরণ করে ডেটা পাঠাবে, তখন ফ্রেমওয়ার্ক স্বয়ংক্রিয়ভাবে চেক করবে `Name` এবং `Email` ফিল্ডগুলো খালি আছে কিনা। যদি খালি থাকে, তাহলে `ErrorMessage`-এ দেওয়া বার্তাটি দেখানো হবে।
*   **Entity Framework-এ:** যখন ডাটাবেস টেবিল তৈরি করা হবে, তখন এই অ্যাট্রিবিউটের কারণে `Name` এবং `Email` কলামগুলো `NOT NULL` হিসেবে তৈরি হবে।

---

#### উদাহরণ ৩: কাস্টম অ্যাট্রিবিউট তৈরি

আপনি চাইলে নিজের প্রয়োজন অনুযায়ী কাস্টম অ্যাট্রিবিউটও তৈরি করতে পারেন।

**C# কোড:**

```csharp
using System;

// ১. কাস্টম অ্যাট্রিবিউট ক্লাস তৈরি (Attribute ক্লাস থেকে ইনহেরিট করতে হয়)
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method)]
public class HelpAttribute : Attribute
{
    public string Description { get; }

    public HelpAttribute(string description)
    {
        Description = description;
    }
}

// ২. কাস্টম অ্যাট্রিবিউট ব্যবহার
[Help("এটি একটি ইউটিলিটি ক্লাস যা বিভিন্ন কাজ করে।")]
public class MyUtility
{
    [Help("এই মেথডটি দুটি সংখ্যা যোগ করে।")]
    public void PerformAction()
    {
        Console.WriteLine("কাজ করা হচ্ছে...");
    }
}
```

**কোডের ব্যাখ্যা:**
এখানে আমরা `HelpAttribute` নামে একটি নতুন অ্যাট্রিবিউট তৈরি করেছি যা একটি বর্ণনা (description) গ্রহণ করে। `[AttributeUsage]` অ্যাট্রিবিউটটি নির্ধারণ করে দেয় যে আমাদের কাস্টম অ্যাট্রিবিউটটি কোথায় ব্যবহার করা যাবে (যেমন, ক্লাস এবং মেথডের উপর)। এরপর `MyUtility` ক্লাস এবং `PerformAction` মেথডের উপর এটি ব্যবহার করে অতিরিক্ত তথ্য যোগ করা হয়েছে, যা পরে "রিফ্লেকশন" ব্যবহার করে পড়া যেতে পারে।

মূলত, C#-এর অ্যাট্রিবিউট একটি শক্তিশালী ফিচার যা কোডকে আরও তথ্যবহুল, ঘোষণামূলক এবং ফ্রেমওয়ার্কের সাথে সহজে একীভূত হতে সাহায্য করে।



অবশ্যই, C# অ্যাট্রিবিউটের আরও পাঁচটি গুরুত্বপূর্ণ উদাহরণ নিচে বাংলা ব্যাখ্যাসহ দেওয়া হলো:

---

### ১. `[Serializable]` অ্যাট্রিবিউট

**ব্যাখ্যা:**
এই অ্যাট্রিবিউটটি একটি ক্লাসকে চিহ্নিত করে, যার মানে হলো ওই ক্লাসের অবজেক্টকে একটি বাইট স্ট্রিমে (stream of bytes) রূপান্তর করা যাবে। এই প্রক্রিয়াটিকে সিরিয়ালাইজেশন (Serialization) বলা হয়। সিরিয়ালাইজেশন সাধারণত কোনো অবজেক্টকে ফাইলে সংরক্ষণ করতে, নেটওয়ার্কে পাঠাতে বা ডাটাবেসে জমা রাখতে ব্যবহৃত হয়। `[Serializable]` অ্যাট্রিবিউটটি না থাকলে একটি অবজেক্টকে বাইনারি ফরম্যাটে সিরিয়ালাইজ করা যায় না।

**সহজ উপমা:**
মনে করুন, আপনার কাছে একটি লেগো দিয়ে বানানো গাড়ি আছে (এটি একটি অবজেক্ট)। আপনি যদি এই গাড়িটি একটি বন্ধুকে পাঠাতে চান, তাহলে পুরো গাড়িটি পাঠানো কঠিন। এর পরিবর্তে, আপনি গাড়িটিকে আবার ছোট ছোট লেগো ব্লকে (বাইট স্ট্রিমে) পরিণত করে একটি বক্সে ভরতে পারেন। এই বক্সটিই হলো সিরিয়ালাইজড ডেটা। আপনার বন্ধু বক্সটি পাওয়ার পর সেই ব্লকগুলো দিয়ে আবার আগের মতো গাড়িটি বানিয়ে নিতে পারবে (এই প্রক্রিয়াকে ডিসিরিয়ালাইজেশন বলে)।

**উদাহরণ (C#):**

```csharp
using System;
using System.IO;
using System.Runtime.Serialization.Formatters.Binary;

// ১. ক্লাসকে Serializable হিসেবে চিহ্নিত করা
[Serializable]
public class UserProfile
{
    public int Id { get; set; }
    public string Name { get; set; }
    // NonSerialized অ্যাট্রিবিউট ব্যবহার করলে এই প্রপার্টি সিরিয়ালাইজ হবে না
    [NonSerialized]
    public string Password; 
}

public class Program
{
    public static void Main()
    {
        UserProfile user = new UserProfile
        {
            Id = 101,
            Name = "Mina Rahman",
            Password = "MySecretPassword123"
        };

        // ২. অবজেক্টকে ফাইলে সিরিয়ালাইজ করা
        using (FileStream fs = new FileStream("user.dat", FileMode.Create))
        {
            BinaryFormatter formatter = new BinaryFormatter();
            formatter.Serialize(fs, user);
            Console.WriteLine("অবজেক্টটি সফলভাবে 'user.dat' ফাইলে সংরক্ষণ করা হয়েছে।");
        }
        
        // ৩. ফাইল থেকে অবজেক্টকে ডিসিরিয়ালাইজ করা
        using (FileStream fs = new FileStream("user.dat", FileMode.Open))
        {
            BinaryFormatter formatter = new BinaryFormatter();
            UserProfile savedUser = (UserProfile)formatter.Deserialize(fs);
            
            Console.WriteLine("\nফাইল থেকে পাওয়া ডেটা:");
            Console.WriteLine($"ID: {savedUser.Id}");
            Console.WriteLine($"Name: {savedUser.Name}");
            // Password এর মান null হবে কারণ এটি NonSerialized ছিল
            Console.WriteLine($"Password: {savedUser.Password ?? "সংরক্ষণ করা হয়নি"}");
        }
    }
}
```

**কোডের ব্যাখ্যা:**
`UserProfile` ক্লাসের উপর `[Serializable]` অ্যাট্রিবিউটটি থাকায় আমরা `BinaryFormatter` ব্যবহার করে `user` অবজেক্টটিকে একটি ফাইলে সংরক্ষণ করতে পারছি। `Password` প্রপার্টির উপর `[NonSerialized]` অ্যাট্রিবিউট থাকায় নিরাপত্তার জন্য এটি ফাইলে সংরক্ষিত হয়নি।

---

### ২. `[Conditional]` অ্যাট্রিবিউট

**ব্যাখ্যা:**
এই অ্যাট্রিবিউটটি কম্পাইলারকে নির্দেশ দেয় যে একটি নির্দিষ্ট মেথডের কল শুধুমাত্র তখনই কোডে অন্তর্ভুক্ত করতে হবে, যখন একটি নির্দিষ্ট কন্ডিশনাল কম্পাইলেশন সিম্বল (যেমন, `DEBUG`) ডিফাইন করা থাকে। এটি সাধারণত ডিবাগিং বা টেস্টিং এর জন্য সহায়ক কোড লেখার জন্য ব্যবহৃত হয়, যা রিলিজ ভার্সনে স্বয়ংক্রিয়ভাবে বাদ পড়ে যায়।

**সহজ উপমা:**
ধরুন, আপনি একটি সিনেমার শুটিং করছেন। শুটিংয়ের সময় পরিচালকের কিছু নির্দেশনা (যেমন, "ক্যামেরা ২ ফোকাস করো") থাকে যা শুধুমাত্র শুটিং টিমের জন্য প্রযোজ্য। সিনেমার চূড়ান্ত ভার্সনে (রিলিজ) এই নির্দেশনাগুলো কেটে ফেলা হয়। `[Conditional]` অ্যাট্রিবিউট ঠিক এই কাজটিই করে—এটি শুধুমাত্র ডেভেলপমেন্ট বা ডিবাগ পর্যায়ে কোডকে সক্রিয় রাখে।

**উদাহরণ (C#):**

```csharp
#define DEBUG // এই সিম্বলটি ডিফাইন করা আছে

using System;
using System.Diagnostics;

public class Logger
{
    [Conditional("DEBUG")]
    public static void Log(string message)
    {
        Console.WriteLine($"[ডিবাগ লগ]: {message}");
    }
}

public class Program
{
    public static void Main()
    {
        Console.WriteLine("প্রোগ্রাম শুরু হয়েছে।");
        
        // এই লাইনটি শুধুমাত্র DEBUG মোডে কম্পাইল হবে
        Logger.Log("একটি গুরুত্বপূর্ণ ভেরিয়েবলের মান পরীক্ষা করা হচ্ছে।");
        
        Console.WriteLine("প্রোগ্রাম শেষ হয়েছে।");
    }
}
```

**কোডের ব্যাখ্যা:**
`Logger.Log` মেথডের উপর `[Conditional("DEBUG")]` অ্যাট্রিবিউটটি দেওয়া আছে। যেহেতু ফাইলের শুরুতে `#define DEBUG` লেখা আছে, তাই `Main` মেথডের ভেতর `Logger.Log` এর কলটি কোডে থাকবে এবং আউটপুটে ডিবাগ বার্তাটি দেখা যাবে। আপনি যদি `#define DEBUG` লাইনটি মুছে দিয়ে কোড চালান, তাহলে `Logger.Log` এর কলটি কম্পাইলার দ্বারা উপেক্ষা করা হবে এবং আউটপুটে ডিবাগ বার্তাটি আসবে না।

---

### ৩. `[CallerMemberName]` অ্যাট্রিবিউট

**ব্যাখ্যা:**
এটি একটি বিশেষ অ্যাট্রিবিউট যা একটি মেথডের প্যারামিটারে ব্যবহৃত হয়। এটি ব্যবহার করলে কম্পাইলার স্বয়ংক্রিয়ভাবে ওই প্যারামিটারের মান হিসেবে কলার মেথড বা প্রপার্টির নাম পাঠিয়ে দেয়। এটি `INotifyPropertyChanged` বাস্তবায়নের সময় "ম্যাজিক স্ট্রিং" (hard-coded string) এড়াতে খুব কার্যকর।

**সহজ উপমা:**
ধরুন, আপনি একটি অফিসে ফোন করলেন। রিসিভার যদি `[CallerMemberName]` ব্যবহার করে, তাহলে তাকে জিজ্ঞেস করতে হবে না "কে বলছেন?", সিস্টেম স্বয়ংক্রিয়ভাবে আপনার নাম (কলার মেথডের নাম) দেখিয়ে দেবে।

**উদাহরণ (C#):**

```csharp
using System;
using System.ComponentModel;
using System.Runtime.CompilerServices;

public class Player : INotifyPropertyChanged
{
    private string _name;

    public event PropertyChangedEventHandler PropertyChanged;

    public string Name
    {
        get { return _name; }
        set
        {
            if (_name != value)
            {
                _name = value;
                // এখানে প্রপার্টির নাম ("Name") ম্যানুয়ালি লিখতে হচ্ছে না
                OnPropertyChanged();
            }
        }
    }

    // [CallerMemberName] অ্যাট্রিবিউট ব্যবহার করা হয়েছে
    protected void OnPropertyChanged([CallerMemberName] string propertyName = null)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}

public class Program
{
    public static void Main()
    {
        Player player = new Player();
        
        // সাবস্ক্রাইব করা ताकि পরিবর্তন হলে নোটিফিকেশন পাওয়া যায়
        player.PropertyChanged += (sender, args) => {
            Console.WriteLine($"'{args.PropertyName}' প্রপার্টি পরিবর্তন হয়েছে।");
        };

        player.Name = "Sakib Al Hasan";
    }
}
```

**কোডের ব্যাখ্যা:**
`OnPropertyChanged` মেথডে `propertyName` প্যারামিটারের আগে `[CallerMemberName]` ব্যবহার করা হয়েছে। যখন `Name` প্রপার্টির `set` ব্লক থেকে `OnPropertyChanged()` কল করা হয়, তখন কম্পাইলার স্বয়ংক্রিয়ভাবে `propertyName` এর মান হিসেবে `"Name"` পাঠিয়ে দেয়। ফলে, আমাদের হার্ড-কোড করে `"Name"` লিখতে হয় না, যা কোডকে আরও নিরাপদ এবং রক্ষণাবেক্ষণযোগ্য করে তোলে।

---

### ৪. `[DllImport]` অ্যাট্রিবিউট

**ব্যাখ্যা:**
এই অ্যাট্রিবিউটটি C# কোডকে আনম্যানেজড (unmanaged) লাইব্রেরি (যেমন, C/C++ এ লেখা DLL ফাইল) থেকে ফাংশন কল করার সুযোগ দেয়। এটি .NET এর প্ল্যাটফর্ম ইনভোক (P/Invoke) ফিচারের একটি অংশ। এটি ব্যবহার করে উইন্ডোজ এপিআই (Windows API) এর মতো সিস্টেম-লেভেল ফাংশন কল করা যায়।

**সহজ উপমা:**
মনে করুন, আপনার অফিসে একজন বিশেষজ্ঞ আছেন যিনি একটি বিশেষ কাজ খুব ভালো পারেন, কিন্তু তিনি আপনার দলের অংশ নন এবং ভিন্ন ভাষায় কথা বলেন। `[DllImport]` অ্যাট্রিবিউটটি একজন দোভাষীর মতো কাজ করে, যা আপনাকে সেই বিশেষজ্ঞের সাথে যোগাযোগ করতে এবং তার সেবা গ্রহণ করতে সাহায্য করে।

**উদাহরণ (C#):**

```csharp
using System;
using System.Runtime.InteropServices;

public class Program
{
    // user32.dll থেকে MessageBox ফাংশনটি ইম্পোর্ট করা হচ্ছে
    [DllImport("user32.dll", CharSet = CharSet.Unicode)]
    public static extern int MessageBox(IntPtr hWnd, string text, string caption, uint type);

    public static void Main()
    {
        Console.WriteLine("উইন্ডোজ মেসেজ বক্স দেখানোর জন্য প্রস্তুত...");
        
        // ইম্পোর্ট করা MessageBox ফাংশনটি কল করা
        MessageBox(IntPtr.Zero, "আপনি কি C# অ্যাট্রিবিউট শিখছেন?", "শিক্ষামূলক বার্তা", 0);
        
        Console.WriteLine("মেসেজ বক্স বন্ধ করা হয়েছে।");
    }
}
```

**কোডের ব্যাখ্যা:**
`[DllImport("user32.dll")]` অ্যাট্রিবিউটটি কম্পাইলারকে জানায় যে `MessageBox` ফাংশনটি C# কোডের অংশ নয়, বরং এটি উইন্ডোজের সিস্টেম ফাইল `user32.dll`-এর ভেতরে রয়েছে। এর ফলে আমরা সরাসরি C# থেকে একটি নেটিভ উইন্ডোজ পপ-আপ মেসেজ বক্স দেখাতে পারছি।

---

### ৫. `[TestMethod]` (Unit Testing Framework-এর অ্যাট্রিবিউট)

**ব্যাখ্যা:**
এটি সরাসরি C# ল্যাঙ্গুয়েজের অংশ নয়, তবে MSTest, NUnit, xUnit এর মতো ইউনিট টেস্টিং ফ্রেমওয়ার্কগুলোতে এটি ব্যাপকভাবে ব্যবহৃত হয়। `[TestMethod]` অ্যাট্রিবিউটটি একটি মেথডকে টেস্ট মেথড হিসেবে চিহ্নিত করে। টেস্ট রানার (Test Runner) সফটওয়্যার এই অ্যাট্রিবিউট দেখেই বুঝতে পারে কোন মেথডগুলো চালাতে হবে এবং সেগুলোর ফলাফল সফল (pass) না ব্যর্থ (fail) তা যাচাই করতে হবে।

**সহজ উপমা:**
স্কুলের পরীক্ষার খাতায় আপনি প্রতিটি উত্তরের শুরুতে যেমন "প্রশ্ন নং ১ এর উত্তর" লেখেন, `[TestMethod]` অ্যাট্রিবিউটটিও তেমনি। এটি টেস্ট রানারকে বলে দেয়, "এই মেথডটি একটি টেস্ট, একে চালাও এবং ফলাফল পরীক্ষা করো"।

**উদাহরণ (C# - MSTest ফ্রেমওয়ার্ক):**

```csharp
// এই অ্যাট্রিবিউটটি একটি ক্লাসকে টেস্ট ক্লাস হিসেবে চিহ্নিত করে
[TestClass]
public class CalculatorTests
{
    // এই অ্যাট্রিবিউটটি একটি মেথডকে টেস্ট মেথড হিসেবে চিহ্নিত করে
    [TestMethod]
    public void Add_SimpleValues_ReturnsCorrectSum()
    {
        // Arrange: পরীক্ষার জন্য প্রয়োজনীয় উপকরণ সাজানো
        Calculator calc = new Calculator();
        int a = 5;
        int b = 10;
        int expected = 15;

        // Act: যে কাজটি পরীক্ষা করা হচ্ছে সেটি করা
        int actual = calc.Add(a, b);

        // Assert: ফলাফল প্রত্যাশা অনুযায়ী হয়েছে কিনা তা যাচাই করা
        Assert.AreEqual(expected, actual, "যোগফল সঠিক হয়নি।");
    }
}

// যে ক্লাসটি পরীক্ষা করা হচ্ছে
public class Calculator
{
    public int Add(int x, int y)
    {
        return x + y;
    }
}
```

**কোডের ব্যাখ্যা:**
`CalculatorTests` ক্লাসের উপর `[TestClass]` এবং `Add_SimpleValues_ReturnsCorrectSum` মেথডের উপর `[TestMethod]` অ্যাট্রিবিউট ব্যবহার করা হয়েছে। যখন আপনি Visual Studio-তে Test Explorer চালাবেন, তখন এটি এই অ্যাট্রিবিউটগুলো দেখে `Add_SimpleValues_ReturnsCorrectSum` মেথডটিকে একটি টেস্ট হিসেবে শনাক্ত করবে এবং চালাবে। `Assert.AreEqual` মেথডটি যাচাই করবে যে `actual` এবং `expected` মান দুটি সমান কিনা। যদি সমান হয়, টেস্টটি পাস করবে, অন্যথায় ফেল করবে।


অবশ্যই, এখানে কাস্টম অ্যাট্রিবিউট (Custom Attribute) তৈরির পাঁচটি বিস্তারিত উদাহরণ বাংলা ব্যাখ্যাসহ দেওয়া হলো। প্রতিটি উদাহরণে আমরা দেখব কীভাবে একটি কাস্টম অ্যাট্রিবিউট তৈরি করতে হয়, কীভাবে এটি ব্যবহার করতে হয়, এবং কীভাবে রিফ্লেকশন (Reflection) ব্যবহার করে সেই অ্যাট্রিবিউটের তথ্য পড়া যায়।

---

### কাস্টম অ্যাট্রিবিউট তৈরির সাধারণ ধাপ:
১.  `System.Attribute` ক্লাস থেকে ইনহেরিট করে একটি নতুন ক্লাস তৈরি করতে হবে।
২.  `[AttributeUsage]` অ্যাট্রিবিউট ব্যবহার করে নির্ধারণ করতে হবে আমাদের কাস্টম অ্যাট্রিবিউটটি কোথায় ব্যবহার করা যাবে (যেমন: ক্লাস, মেথড, প্রপার্টি)।
৩.  অ্যাট্রিবিউটের মধ্যে যে ডেটা সংরক্ষণ করতে চাই তার জন্য প্রপার্টি এবং কনস্ট্রাক্টর তৈরি করতে হবে।

---

### ১. কোড পর্যালোচনার জন্য `CodeReview` অ্যাট্রিবিউট

**উদ্দেশ্য:** কোনো একটি ক্লাস বা মেথড কে, কবে এবং কেন রিভিউ করেছে, সেই তথ্য কোডের সাথে জুড়ে দেওয়া। এটি টিম ওয়ার্ক এবং কোড ব্যবস্থাপনার জন্য খুবই সহায়ক।

**ধাপ ১: অ্যাট্রিবিউট ক্লাস তৈরি**```csharp
using System;

// এই অ্যাট্রিবিউটটি ক্লাস এবং মেথডের উপর ব্যবহার করা যাবে
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, AllowMultiple = true)]
public class CodeReviewAttribute : Attribute
{
    public string ReviewerName { get; }
    public string ReviewDate { get; }
    public bool IsApproved { get; set; } // এটি একটি ঐচ্ছিক প্রপার্টি

    public CodeReviewAttribute(string reviewerName, string reviewDate)
    {
        ReviewerName = reviewerName;
        ReviewDate = reviewDate;
        IsApproved = false; // ডিফল্ট মান
    }
}
```

**ধাপ ২: অ্যাট্রিবিউট ব্যবহার**
```csharp
[CodeReview("Mizanur Rahman", "2024-10-22", IsApproved = true)]
[CodeReview("Farhana Yasmin", "2024-10-23", IsApproved = true)]
public class Account
{
    [CodeReview("Mizanur Rahman", "2024-10-21")]
    public void Deposit(decimal amount)
    {
        // টাকা জমার লজিক
    }
}
```

**ধাপ ৩: অ্যাট্রিবিউটের তথ্য পড়া (রিফ্লেকশন ব্যবহার করে)**
```csharp
using System.Reflection;

public class ReviewReporter
{
    public static void GenerateReport(Type type)
    {
        Console.WriteLine($"--- রিভিউ রিপোর্ট: {type.Name} ---");

        // ক্লাসের উপর ব্যবহৃত অ্যাট্রিবিউটগুলো পড়া
        foreach (var attr in type.GetCustomAttributes<CodeReviewAttribute>())
        {
            Console.WriteLine($"রিভিউ করেছেন: {attr.ReviewerName}, তারিখ: {attr.ReviewDate}, অনুমোদন: {attr.IsApproved}");
        }

        // ক্লাসের মেথডগুলোর উপর ব্যবহৃত অ্যাট্রিবিউট পড়া
        foreach (var method in type.GetMethods())
        {
            foreach (var attr in method.GetCustomAttributes<CodeReviewAttribute>())
            {
                Console.WriteLine($"মেথড '{method.Name}' রিভিউ করেছেন: {attr.ReviewerName}, তারিখ: {attr.ReviewDate}");
            }
        }
    }
}

// Main মেথডে ব্যবহার
// ReviewReporter.GenerateReport(typeof(Account));
```

**কোডের ব্যাখ্যা:** `CodeReviewAttribute` ক্লাসটি রিভিউয়ারের নাম ও তারিখ সংরক্ষণ করে। `Account` ক্লাসে এটি ব্যবহার করা হয়েছে। `ReviewReporter` ক্লাসটি রিফ্লেকশন ব্যবহার করে `Account` ক্লাস এবং তার মেথড থেকে এই রিভিউ তথ্যগুলো পড়ে একটি রিপোর্ট তৈরি করছে।

---

### ২. এক্সিকিউশন নিয়ন্ত্রণের জন্য `RequiresPermission` অ্যাট্রিবিউট

**উদ্দেশ্য:** একটি মেথড চালানোর জন্য ব্যবহারকারীর নির্দিষ্ট অনুমতি (permission) প্রয়োজন কিনা তা নির্ধারণ করা। যদি ব্যবহারকারীর প্রয়োজনীয় অনুমতি না থাকে, তাহলে মেথডটি চালানো হবে না।

**ধাপ ১: অ্যাট্রিবিউট ক্লাস তৈরি**
```csharp
using System;

public enum PermissionLevel { Guest, User, Admin }

[AttributeUsage(AttributeTargets.Method)]
public class RequiresPermissionAttribute : Attribute
{
    public PermissionLevel RequiredPermission { get; }

    public RequiresPermissionAttribute(PermissionLevel permission)
    {
        RequiredPermission = permission;
    }
}
```

**ধাপ ২: অ্যাট্রিবিউট ব্যবহার**
```csharp
public class AdminPanel
{
    [RequiresPermission(PermissionLevel.Admin)]
    public void DeleteUser(int userId)
    {
        Console.WriteLine($"ব্যবহারকারী {userId} সফলভাবে ডিলিট করা হয়েছে।");
    }

    [RequiresPermission(PermissionLevel.User)]
    public void ViewDashboard()
    {
        Console.WriteLine("ড্যাশবোর্ড দেখা যাচ্ছে।");
    }
}
```

**ধাপ ৩: অ্যাট্রিবিউটের তথ্য পড়া এবং ব্যবহার**
```csharp
using System.Reflection;

public class AccessManager
{
    public static void Execute(object panel, string methodName, PermissionLevel currentUserPermission)
    {
        MethodInfo method = panel.GetType().GetMethod(methodName);
        var requiredAttr = method.GetCustomAttribute<RequiresPermissionAttribute>();

        if (requiredAttr != null)
        {
            Console.WriteLine($"'{method.Name}' মেথডটির জন্য '{requiredAttr.RequiredPermission}' লেভেলের অনুমতি প্রয়োজন।");
            if (currentUserPermission >= requiredAttr.RequiredPermission)
            {
                Console.WriteLine("অনুমতি আছে। মেথডটি চালানো হচ্ছে...");
                // মেথডটি কল করা (প্যারামিটার ছাড়া মেথডের জন্য)
                method.Invoke(panel, new object[] { 101 }); // DeleteUser এর জন্য একটি আর্গুমেন্ট পাঠানো হলো
            }
            else
            {
                Console.WriteLine("ত্রুটি: আপনার প্রয়োজনীয় অনুমতি নেই!");
            }
        }
    }
}

// Main মেথডে ব্যবহার
// AdminPanel panel = new AdminPanel();
// AccessManager.Execute(panel, "DeleteUser", PermissionLevel.User); // আউটপুট: অনুমতি নেই
// AccessManager.Execute(panel, "DeleteUser", PermissionLevel.Admin); // আউটপুট: সফলভাবে ডিলিট
```

**কোডের ব্যাখ্যা:** `RequiresPermissionAttribute` একটি মেথড চালানোর জন্য প্রয়োজনীয় `PermissionLevel` নির্ধারণ করে। `AccessManager` ক্লাসটি কোনো মেথড চালানোর আগে রিফ্লেকশন দিয়ে চেক করে নেয় যে বর্তমান ব্যবহারকারীর সেই অনুমতি আছে কিনা এবং সেই অনুযায়ী মেথডটি চালায় বা বাধা দেয়।

---

### ৩. ডাটা ম্যাপিং এর জন্য `ColumnName` অ্যাট্রিবিউট

**উদ্দেশ্য:** একটি ক্লাসের প্রপার্টিকে ডাটাবেসের একটি নির্দিষ্ট কলামের নামের সাথে ম্যাপ করা। এটি ORM (Object-Relational Mapping) তৈরিতে খুব দরকারি।

**ধাপ ১: অ্যাট্রিবিউট ক্লাস তৈরি**
```csharp
[AttributeUsage(AttributeTargets.Property)]
public class ColumnNameAttribute : Attribute
{
    public string Name { get; }
    public ColumnNameAttribute(string name) => Name = name;
}
```

**ধাপ ২: অ্যাট্রিবিউট ব্যবহার**
```csharp
public class Product
{
    [ColumnName("product_id")]
    public int Id { get; set; }

    [ColumnName("product_name")]
    public string Name { get; set; }

    public decimal Price { get; set; } // কোনো অ্যাট্রিবিউট নেই, তাই প্রপার্টির নামই ব্যবহৃত হবে
}
```

**ধাপ ৩: অ্যাট্রিবিউটের তথ্য পড়া**
```csharp
public class SqlGenerator
{
    public static string GenerateSelectQuery(Type type)
    {
        string tableName = type.Name + "s"; // যেমন: Products
        string columns = "";

        foreach (var prop in type.GetProperties())
        {
            var attr = prop.GetCustomAttribute<ColumnNameAttribute>();
            string columnName = attr?.Name ?? prop.Name; // অ্যাট্রিবিউট থাকলে তার নাম, না থাকলে প্রপার্টির নাম
            columns += $"{columnName}, ";
        }
        columns = columns.TrimEnd(',', ' ');

        return $"SELECT {columns} FROM {tableName};";
    }
}

// Main মেথডে ব্যবহার
// string query = SqlGenerator.GenerateSelectQuery(typeof(Product));
// Console.WriteLine(query); // আউটপুট: SELECT product_id, product_name, Price FROM Products;```

**কোডের ব্যাখ্যা:** `ColumnNameAttribute` ব্যবহার করে ক্লাসের প্রপার্টিকে ডাটাবেসের কলামের নামের সাথে যুক্ত করা হয়েছে। `SqlGenerator` ক্লাসটি রিফ্লেকশন ব্যবহার করে এই অ্যাট্রিবিউটগুলো পড়ে একটি ডাইনামিক SQL SELECT কোয়েরি তৈরি করছে।

---

### ৪. ইউনিট টেস্টের জন্য `TestCaseAuthor` অ্যাট্রিবিউট

**উদ্দেশ্য:** প্রতিটি ইউনিট টেস্ট কে লিখেছেন তা ট্র্যাক করা। এটি কোড রক্ষণাবেক্ষণের জন্য সহায়ক।

**ধাপ ১: অ্যাট্রিবিউট ক্লাস তৈরি**
```csharp
[AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
public class TestCaseAuthorAttribute : Attribute
{
    public string Author { get; }
    public TestCaseAuthorAttribute(string author) => Author = author;
}
```

**ধাপ ২: অ্যাট্রিবিউট ব্যবহার**```csharp
public class MyMathTests
{
    [TestCaseAuthor("Rina")]
    public void TestAddition()
    {
        // ... test logic
    }
    
    [TestCaseAuthor("Karim")]
    public void TestSubtraction()
    {
        // ... test logic
    }
}
```

**ধাপ ৩: অ্যাট্রিবিউটের তথ্য পড়া**
```csharp
public class TestRunner
{
    public static void RunTests(Type testClass)
    {
        foreach (var method in testClass.GetMethods())
        {
            var attr = method.GetCustomAttribute<TestCaseAuthorAttribute>();
            if (attr != null)
            {
                Console.WriteLine($"'{method.Name}' টেস্টটি চালানো হচ্ছে... লেখক: {attr.Author}");
                // এখানে টেস্ট চালানোর আসল লজিক থাকবে
            }
        }
    }
}

// Main মেথডে ব্যবহার
// TestRunner.RunTests(typeof(MyMathTests));```

**কোডের ব্যাখ্যা:** `TestCaseAuthorAttribute` দিয়ে প্রতিটি টেস্ট মেথডের লেখকের নাম যুক্ত করা হয়েছে। `TestRunner` ক্লাসটি রিফ্লেকশন ব্যবহার করে সব টেস্ট এবং তাদের লেখকদের একটি তালিকা দেখাতে পারে।

---

### ৫. ডিবাগিং এর জন্য `Log` অ্যাট্রিবিউট

**উদ্দেশ্য:** কোনো একটি মেথড কল হলে তার নাম এবং প্যারামিটারের মান স্বয়ংক্রিয়ভাবে লগ করা, যা ডিবাগিং এর সময় খুব কার্যকর।

**ধাপ ১: অ্যাট্রিবিউট ক্লাস তৈরি**
```csharp
[AttributeUsage(AttributeTargets.Method)]
public class LogAttribute : Attribute { }
```

**ধাপ ২: অ্যাট্রিবিউট ব্যবহার**
```csharp
public class PaymentProcessor
{
    [Log]
    public void ProcessPayment(string user, decimal amount)
    {
        Console.WriteLine($"{user} এর জন্য {amount} টাকার পেমেন্ট প্রসেস করা হচ্ছে।");
    }
    
    public void RefundPayment(string user)
    {
        // ...
    }
}
```

**ধাপ ৩: অ্যাট্রিবিউটের তথ্য পড়া এবং ব্যবহার (Dynamic Proxy ব্যবহার করে)**
এই উদাহরণটি একটু জটিল কারণ মেথড কলের আগে ও পরে কাজ করার জন্য সাধারণত پراکسي বা AOP (Aspect-Oriented Programming) ফ্রেমওয়ার্ক ব্যবহার করা হয়। নিচে একটি সরলীকৃত উদাহরণ দেওয়া হলো।

```csharp
public class LoggerProxy
{
    public static void Invoke(object target, MethodInfo method, object[] args)
    {
        var hasLogAttr = method.IsDefined(typeof(LogAttribute), true);

        if (hasLogAttr)
        {
            Console.WriteLine($"[লগ] মেথড কল হচ্ছে: {method.Name}, আর্গুমেন্ট: {string.Join(", ", args)}");
        }

        // আসল মেথডটি কল করা
        method.Invoke(target, args);

        if (hasLogAttr)
        {
            Console.WriteLine($"[লগ] মেথড কল শেষ: {method.Name}");
        }
    }
}

// Main মেথডে ব্যবহার
// PaymentProcessor processor = new PaymentProcessor();
// MethodInfo processMethod = typeof(PaymentProcessor).GetMethod("ProcessPayment");
// LoggerProxy.Invoke(processor, processMethod, new object[] { "Rahim", 550.75m });
```

**কোডের ব্যাখ্যা:** `LogAttribute` একটি মার্কার হিসেবে কাজ করছে। `LoggerProxy` ক্লাসটি রিফ্লেকশন ব্যবহার করে চেক করে যে কোনো মেথডের উপর `Log` অ্যাট্রিবিউট আছে কিনা। যদি থাকে, তাহলে মেথডটি কল করার আগে এবং পরে স্বয়ংক্রিয়ভাবে লগিং বার্তা প্রিন্ট করে। এটি কোডকে পরিষ্কার রাখে কারণ লগিং লজিক মূল বিজনেস লজিকের সাথে মিশে যায় না।