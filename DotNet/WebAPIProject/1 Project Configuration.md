
### Create a Project 

Let's open Visual Studio, we are going to use VS 2022, and create a new ASP.NET Core Web API Application:

![[DotNet/WebAPIProject/images/image_1.png]]


![[DotNet/WebAPIProject/images/image_2.png]]
Now we can proceed by clicking the Create button and the project will start initializing.

### launchSettings.json File  Configuration 

![[DotNet/WebAPIProject/images/image_3.png]]


After the project has been created, we are going to modify the ==launchSettings.json== file, which can be found in the Properties section of the Solution Explorer window. This configuration determines the launch behavior of the ASP.NET Core applications. As we can see, it contains both configurations to launch settings for IIS and self-hosted applications (Kestrel). For now, let’s change the launchBrowser property to ==false== to prevent the web browser from launching on application start. We’ll also remove the entier http profile from the profiles object and modify the   property for the https profile:
```json

{
  "$schema": "https://json.schemastore.org/launchsettings.json",
  "iisSettings": {
    "windowsAuthentication": false,
    "anonymousAuthentication": true,
    "iisExpress": {
      "applicationUrl": "http://localhost:46969",
      "sslPort": 44389
    }
  },
  "profiles": {
    "https": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": false,
      "launchUrl": "weatherforecast",
      "applicationUrl": "https://localhost:5001;http://localhost:5000",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    },
    "IIS Express": {
      "commandName": "IISExpress",
      "launchBrowser": false,
      "launchUrl": "weatherforecast",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    }
  }
}

```
This is convenient since we are developing a Web API project and we don’t need a browser to check our API out.
We will use Postman (described later) for this purpose.
If you’ve checked Configure for HTTPS checkbox earlier in the setup phase, you will end up with two URLs in the applicationUrl section — one for HTTPS` (localhost:5001)`, and one for HTTP `(localhost:5000)`.
You’ll also notice the sslPort property which indicates that our application, when running in IISExpress, will be configured for HTTPS `(port 44389)`, too.

NOTE: This HTTPS configuration is only valid in the local environment. You will have to configure a valid certificate and HTTPS redirection once you deploy the application

### Program.cs 
is the entry point to our application and it looks like this:
```C#
var builder = WebApplication.CreateBuilder(args);

// Add services to the container.

builder.Services.AddControllers();
// Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

var app = builder.Build();

// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseHttpsRedirection();

app.UseAuthorization();

app.MapControllers();

app.Run();

```

**==“Top-level statements”==** means the compiler generates the namespace, class, and method elements for the main program in our application. We can see that we don’t have the class block in the code nor the Main method. All of that is generated for us by the compiler. Of course, we can add other functions to the Program class and those will be created as the local functions nested inside the generated Main method. Top-level statements are meant to simplify the entry point to the application and remove the extra “fluff” so we can focus on the important stuff instead.

**==“Implicit using directives”==** mean the compiler automatically adds a different set of using directives based on a project type, so we don’t have to do that manually. These using directives are stored in the ==obj/Debug/net8.0== folder of our project under the name ==CompanyEmployees.GlobalUsings.g.c==s:


```C#
// <auto-generated/> 
global using global::Microsoft.AspNetCore.Builder;
global using global::Microsoft.AspNetCore.Hosting; global using global::Microsoft.AspNetCore.Http;
global using global::Microsoft.AspNetCore.Routing; 
global using global::Microsoft.Extensions.Configuration;
global using global::Microsoft.Extensions.DependencyInjection; 
global using global::Microsoft.Extensions.Hosting; 
global using global::Microsoft.Extensions.Logging;
global using global::System;
global using global::System.Collections.Generic; 
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Net.Http.Json; 
global using global::System.Threading; 
global using global::System.Threading.Tasks;

```

This means that we can use different classes from these namespaces in our project without adding using directives explicitly in our project files. Of course, if you don’t want this type of behavior, you can turn it off by visiting the project file and disabling the ImplicitUsings tag: `<ImplicitUsings>disable</ImplicitUsings>`

Program.cs
```C#
var builder = WebApplication.CreateBuilder(args);
```

The application creates a builder variable of the type WebApplicationBuilder. The WebApplicationBuilder class is responsible for four main things:
1 Adding Configuration to the project by using the builder.Configuration property
2 Registering services in our app with the builder.Services property
3 Logging configuration with the builder.Logging property
4  Other IHostBuilder and IWebHostBuilder configuration
Compared to .NET 5 where we had a static CreateDefaultBuilder class, which returned the IHostBuilder type, now we have the static CreateBuilder method, which returns the WebApplicationBuilder type.![[DotNet/WebAPIProject/images/image_4.png]]
ourselves, we can structure the code into logical blocks and separate those blocks into extension methods.


###  Extension methods.

An extension method is inherently a static method. What makes it different from other static methods is that it accepts this as the first parameter, and this represents the data type of the object which will be using that extension method. We’ll see what that means in a moment.
An extension method must be defined inside a static class. This kind of method extends the behavior of a type in .NET. Once we define an extension method, it can be chained multiple times on the same type of object.
So, let’s start writing some code to see how it all adds up.
We are going to create a new folder Extensions in the project and create a new class inside that folder named ServiceExtensions. The ServiceExtensions class should be static:



```C#
public static class ServiceExtensions {
}
```

The first thing we are going to do is to configure CORS in our application. CORS (Cross-Origin Resource Sharing) is a mechanism to give or restrict access rights to applications from different domains.

we want to send requests from a different domain to our application, configuring CORS is mandatory. So, to start, we’ll add a code that allows all requests from all origins to be sent to our API:

```c#
namespace CompanyEmployees.Extensions
{
    public static class ServiceExtensions
    {
        public static void ConfigureCors(this IServiceCollection services)
        {
            services.AddCors( options =>
            {
                options.AddPolicy("CorsPolicy",
                    builder =>
                        builder.AllowAnyOrigin()
                        .AllowAnyMethod()
                        .AllowAnyHeader());
            });
        }
    }
}
```

Instead of the AllowAnyOrigin() method which allows requests from any source, we can use the WithOrigins("https://example.com") which will allow requests only from that concrete source. Also, instead of AllowAnyMethod() that allows all HTTP methods, we can use WithMethods("POST", "GET") that will allow only specific HTTP methods. Furthermore, you can make the same changes for the AllowAnyHeader() method by using, for example, the WithHeaders("accept", "content-type") method to allow only specific headers.

### IIS Configuration 

ASP.NET Core applications are by default self-hosted, and if we want to host our application on IIS, we need to configure an IIS integration which will eventually help us with the deployment to IIS. To do that, we need to add the following code to the ServiceExtensions class:

```c#
  public static void ConfigureIISIntegration(this IServiceCollection services) => services.Configure<IISOptions>(options => { });
```
Program.cs
``` c#
using CompanyEmployees.Extensions; 
var builder = WebApplication.CreateBuilder(args); builder.Services.ConfigureCors();
builder.Services.ConfigureIISIntegration();
builder.Services.AddControllers();
var app = builder.Build();
/*And let's add a few mandatory methods to the second part of the Program class (the one for the request pipeline configuration): */

var app = builder.Build(); 
if (app.Environment.IsDevelopment()) app.UseDeveloperExceptionPage();
else app.UseHsts();
app.UseHttpsRedirection(); 
app.UseStaticFiles();
app.UseForwardedHeaders(new ForwardedHeadersOptions { ForwardedHeaders = ForwardedHeaders.All });
app.UseCors("CorsPolicy"); app.UseAuthorization(); 
app.MapControllers();
app.Run();
```

configuration. Let’s go through those and learn what they do. 
1. app.UseForwardedHeaders() will forward proxy headers to the current request.
 This will help us during application deployment. Pay attention that we require 
 2. Microsoft.AspNetCore.HttpOverrides using directive to introduce the ForwardedHeaders enumeration 
 3. app.UseStaticFiles() enables using static files for the request. If we don’t set a path to the static files directory, it will use a wwwroot folder in our project by default.
 4.  app.UseHsts() will add middleware for using HSTS, which adds the Strict-Transport-Security header.


AddControllers() method. This method registers only the controllers in ==IServiceCollection== and not Views or Pages because they are not required in the Web API project which we are building.
Right below the controller registration, we have this line of code


## Environment-Based  Settings


While we develop our application, we use the “development” environment. But as soon as we publish our application, it goes to the “production” environment. Development and production environments should have different URLs, ports, connection strings, passwords, and other sensitive information.
Therefore, we need to have a separate configuration for each environment and that’s easy to accomplish by using .NET Core-provided mechanisms.
As soon as we create a project, we are going to see the ==appsettings.json== file in the root, which is our main settings file, and when we expand it we are going to see the ==appsetings.Development.json== file by default. These files are separate on the file system, but Visual Studio makes it obvious that they are connected somehow:

![[DotNet/WebAPIProject/images/image_5.png]]

## Middleware 
middleware code to modify the application’s pipeline (CORS, Authorization...), and we are going to use the middleware throughout the rest of the book, we should be more familiar with the ASP.NET Core middleware.

ASP.NET Core middleware is a piece of code integrated inside the application’s pipeline that we can use to handle requests and responses. When we talk about the ASP.NET Core middleware, we can think of it as a code section that executes with every request.
Usually, we have more than a single middleware component in our application. Each component can:
1.  Pass the request to the next middleware component in the pipeline and also
2. It can execute some work before and after the next component in the pipeline

To build a pipeline, we are using request delegates, which handle each HTTP request. To configure request delegates, we use the Run, Map, and Use extension methods. Inside the request pipeline, an application executes each component in the same order they are placed in the code – top to bottom:

![[DotNet/WebAPIProject/images/image_6.png]]
![[DotNet/WebAPIProject/images/image_7.png]]
As we can see, we should register the exception handler in the early stage of the pipeline flow so it could catch all the exceptions that can happen in the later stages of the pipeline. When we create a new ASP.NET Core app, many of the middleware components are already registered in the order

from the diagram. We have to pay attention when registering additional existing components or the custom ones to fit this recommendation.

## Creating a First Middleware Component







## Create a Required Project 
Let’s create two new projects. In the first one named Contracts, we are going to keep our interfaces. We will use this project later on too, to define our contracts for the whole application. The second one, LoggerService, we are going to use to write our logger logic in.
To create a new project, right-click on the solution window, choose Add, and then NewProject. Choose the Class Library (C#) project template:

![[image_8.png]]

## Creating ILoggerInterface and install NLog 

Our logger service will contain four methods for logging our messages:
1 Info messages
2 Debug messages
3 Warning messages
4 Error messages
To achieve this, we are going to create an interface named ILoggerManager inside the Contracts project containing those four method definitions.

```C#
public interface ILoggerManager { 
void LogInfo(string message);
void LogWarn(string message); 
void LogDebug(string message);
void LogError(string message); 
}
```

Before we implement this interface inside the LoggerService project, we need to install the NLog library in our LoggerService project. NLog is a logging platform for .NET which will help us create and log our messages. We are going to show two different ways of adding the NLog library to our project.

![[DotNet/WebAPIProject/images/image_9.png]]

## Implementing the interface and Nlog configFile
In the LoggerService project, we are going to create a new class: LoggerManager. We can do that by repeating the same steps for the interface creation just choosing the class option instead of an interface. Now let’s have it implement the ILoggerManager interface.

```C#
using Contracts;
using NLog;

namespace CompanyEmployees.Services
{
    public class LoggerManager : ILoggerManager
    {

        private static NLog.ILogger _logger = LogManager.GetCurrentClassLogger();
        public LoggerManager() { }
        public void LogDebug(string message)
        {
            _logger.Debug(message);
        }

        public void LogError(string message)
        {
            _logger.Error(message);
        }

        public void LogInfo(string message)
        {
          _logger.Info(message);
        }

        public void LogWarn(string message)
        {
            _logger.Warn(message);
        }
    }
}

```

our methods are just wrappers around NLog’s methods. Both ILogger and LogManager are part of the NLog namespace. Now, we need to configure it and inject it into the Program class in the section related to the service configuration.

NLog needs to have information about where to put log files on the file system, what the name of these files will be, and what is the minimum level of logging that we want.

We are going to define all these constants in a text file in the main project and name it nlog.config. So, let’s right-click on the main project, choose Add -> New Item, and then search for the Text File. Select the Text File, and add the name nlog.config.

```xml
<?xml version="1.0" encoding="utf-8" ?>
<nlog xmlns="http://www.nlog-project.org/schemas/NLog.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" autoReload="true" internalLogLevel="Trace"
	  internalLogFile=".\internal_logs\internallog.txt">
	<targets>
		<target name="logfile" xsi:type="File" fileName=".\logs\${shortdate}_logfile.txt" layout="${longdate} ${level:uppercase=true} ${message}"/>
	</targets>
	<rules>
		<logger name="*" minlevel="Debug" writeTo="logfile" />
	</rules>
</nlog>
```
You can find the internal logs at the project root, and the logs folder in the bin\debug folder of the main project once we start the app. Once the application is published both folders will be created at the root of the output folder which is what we want.


## Configuration Logger Service for Logging Message 
Setting up the configuration for a logger service is quite easy. First, we need to update the Program class and include the path to the configuration file for the NLog configuration:

```C#
using NLog; 
var builder = WebApplication.CreateBuilder(args); LogManager.Setup().LoadConfigurationFromFile(string.Concat(Directory.GetCurrentDirectory(), "/nlog.config")); 

```

We are using NLog’s LogManager static class with the LoadConfigurationFromFile method to provide a path to the configuration file.


The next thing we need to do is to add the logger service inside the .NET Core’s IOC container. There are three ways to do that:

1 By calling the services.AddSingleton method, we can create a service the first time we request it and then every subsequent request will call the same instance of the service. This means that all components share the same service every time they need it and the same instance will be used for every method call. 
2  By calling the services.AddScoped method, we can create a service once per request. That means whenever we send an HTTP request to the application, a new instance of the service will be created. 
3 By calling the services.AddTransient method, we can create a service each time the application requests it. This means that if multiple components need the service, it will be created again for every single component request.

So, let’s add a new method in the ServiceExtensions class:
```C#
public static void ConfigureLoggerService(this IServiceCollection services) => services.AddSingleton<ILoggerManager, LoggerManager>();
```

Program.cs

```C#
builder.Services.ConfigureLoggerService();
```

Every time we want to use a logger service, all we need to do is to inject it into the constructor of the class that needs it. .NET Core will resolve that service and the logging features will be available. This type of injecting a class is called Dependency Injection and it is built into .NET Core.

```C#
namespace CompanyEmployees.Controllers
{
    [ApiController]
    [Route("[controller]")]
    public class WeatherForecastController : ControllerBase
    {   
        private readonly ILoggerManager _logger;

        public WeatherForecastController(ILoggerManager logger)
        {
            _logger = logger;
        }

        [HttpGet("/TestLog")]
        public IEnumerable<string> TestLog()
        {
            _logger.LogInfo("Here is info message from our values controller."); 
            _logger.LogDebug("Here is debug message from our values controller.");
            _logger.LogWarn("Here is warn message from our values controller."); 
            _logger.LogError("Here is an error message from our values controller.");

             return new string[] { "value1", "value2" };
        }
        }
        }
```

Now let’s start the application and browse to https://localhost:5001/weatherforecast. As a result, you will see an array of two strings. Now go to the folder that you have specified in the nlog.config file, and check out the result. You should see two folders: the internal_logs folder and the logs folder. Inside the logs folder, you should find a file with the following logs:

