
### 1. **Basic Setup**

First, you need to install Dapper via NuGet:

```cmd
Install-Package Dapper

```

Next, ensure that you have a database connection, usually through `IDbConnection` (e.g., `SqlConnection` for SQL Server).

```c#
using Dapper;
using System.Data.SqlClient;

var connectionString = "YourConnectionString";
using (var connection = new SqlConnection(connectionString))
{
    connection.Open();
    // Execute queries here
}

```


### 2. **Basic Query Execution**

- **Fetching a Single Record**: To execute a query that fetches a single row and maps it to a C# object, you can use `QuerySingle` or `QueryFirst`.
```c#
using (var connection = new SqlConnection(connectionString))
{
    string sql = "SELECT * FROM Users WHERE Id = @Id";
    var user = connection.QuerySingle<User>(sql, new { Id = 1 });
}

```

Here, `QuerySingle<T>` will throw an exception if no row is returned, while `QueryFirst<T>` returns the first row (or null if none).

**Fetching Multiple Records**: To fetch multiple records, use `Query<T>`:

```c#
using (var connection = new SqlConnection(connectionString))
{
    string sql = "SELECT * FROM Users";
    var users = connection.Query<User>(sql).ToList();
}

```

### 3. **Parameterized Queries**

Dapper supports parameterized queries, preventing SQL injection and improving performance by reusing query execution plans:

```c#
string sql = "SELECT * FROM Users WHERE Age > @Age";
var users = connection.Query<User>(sql, new { Age = 30 });

```

### 4. **Executing Insert, Update, and Delete**

For non-query operations like insert, update, and delete, use `Execute`:

```c#
string insertSql = "INSERT INTO Users (Name, Age) VALUES (@Name, @Age)";
int rowsAffected = connection.Execute(insertSql, new { Name = "John", Age = 25 });

```

```c#
string updateSql = "UPDATE Users SET Age = @Age WHERE Id = @Id";
int rowsAffected = connection.Execute(updateSql, new { Age = 26, Id = 1 });

```

```c#
string deleteSql = "DELETE FROM Users WHERE Id = @Id";
int rowsAffected = connection.Execute(deleteSql, new { Id = 1 });

```

### 5. **Advanced Querying**

#### **Multi-Mapping (JOIN Queries)**

Dapper can handle complex result sets, such as when you're performing a SQL `JOIN` between tables.

Example: Joining `Users` and `Orders` tables:

```c#
string sql = @"SELECT * FROM Users u 
               INNER JOIN Orders o ON u.Id = o.UserId 
               WHERE u.Id = @Id";

var userWithOrders = connection.Query<User, Order, User>(
    sql,
    (user, order) => { user.Orders.Add(order); return user; },
    new { Id = 1 }, splitOn: "UserId"
);

// second 

var sql = @"SELECT u.*, p.* FROM Users u 
            INNER JOIN Profiles p ON u.Id = p.UserId
            WHERE u.Id = @Id";

var user = connection.Query<User, Profile, User>(sql, (user, profile) =>
{
    user.Profile = profile;
    return user;
}, new { Id = 1 }).FirstOrDefault();

```

#### **Multiple Result Sets**

Dapper can also handle multiple result sets returned from a single stored procedure or query:

```c#
string sql = "SELECT * FROM Users; SELECT * FROM Orders";
using (var multi = connection.QueryMultiple(sql))
{
    var users = multi.Read<User>().ToList();
    var orders = multi.Read<Order>().ToList();
}

```
#### **Stored Procedures**

Dapper has seamless support for calling stored procedures:

```c#
using (var connection = new SqlConnection(connectionString))
{
    var users = connection.Query<User>(
        "GetUsers", 
        new { Active = true }, 
        commandType: CommandType.StoredProcedure
    ).ToList();
}

```

### 6. **Handling Transactions**

You can execute queries within a transaction:

```c#
using (var connection = new SqlConnection(connectionString))
{
    connection.Open();
    using (var transaction = connection.BeginTransaction())
    {
        try
        {
            connection.Execute("UPDATE Users SET Age = 30 WHERE Id = 1", transaction: transaction);
            transaction.Commit();
        }
        catch
        {
            transaction.Rollback();
        }
    }
}


// second 


```

### 7. **Bulk Inserts**

For scenarios requiring bulk inserts, Dapper doesn’t offer direct bulk insert capabilities, but you can achieve it by batching `Execute` calls or using SQL `BulkInsert` functionality outside of Dapper.

```c#
var users = new List<User> { new User { Name = "Alice" }, new User { Name = "Bob" } };
string insertSql = "INSERT INTO Users (Name) VALUES (@Name)";
connection.Execute(insertSql, users);

```

### 8. **Performance Considerations**

Dapper is highly performant because it directly maps the result set to objects with minimal overhead. For large datasets, it’s best to use streaming to avoid loading everything into memory:

```c#
var reader = connection.ExecuteReader("SELECT * FROM Users");
while (reader.Read())
{
    // Process each row
}

```

### 10. **Caching Results**

To enhance performance, especially with frequent database reads, Dapper can be combined with caching mechanisms such as **MemoryCache** or **Redis**.

```c#
private static MemoryCache _cache = new MemoryCache(new MemoryCacheOptions());

var cacheKey = "GetAllUsers";
if (!_cache.TryGetValue(cacheKey, out List<User> users))
{
    var sql = "SELECT * FROM Users";
    users = connection.Query<User>(sql).ToList();

    _cache.Set(cacheKey, users, TimeSpan.FromMinutes(10));
}

```

### 11. **Async Queries**

Dapper has full support for asynchronous operations:

```c#
var sql = "SELECT * FROM Users WHERE Id = @Id";
var user = await connection.QueryFirstOrDefaultAsync<User>(sql, new { Id = 1 });

```

