
Angular 19 is the latest version of the Angular framework as of its release on November 19, 2024. In Angular 19, all components, directives, and pipes are standalone by default, simplifying development by reducing the need for NgModules. Below, I’ll provide a full list of Angular decorators, describe each one, and include a real-life example of a standalone component in Bangla.[](https://www.bacancytechnology.com/blog/whats-new-in-angular-19)

### Full List of Angular Decorators

Angular decorators are TypeScript functions that add metadata or modify the behavior of classes, methods, properties, or parameters. They are prefixed with the `@` symbol and are crucial for defining Angular artifacts like components, services, and modules. The following is a comprehensive list of Angular decorators, categorized by type, with their descriptions.[](https://www.fynd.academy/blog/decorators-in-angular)

#### 1. Class Decorators
These decorators define the purpose of a class, such as marking it as a component, module, or service.

- **@Component**
  - **Description**: Marks a class as an Angular component and provides metadata like selector, template, styles, and more. In Angular 19, components are standalone by default, meaning they can be imported directly without NgModules.[](https://angular.dev/api/core/Component)[](https://www.bacancytechnology.com/blog/whats-new-in-angular-19)
  - **Purpose**: Defines a component’s structure, behavior, and rendering logic, enabling Angular to instantiate and render it in the DOM.
  - **Metadata**:
    - `selector`: The CSS selector to use the component in templates.
    - `template` or `templateUrl`: The HTML content or file for the component’s view.
    - `styles` or `styleUrls`: CSS styles for the component.
    - `standalone`: Defaults to `true` in Angular 19.
    - `imports`: Specifies dependencies (other standalone components, directives, or pipes).
    - Others: `changeDetection`, `encapsulation`, `animations`, etc.

- **@NgModule**
  - **Description**: Defines a module that organizes components, directives, pipes, and services. While less common in Angular 19 due to standalone components, it’s still used for legacy or complex applications.[](https://www.tektutorialshub.com/angular/angular-decorators/)
  - **Purpose**: Groups related features and provides a context for dependency injection.
  - **Metadata**:
    - `declarations`: Components, directives, and pipes in the module.
    - `imports`: Other modules or standalone components.
    - `providers`: Services available in the module.
    - `bootstrap`: The root component for bootstrapping.

- **@Directive**
  - **Description**: Marks a class as an Angular directive, allowing custom behavior to be attached to DOM elements.[](https://www.fynd.academy/blog/decorators-in-angular)
  - **Purpose**: Modifies the appearance, behavior, or structure of DOM elements.
  - **Metadata**:
    - `selector`: CSS selector to apply the directive.
    - `standalone`: Defaults to `true` in Angular 19.
    - `inputs` and `outputs`: For binding properties and events.

- **@Pipe**
  - **Description**: Defines a class as an Angular pipe for transforming data in templates.[](https://www.fynd.academy/blog/decorators-in-angular)
  - **Purpose**: Formats or transforms data for display (e.g., converting a date to a specific format).
  - **Metadata**:
    - `name`: The pipe’s name used in templates.
    - `standalone`: Defaults to `true` in Angular 19.
    - `pure`: Whether the pipe is pure (recalculates only when inputs change).

- **@Injectable**
  - **Description**: Marks a class as a service that can be injected into other components or services via Angular’s dependency injection system.[](https://www.fynd.academy/blog/decorators-in-angular)
  - **Purpose**: Enables dependency injection for reusable services.
  - **Metadata**:
    - `providedIn`: Specifies the scope (e.g., `'root'` for singleton services).

#### 2. Property Decorators
These modify class properties, often for data binding or querying DOM elements.

- **@Input**
  - **Description**: Marks a property as an input, allowing data to be passed from a parent component to a child component.[](https://www.geeksforgeeks.org/what-are-decorators-in-angular/)
  - **Purpose**: Facilitates parent-to-child communication via property binding.
  - **Usage**: Binds a property to a value in the parent’s template.

- **@Output**
  - **Description**: Marks a property as an output, typically an `EventEmitter`, to emit events from a child to a parent component.[](https://www.geeksforgeeks.org/what-are-decorators-in-angular/)
  - **Purpose**: Enables child-to-parent communication via events.

- **@ViewChild**
  - **Description**: Queries a single element or directive in the component’s view and binds it to a property. Not available for directives.[](https://medium.com/%40madhavmahesh/list-of-all-decorators-available-in-angular-71bdf4ad6976)
  - **Purpose**: Accesses a specific child component or DOM element in the template.
  - **Usage**: Takes a selector (e.g., component class or template reference) and options like `{ static: true }`.

- **@ViewChildren**
  - **Description**: Queries multiple elements or directives in the component’s view and binds them to a `QueryList`.[](https://medium.com/%40madhavmahesh/list-of-all-decorators-available-in-angular-71bdf4ad6976)
  - **Purpose**: Retrieves a list of matching elements or components.
  - **Usage**: Similar to `@ViewChild` but returns a `QueryList`.

- **@ContentChild**
  - **Description**: Queries a single element or directive in the component’s content (projected via `<ng-content>`) and binds it to a property.[](https://medium.com/%40madhavmahesh/list-of-all-decorators-available-in-angular-71bdf4ad6976)
  - **Purpose**: Accesses content projected into the component.
  - **Usage**: Takes a selector and options like `@ViewChild`.

- **@ContentChildren**
  - **Description**: Queries multiple elements or directives in the component’s content and binds them to a `QueryList`.[](https://medium.com/%40madhavmahesh/list-of-all-decorators-available-in-angular-71bdf4ad6976)
  - **Purpose**: Retrieves a list of projected elements or components.

- **@HostBinding**
  - **Description**: Binds a host element’s property (e.g., a CSS class or attribute) to a directive/component property.[](https://medium.com/%40madhavmahesh/list-of-all-decorators-available-in-angular-71bdf4ad6976)
  - **Purpose**: Dynamically modifies the host element’s properties.
  - **Usage**: Specifies the host property to bind (e.g., `class.active`).

#### 3. Method Decorators
These modify class methods, often for event handling.

- **@HostListener**
  - **Description**: Subscribes to a host element’s event (e.g., `click`, `mouseover`) and binds it to a method.[](https://medium.com/%40madhavmahesh/list-of-all-decorators-available-in-angular-71bdf4ad6976)
  - **Purpose**: Handles DOM events directly in the component or directive.
  - **Usage**: Specifies the event name and optional arguments (e.g., `$event`).

#### 4. Parameter Decorators
These provide metadata for constructor parameters.

- **@Inject**
  - **Description**: Specifies a dependency to be injected into a constructor.[](https://www.geeksforgeeks.org/what-are-decorators-in-angular/)
  - **Purpose**: Explicitly defines dependencies for dependency injection.
  - **Usage**: Used with tokens to identify dependencies.

- **@Optional**
  - **Description**: Marks a constructor parameter as optional, so Angular doesn’t throw an error if the dependency is missing.
  - **Purpose**: Allows flexible dependency injection.

- **@Self**
  - **Description**: Restricts dependency injection to the component’s own injector.
  - **Purpose**: Ensures the dependency is provided locally.

- **@SkipSelf**
  - **Description**: Skips the component’s injector and looks for the dependency in parent injectors.
  - **Purpose**: Resolves dependencies from higher in the injector hierarchy.

- **@Host**
  - **Description**: Restricts dependency injection to the host element’s injector.
  - **Purpose**: Limits dependency resolution to the host context.

### Real-Life Example: Standalone Component in Bangla

Let’s create a standalone Angular 19 component for a simple **To-Do List** application, explained in Bangla. This example demonstrates `@Component`, `@Input`, `@Output`, and `@HostListener` in a standalone component. The component allows users to add tasks and mark them as completed.

#### Scenario
একটি টু-ডু লিস্ট অ্যাপ তৈরি করা হবে যেখানে ব্যবহারকারী নতুন কাজ যোগ করতে পারবে এবং কাজ সম্পন্ন হিসেবে চিহ্নিত করতে পারবে। এই উদাহরণে আমরা একটি স্ট্যান্ডএলোন কম্পোনেন্ট ব্যবহার করব, যা Angular 19-এ ডিফল্ট।

#### Code Example
**File: todo.component.ts**

```typescript
import { Component, Input, Output, EventEmitter, HostListener } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';

@Component({
  selector: 'app-todo',
  standalone: true, // Angular 19-এ ডিফল্ট
  imports: [CommonModule, FormsModule], // প্রয়োজনীয় মডিউল ইমপোর্ট
  template: `
    <div class="todo-container">
      <h2>{{ title }}</h2>
      <input [(ngModel)]="newTask" placeholder="নতুন কাজ যোগ করুন" />
      <button (click)="addTask()">কাজ যোগ করুন</button>
      <ul>
        <li *ngFor="let task of tasks" [class.completed]="task.completed" (click)="toggleTask(task)">
          {{ task.name }}
        </li>
      </ul>
    </div>
  `,
  styles: [`
    .todo-container { padding: 20px; font-family: Arial; }
    .completed { text-decoration: line-through; color: green; }
    button { margin-left: 10px; }
    li { cursor: pointer; }
  `]
})
export class TodoComponent {
  @Input() title: string = 'টু-ডু লিস্ট'; // প্যারেন্ট থেকে টাইটেল গ্রহণ
  @Output() taskAdded = new EventEmitter<string>(); // নতুন কাজ যোগের ইভেন্ট
  tasks: { name: string, completed: boolean }[] = [];
  newTask: string = '';

  addTask() {
    if (this.newTask.trim()) {
      this.tasks.push({ name: this.newTask, completed: false });
      this.taskAdded.emit(this.newTask); // প্যারেন্টে ইভেন্ট পাঠানো
      this.newTask = '';
    }
  }

  @HostListener('document:keydown.enter')
  onEnterKey() {
    this.addTask(); // এন্টার কী চাপলে কাজ যোগ হবে
  }

  toggleTask(task: { name: string, completed: boolean }) {
    task.completed = !task.completed; // কাজের স্ট্যাটাস টগল করা
  }
}
```

**File: app.component.ts** (Root Component)

```typescript
import { Component } from '@angular/core';
import { TodoComponent } from './todo.component';

@Component({
  selector: 'app-root',
  standalone: true,
  imports: [TodoComponent],
  template: `
    <app-todo title="আমার কাজের তালিকা" (taskAdded)="onTaskAdded($event)" />
    <p>সর্বশেষ যোগ করা কাজ: {{ lastTask }}</p>
  `
})
export class AppComponent {
  lastTask: string = '';

  onTaskAdded(task: string) {
    this.lastTask = task; // নতুন কাজ রেকর্ড করা
  }
}
```

**File: main.ts**

```typescript
import { bootstrapApplication } from '@angular/platform-browser';
import { AppComponent } from './app/app.component';

bootstrapApplication(AppComponent);
```

#### Explanation in Bangla
- **@Component**: এই ডেকোরেটরটি `TodoComponent` ক্লাসকে একটি Angular কম্পোনেন্ট হিসেবে চিহ্নিত করে। এটি `selector`, `template`, এবং `styles` নির্দিষ্ট করে। Angular 19-এ `standalone: true` ডিফল্ট, তাই আমাদের এটি লিখতে হয়নি। আমরা `CommonModule` এবং `FormsModule` ইমপোর্ট করেছি কারণ আমরা `*ngFor` এবং `ngModel` ব্যবহার করছি।
- **@Input**: `title` প্রপার্টি প্যারেন্ট কম্পোনেন্ট থেকে ডেটা গ্রহণ করে। এখানে, `AppComponent` থেকে "আমার কাজের তালিকা" টাইটেল পাঠানো হয়েছে।
- **@Output**: `taskAdded` একটি ইভেন্ট এমিটার, যা নতুন কাজ যোগ হলে প্যারেন্ট কম্পোনেন্টকে জানায়। `AppComponent` এই ইভেন্ট গ্রহণ করে এবং সর্বশেষ কাজ প্রদর্শন করে।
- **@HostListener**: এন্টার কী চাপলে `addTask()` মেথড কল হয়, যা ব্যবহারকারীকে কীবোর্ড দিয়ে কাজ যোগ করতে দেয়।
- **Standalone Component**: `TodoComponent` একটি স্ট্যান্ডএলোন কম্পোনেন্ট, তাই এটি সরাসরি `AppComponent`-এ ইমপোর্ট করা হয়েছে। কোনো `NgModule` প্রয়োজন হয়নি।

#### Real-Life Use Case
এই টু-ডু লিস্ট অ্যাপটি একটি সাধারণ প্রজেক্ট ম্যানেজমেন্ট টুল হিসেবে ব্যবহার করা যেতে পারে। উদাহরণস্বরূপ, একজন ফ্রিল্যান্সার তাদের ক্লায়েন্টের কাজের তালিকা ট্র্যাক করতে এটি ব্যবহার করতে পারেন। প্যারেন্ট কম্পোনেন্টে কাজগুলোর স্ট্যাটাস সংরক্ষণ করা যায় এবং ডাটাবেসে সেভ করা যায়।

#### Running the Application
1. **প্রজেক্ট তৈরি**: `ng new todo-app --standalone` কমান্ড দিয়ে একটি নতুন Angular 19 প্রজেক্ট তৈরি করুন।
2. **ফাইল তৈরি**: উপরের কোডগুলো `todo.component.ts`, `app.component.ts`, এবং `main.ts` ফাইলে রাখুন।
3. **অ্যাপ চালানো**: `ng serve` কমান্ড দিয়ে অ্যাপ চালান। ব্রাউজারে `http://localhost:4200` এ অ্যাপটি দেখা যাবে।
4. **ফলাফল**: ব্যবহারকারী একটি ইনপুট ফিল্ডে কাজ যোগ করতে পারবেন, এন্টার কী চাপলে বা বাটনে ক্লিক করলে কাজ লিস্টে যুক্ত হবে। কাজে ক্লিক করলে তা সম্পন্ন হিসেবে চিহ্নিত হবে।

### Notes
- **Angular 19 Features**: The example leverages Angular 19’s default standalone components and simplified structure, reducing boilerplate code.[](https://www.bacancytechnology.com/blog/whats-new-in-angular-19)
- **Migration**: If upgrading from older versions, use `ng update` to handle standalone component migrations and remove redundant `standalone: true` declarations.[](https://stackoverflow.com/questions/79199579/angular-19-component-appcomponent-is-standalone-and-cannot-be-declared-in-an)
- **Unused Imports**: Angular 19’s compiler detects unused imports in standalone components, ensuring clean code.[](https://blog.ninja-squad.com/2024/11/19/what-is-new-angular-19.0/)
- **Language Limitation**: Since the request asked for explanations in Bangla, I’ve provided them accordingly. For further details or additional decorators, let me know!

If you need more examples or clarification in Bangla, feel free to ask![](https://www.bacancytechnology.com/blog/whats-new-in-angular-19)