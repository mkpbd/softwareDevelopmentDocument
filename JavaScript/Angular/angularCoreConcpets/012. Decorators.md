
Okay, let's clarify something important first: **As of my last update (early 2024), Angular 19 has not been released.** The latest stable major version is Angular 17, with Angular 18 in active development/pre-release.

The core decorators in Angular are very stable and have been around for many versions. It's highly unlikely they will change drastically or that many new *core* decorators will be introduced by Angular 19. The list I provide will be based on the latest available Angular version (v17/v18), and these will almost certainly be the same for Angular 19 when it's released.

We will focus on **standalone components** for the examples, as this is the modern and recommended approach in Angular.

Here's a comprehensive list of Angular decorators, their descriptions, and real-life examples using standalone components:

---

**Important Note on Standalone Components:**
With standalone components, directives, and pipes, you explicitly declare their dependencies (other components, directives, pipes, or NgModules like `CommonModule`) in their `imports` array. Services are typically provided in `root` (`providedIn: 'root'`), in the `providers` array of `bootstrapApplication`, or in the `providers` array of a component/route.

---

### I. Class Decorators

These decorators are applied to classes to tell Angular what type of building block the class represents.

1.  **`@Component(metadata)`**
    *   **Description:** Marks a class as an Angular component and provides configuration metadata that determines how the component should be processed, instantiated, and used at runtime.
    *   **Metadata Properties (common ones for standalone):**
        *   `selector`: CSS selector that identifies this component in a template.
        *   `standalone: true`: Declares the component as standalone.
        *   `template` or `templateUrl`: Inline template or path to an external template file.
        *   `styleUrls` or `styles`: Array of URLs to external style files or inline styles.
        *   `imports`: Array of other standalone components, directives, pipes, or NgModules needed by this component's template.
        *   `providers`: Array of providers for services that this component and its children can inject.
        *   `changeDetection`: Strategy for change detection (e.g., `ChangeDetectionStrategy.OnPush`).
        *   `viewProviders`: Similar to `providers` but services are only available to the component's view, not content children.
        *   `schemas`: Defines a schema for the component's template (e.g., `CUSTOM_ELEMENTS_SCHEMA`).
    *   **Real-life Example:** A user profile card.
        ```typescript
        // user-profile.component.ts
        import { Component, Input } from '@angular/core';
        import { CommonModule } from '@angular/common'; // For *ngIf, etc.

        @Component({
          selector: 'app-user-profile',
          standalone: true,
          imports: [CommonModule], // Import CommonModule for *ngIf
          template: `
            <div class="profile-card" *ngIf="user">
              <h2>{{ user.name }}</h2>
              <p>Email: {{ user.email }}</p>
              <p *ngIf="user.bio">Bio: {{ user.bio }}</p>
            </div>
            <p *ngIf="!user">No user data provided.</p>
          `,
          styles: [`
            .profile-card {
              border: 1px solid #ccc;
              padding: 15px;
              border-radius: 8px;
              box-shadow: 2px 2px 5px rgba(0,0,0,0.1);
            }
          `]
        })
        export class UserProfileComponent {
          @Input() user: { name: string; email: string; bio?: string } | null = null;
        }

        // Usage in another standalone component (e.g., app.component.ts)
        // @Component({
        //   selector: 'app-root',
        //   standalone: true,
        //   imports: [UserProfileComponent], // Import the standalone component
        //   template: '<app-user-profile [user]="currentUser"></app-user-profile>'
        // })
        // export class AppComponent {
        //   currentUser = { name: 'Alice Wonderland', email: 'alice@example.com', bio: 'Curious explorer' };
        // }
        ```

2.  **`@Directive(metadata)`**
    *   **Description:** Marks a class as an Angular directive. Directives are used to attach custom behavior to elements in the DOM.
    *   **Metadata Properties (common ones for standalone):**
        *   `selector`: CSS selector that identifies this directive.
        *   `standalone: true`: Declares the directive as standalone.
        *   `providers`: For services specific to this directive.
        *   `host`: A map of class property to host element property bindings (less common now, prefer `@HostBinding` and `@HostListener`).
    *   **Real-life Example:** A directive to highlight an element on mouse hover.
        ```typescript
        // highlight.directive.ts
        import { Directive, ElementRef, HostListener, Input, Renderer2 } from '@angular/core';

        @Directive({
          selector: '[appHighlight]',
          standalone: true,
        })
        export class HighlightDirective {
          @Input('appHighlight') highlightColor: string = 'yellow'; // Alias for clarity
          private originalColor: string = '';

          constructor(private el: ElementRef, private renderer: Renderer2) {}

          @HostListener('mouseenter') onMouseEnter() {
            this.originalColor = this.el.nativeElement.style.backgroundColor;
            this.renderer.setStyle(this.el.nativeElement, 'backgroundColor', this.highlightColor);
            this.renderer.setStyle(this.el.nativeElement, 'transition', 'background-color 0.3s ease');
          }

          @HostListener('mouseleave') onMouseLeave() {
            this.renderer.setStyle(this.el.nativeElement, 'backgroundColor', this.originalColor);
          }
        }

        // Usage in a standalone component's template:
        // @Component({
        //   selector: 'app-demo',
        //   standalone: true,
        //   imports: [HighlightDirective], // Import the standalone directive
        //   template: `
        //     <p appHighlight="lightblue">Hover over me for a light blue highlight!</p>
        //     <div [appHighlight]="'#FFDDC1'">Hover over me for a custom color highlight!</div>
        //   `
        // })
        // export class DemoComponent {}
        ```

3.  **`@Pipe(metadata)`**
    *   **Description:** Marks a class as an Angular pipe, which transforms input data to a desired output for display in a template.
    *   **Metadata Properties (common ones for standalone):**
        *   `name`: The name of the pipe to be used in templates.
        *   `standalone: true`: Declares the pipe as standalone.
        *   `pure`: (Optional, default `true`) If true, the pipe is only re-evaluated when its input arguments change. If false, it's re-evaluated on every change detection cycle.
    *   **Real-life Example:** A pipe to truncate text to a certain length.
        ```typescript
        // truncate.pipe.ts
        import { Pipe, PipeTransform } from '@angular/core';

        @Pipe({
          name: 'truncate',
          standalone: true,
        })
        export class TruncatePipe implements PipeTransform {
          transform(value: string, limit: number = 20, trail: string = '...'): string {
            if (!value) return '';
            return value.length > limit ? value.substring(0, limit) + trail : value;
          }
        }

        // Usage in a standalone component's template:
        // @Component({
        //   selector: 'app-article-summary',
        //   standalone: true,
        //   imports: [TruncatePipe], // Import the standalone pipe
        //   template: `
        //     <h2>{{ articleTitle }}</h2>
        //     <p>{{ longDescription | truncate:50 }}</p>
        //     <p>{{ shortNote | truncate }}</p> <!-- Uses default limit -->
        //   `
        // })
        // export class ArticleSummaryComponent {
        //   articleTitle = "The Wonders of Standalone Components";
        //   longDescription = "This is a very long description of an article that talks about the benefits and usage of standalone components in modern Angular development, which helps reduce boilerplate and improve modularity.";
        //   shortNote = "Angular is great!";
        // }
        ```

4.  **`@Injectable(metadata)`**
    *   **Description:** Marks a class as a service that can be injected with Angular's dependency injection (DI) system.
    *   **Metadata Properties:**
        *   `providedIn`: Specifies where the service should be provided.
            *   `'root'`: The service is provided in the application root injector, making it a singleton available throughout the application. (Recommended for most services).
            *   `'platform'`: A special singleton platform injector shared by all applications on the page.
            *   `'any'`: Provides a unique instance in every lazy-loaded module (and the root) that injects the token.
            *   A specific NgModule (less common with standalone, where services are often `'root'` or provided in components/routes).
    *   **Real-life Example:** A service to fetch user data.
        ```typescript
        // user.service.ts
        import { Injectable } from '@angular/core';
        import { Observable, of, delay } from 'rxjs'; // 'of' for mock data

        export interface User {
          id: number;
          name: string;
          email: string;
        }

        @Injectable({
          providedIn: 'root', // Singleton service available application-wide
        })
        export class UserService {
          private users: User[] = [
            { id: 1, name: 'Alice Smith', email: 'alice@example.com' },
            { id: 2, name: 'Bob Johnson', email: 'bob@example.com' },
          ];

          getUsers(): Observable<User[]> {
            return of(this.users).pipe(delay(500)); // Simulate API call
          }

          getUserById(id: number): Observable<User | undefined> {
            return of(this.users.find(user => user.id === id)).pipe(delay(300));
          }
        }

        // Usage in a standalone component:
        // user-list.component.ts
        // import { Component, OnInit, inject } from '@angular/core';
        // import { CommonModule } from '@angular/common';
        // import { UserService, User } from './user.service'; // Assuming same folder or correct path
        // import { Observable } from 'rxjs';

        // @Component({
        //   selector: 'app-user-list',
        //   standalone: true,
        //   imports: [CommonModule], // For async pipe, *ngFor
        //   template: `
        //     <h2>User List</h2>
        //     <ul *ngIf="users$ | async as users; else loading">
        //       <li *ngFor="let user of users">{{ user.name }} - {{ user.email }}</li>
        //     </ul>
        //     <ng-template #loading>Loading users...</ng-template>
        //   `
        // })
        // export class UserListComponent implements OnInit {
        //   private userService = inject(UserService); // Modern DI with inject()
        //   users$!: Observable<User[]>;

        //   // Or constructor injection:
        //   // constructor(private userService: UserService) {}

        //   ngOnInit(): void {
        //     this.users$ = this.userService.getUsers();
        //   }
        // }
        ```

---

### II. Property Decorators (for Component/Directive class members)

These decorators are applied to properties or methods within a component or directive class.

1.  **`@Input(alias?: string)`**
    *   **Description:** Declares an input property, allowing data to flow from a parent component to this child component/directive. Optionally, an alias can be provided for the property name used in the template.
    *   **New in Angular 16+:** `@Input({ required: true })` makes the input mandatory.
    *   **Real-life Example:** The `user` property in the `UserProfileComponent` example above is an `@Input`. Another:
        ```typescript
        // alert.component.ts
        import { Component, Input } from '@angular/core';
        import { CommonModule } from '@angular/common';

        @Component({
          selector: 'app-alert',
          standalone: true,
          imports: [CommonModule],
          template: `
            <div *ngIf="message" [ngClass]="alertTypeClass">
              <strong>{{ type | uppercase }}:</strong> {{ message }}
            </div>
          `,
          styles: [`
            .alert-success { background-color: #d4edda; color: #155724; padding: 10px; border: 1px solid #c3e6cb; }
            .alert-error { background-color: #f8d7da; color: #721c24; padding: 10px; border: 1px solid #f5c6cb; }
            .alert-info { background-color: #d1ecf1; color: #0c5460; padding: 10px; border: 1px solid #bee5eb; }
          `]
        })
        export class AlertComponent {
          @Input({ required: true }) message!: string; // Required input
          @Input() type: 'success' | 'error' | 'info' = 'info'; // Optional with default

          get alertTypeClass() {
            return {
              'alert-success': this.type === 'success',
              'alert-error': this.type === 'error',
              'alert-info': this.type === 'info',
            };
          }
        }

        // Usage in another standalone component:
        // @Component({
        //   selector: 'app-feedback',
        //   standalone: true,
        //   imports: [AlertComponent],
        //   template: `
        //     <app-alert message="Operation completed successfully!" type="success"></app-alert>
        //     <app-alert [message]="errorMessage" type="error"></app-alert>
        //   `
        // })
        // export class FeedbackComponent {
        //   errorMessage = "Failed to save data.";
        // }
        ```

2.  **`@Output(alias?: string)`**
    *   **Description:** Declares an output property, which must be an instance of `EventEmitter`. It allows the component/directive to emit custom events, enabling data to flow from this child to its parent.
    *   **Real-life Example:** A custom button that emits a click event with a payload.
        ```typescript
        // custom-button.component.ts
        import { Component, Output, EventEmitter, Input } from '@angular/core';

        @Component({
          selector: 'app-custom-button',
          standalone: true,
          template: `
            <button (click)="onClick()">{{ label }}</button>
          `
        })
        export class CustomButtonComponent {
          @Input() label: string = 'Click Me';
          @Input() payload: any = null; // Data to emit with the event

          @Output() customClick = new EventEmitter<any>(); // Emits 'any' type payload

          onClick(): void {
            this.customClick.emit(this.payload || this.label);
          }
        }

        // Usage in a parent standalone component:
        // @Component({
        //   selector: 'app-action-panel',
        //   standalone: true,
        //   imports: [CustomButtonComponent],
        //   template: `
        //     <app-custom-button
        //       label="Submit Form"
        //       payload="{formId: 123}"
        //       (customClick)="handleFormSubmit($event)">
        //     </app-custom-button>
        //     <p>Last action: {{ lastActionInfo }}</p>
        //   `
        // })
        // export class ActionPanelComponent {
        //   lastActionInfo: string = 'None';
        //   handleFormSubmit(data: any): void {
        //     this.lastActionInfo = `Button clicked with payload: ${JSON.stringify(data)}`;
        //     console.log('Form submit triggered with:', data);
        //   }
        // }
        ```

3.  **`@HostBinding(hostPropertyName: string)`**
    *   **Description:** Binds a property of the host element (the element to which the component/directive is attached) to a property of the directive or component. For example, you can bind the `class`, `style`, or an `attribute` of the host element.
    *   **Real-life Example:** A directive that adds an 'active' class to its host element if a certain condition is met.
        ```typescript
        // active-state.directive.ts
        import { Directive, Input, HostBinding } from '@angular/core';

        @Directive({
          selector: '[appActiveState]',
          standalone: true,
        })
        export class ActiveStateDirective {
          @Input('appActiveState') isActive: boolean = false;

          @HostBinding('class.active-styling')
          get appliedClass() {
            return this.isActive;
          }

          @HostBinding('style.border')
          get borderStyle() {
            return this.isActive ? '2px solid green' : '1px solid #ccc';
          }

          @HostBinding('attr.aria-pressed')
          get ariaPressedAttribute() {
            return this.isActive;
          }
        }

        // Usage in a standalone component:
        // @Component({
        //   selector: 'app-status-indicator',
        //   standalone: true,
        //   imports: [ActiveStateDirective],
        //   template: `
        //     <div [appActiveState]="isServiceOnline" (click)="toggleStatus()">
        //       Service Status: {{ isServiceOnline ? 'Online' : 'Offline' }}
        //     </div>
        //     <style>
        //       .active-styling { font-weight: bold; }
        //     </style>
        //   `
        // })
        // export class StatusIndicatorComponent {
        //   isServiceOnline = true;
        //   toggleStatus() { this.isServiceOnline = !this.isServiceOnline; }
        // }
        ```

4.  **`@HostListener(eventName: string, args?: string[])`**
    *   **Description:** Declares a method to be a handler for a host element event. Listens for events on the host element of the component/directive.
    *   **Real-life Example:** The `HighlightDirective` example above uses `@HostListener` for `mouseenter` and `mouseleave`. Another: A directive that logs clicks on its host.
        ```typescript
        // click-logger.directive.ts
        import { Directive, HostListener, Input } from '@angular/core';

        @Directive({
          selector: '[appClickLogger]',
          standalone: true,
        })
        export class ClickLoggerDirective {
          @Input('appClickLogger') message: string = 'Element clicked!';

          @HostListener('click', ['$event.target'])
          onClick(target: HTMLElement): void {
            console.log(`${this.message} Target: ${target.tagName}`);
          }

          @HostListener('document:keydown.escape', ['$event'])
          onEscapeKey(event: KeyboardEvent): void {
            console.log('Escape key pressed on document while this directive is active on an element.');
          }
        }

        // Usage in a standalone component:
        // @Component({
        //   selector: 'app-interactive-area',
        //   standalone: true,
        //   imports: [ClickLoggerDirective],
        //   template: `
        //     <button appClickLogger="Button Interaction">Click Me</button>
        //     <div appClickLogger="Div Interaction">Click this Div too!</div>
        //   `
        // })
        // export class InteractiveAreaComponent {}
        ```

5.  **`@ViewChild(selector: string | Type<any>, opts?: {read?: any, static?: boolean})`**
    *   **Description:** Provides access to a child element, component, or directive instance within the component's view template. The query result is available after the `ngAfterViewInit` lifecycle hook.
    *   `selector`: Can be a template reference variable (e.g., `#myVar`), a component type (e.g., `ChildComponent`), or a directive type.
    *   `read`: (Optional) Used to read a different token from the queried elements. E.g., `ElementRef`, `ViewContainerRef`, or a specific directive type.
    *   `static`: (Default `false`) If `true`, resolves query results before change detection runs. Only use `true` if you are certain the element will be present statically in the template and not within an `*ngIf`, `*ngFor`, etc. Generally, `false` is safer and more common.
    *   **Real-life Example:** Accessing an input field to focus it.
        ```typescript
        // focus-input.component.ts
        import { Component, ViewChild, ElementRef, AfterViewInit } from '@angular/core';

        @Component({
          selector: 'app-focus-input',
          standalone: true,
          template: `
            <input #nameInput type="text" placeholder="Enter your name">
            <button (click)="focusInput()">Focus Name Field</button>
          `
        })
        export class FocusInputComponent implements AfterViewInit {
          // Using ElementRef to access the native DOM element
          @ViewChild('nameInput') nameInputElementRef!: ElementRef<HTMLInputElement>;

          ngAfterViewInit(): void {
            // It's good practice to check if it exists, though '!' implies it will.
            // this.nameInputElementRef.nativeElement.focus(); // Focus on init
            console.log('Input element ready:', this.nameInputElementRef);
          }

          focusInput(): void {
            if (this.nameInputElementRef) {
              this.nameInputElementRef.nativeElement.focus();
            }
          }
        }
        ```

6.  **`@ViewChildren(selector: string | Type<any>, opts?: {read?: any})`**
    *   **Description:** Similar to `@ViewChild`, but returns a `QueryList` of all matching child elements, components, or directives. The `QueryList` is updated as elements are added or removed. Available after `ngAfterViewInit`.
    *   **Real-life Example:** Managing a list of selectable items.
        ```typescript
        // selectable-item.component.ts
        import { Component, Input, HostBinding, HostListener } from '@angular/core';

        @Component({
          selector: 'app-selectable-item',
          standalone: true,
          template: `{{ itemData }}`,
          styles: [`
            :host {
              display: block;
              padding: 8px;
              border: 1px solid #eee;
              margin-bottom: 5px;
              cursor: pointer;
            }
            :host.selected {
              background-color: lightblue;
              border-color: blue;
            }
          `]
        })
        export class SelectableItemComponent {
          @Input() itemData: string = '';
          @HostBinding('class.selected') isSelected: boolean = false;

          @HostListener('click')
          toggleSelection() {
            this.isSelected = !this.isSelected;
          }
        }

        // item-list.component.ts
        import { Component, ViewChildren, QueryList, AfterViewInit } from '@angular/core';
        import { CommonModule } from '@angular/common';
        import { SelectableItemComponent } from './selectable-item.component';

        @Component({
          selector: 'app-item-list',
          standalone: true,
          imports: [CommonModule, SelectableItemComponent],
          template: `
            <app-selectable-item *ngFor="let item of items" [itemData]="item"></app-selectable-item>
            <button (click)="logSelectedItems()">Log Selected</button>
          `
        })
        export class ItemListComponent implements AfterViewInit {
          @ViewChildren(SelectableItemComponent)
          itemComponents!: QueryList<SelectableItemComponent>;

          items = ['Apple', 'Banana', 'Cherry'];

          ngAfterViewInit(): void {
            this.itemComponents.changes.subscribe(() => {
              console.log('Selectable items changed!');
            });
          }

          logSelectedItems(): void {
            const selected = this.itemComponents
              .filter(itemComp => itemComp.isSelected)
              .map(itemComp => itemComp.itemData);
            console.log('Selected items:', selected);
          }
        }
        ```

7.  **`@ContentChild(selector: string | Type<any>, opts?: {read?: any, descendants?: boolean})`**
    *   **Description:** Accesses a child element, component, or directive instance that is projected into the component's view using `<ng-content>`. The query result is available after the `ngAfterContentInit` lifecycle hook.
    *   `descendants`: (Default `false`) If `true`, include all descendants, not just direct children.
    *   **Real-life Example:** A card component that can take a projected header.
        ```typescript
        // card-header.directive.ts (marker directive for projection)
        import { Directive } from '@angular/core';
        @Directive({ selector: '[appCardHeader]', standalone: true })
        export class CardHeaderDirective {}

        // card.component.ts
        import { Component, ContentChild, AfterContentInit, ElementRef } from '@angular/core';
        import { CardHeaderDirective } from './card-header.directive'; // Import if it's a separate file

        @Component({
          selector: 'app-card',
          standalone: true,
          imports: [], // CardHeaderDirective is not directly used in template, but for query
          template: `
            <div class="card">
              <div class="card-header-slot">
                <ng-content select="[appCardHeader]"></ng-content>
              </div>
              <div class="card-body">
                <ng-content></ng-content> <!-- Default slot for other content -->
              </div>
            </div>
          `,
          styles: [/* ... card styles ... */]
        })
        export class CardComponent implements AfterContentInit {
          // Query for the directive on a projected element
          @ContentChild(CardHeaderDirective, { read: ElementRef })
          projectedHeader!: ElementRef<HTMLElement>;

          // Or query for a projected component type:
          // @ContentChild(MyProjectedHeaderComponent)
          // projectedHeaderComponent!: MyProjectedHeaderComponent;

          ngAfterContentInit(): void {
            if (this.projectedHeader) {
              console.log('Projected header element:', this.projectedHeader.nativeElement.textContent);
              // You could, for example, add a class or style to it
              // this.projectedHeader.nativeElement.classList.add('fancy-header');
            }
          }
        }

        // Usage in another standalone component:
        // @Component({
        //   selector: 'app-page-layout',
        //   standalone: true,
        //   imports: [CardComponent, CardHeaderDirective], // Import CardComponent and the directive used for projection
        //   template: `
        //     <app-card>
        //       <h2 appCardHeader>My Awesome Card Title</h2>
        //       <p>This is the main content of the card, projected into the default ng-content.</p>
        //     </app-card>
        //   `
        // })
        // export class PageLayoutComponent {}
        ```

8.  **`@ContentChildren(selector: string | Type<any>, opts?: {read?: any, descendants?: boolean})`**
    *   **Description:** Similar to `@ContentChild`, but returns a `QueryList` of all matching projected elements, components, or directives. Available after `ngAfterContentInit`.
    *   **Real-life Example:** A tabset component that manages projected tab panels.
        ```typescript
        // tab-panel.component.ts
        import { Component, Input } from '@angular/core';
        import { CommonModule } from '@angular/common';

        @Component({
          selector: 'app-tab-panel',
          standalone: true,
          imports: [CommonModule],
          template: `
            <div [hidden]="!isActive">
              <h4>{{ title }}</h4>
              <ng-content></ng-content>
            </div>
          `
        })
        export class TabPanelComponent {
          @Input() title: string = 'Tab';
          isActive: boolean = false;
        }

        // tab-group.component.ts
        import { Component, ContentChildren, QueryList, AfterContentInit } from '@angular/core';
        import { CommonModule } from '@angular/common';
        import { TabPanelComponent } from './tab-panel.component';

        @Component({
          selector: 'app-tab-group',
          standalone: true,
          imports: [CommonModule], // TabPanelComponent is projected, not directly imported for template
          template: `
            <div class="tab-headers">
              <button *ngFor="let tab of tabPanels; let i = index"
                      (click)="selectTab(tab)"
                      [class.active]="tab.isActive">
                {{ tab.title }}
              </button>
            </div>
            <ng-content select="app-tab-panel"></ng-content>
          `,
          styles: [`.active { font-weight: bold; background-color: #e0e0e0; } button { margin-right: 5px; }`]
        })
        export class TabGroupComponent implements AfterContentInit {
          @ContentChildren(TabPanelComponent) tabPanels!: QueryList<TabPanelComponent>;

          ngAfterContentInit(): void {
            // Activate the first tab by default
            if (this.tabPanels.length > 0) {
              this.selectTab(this.tabPanels.first);
            }
            this.tabPanels.changes.subscribe(() => {
                // Handle if tabs are dynamically added/removed
                if (this.tabPanels.length > 0 && !this.tabPanels.some(tab => tab.isActive)) {
                    this.selectTab(this.tabPanels.first);
                }
            });
          }

          selectTab(selectedTab: TabPanelComponent): void {
            this.tabPanels.forEach(tab => tab.isActive = (tab === selectedTab));
          }
        }

        // Usage in another standalone component:
        // @Component({
        //   selector: 'app-settings',
        //   standalone: true,
        //   imports: [TabGroupComponent, TabPanelComponent], // Import both
        //   template: `
        //     <app-tab-group>
        //       <app-tab-panel title="Profile">
        //         <p>User profile settings...</p>
        //       </app-tab-panel>
        //       <app-tab-panel title="Notifications">
        //         <p>Notification preferences...</p>
        //       </app-tab-panel>
        //       <app-tab-panel title="Security">
        //         <p>Password and security settings...</p>
        //       </app-tab-panel>
        //     </app-tab-group>
        //   `
        // })
        // export class SettingsComponent {}
        ```

---

### III. Parameter Decorators (for constructor parameters)

These decorators are used on parameters of a class constructor to modify how dependency injection works for that specific parameter.

1.  **`@Inject(token)`**
    *   **Description:** Explicitly specifies the dependency injection token to be used for a constructor parameter. Useful when the type is not sufficient (e.g., injecting primitive values, configuration objects using `InjectionToken`, or multiple instances of the same type).
    *   **Real-life Example:** Injecting a configuration object.
        ```typescript
        // app.config.ts
        import { InjectionToken } from '@angular/core';

        export interface AppConfig {
          apiUrl: string;
          apiKey: string;
        }

        export const APP_CONFIG = new InjectionToken<AppConfig>('app.config');

        // main.ts (or app.config.ts for component-level providers)
        // import { bootstrapApplication } from '@angular/platform-browser';
        // import { AppComponent } from './app/app.component'; // Your root component
        // import { APP_CONFIG, AppConfig } from './app/app.config';

        // const myAppConfig: AppConfig = {
        //   apiUrl: 'https://api.example.com/v1',
        //   apiKey: 'YOUR_API_KEY_HERE'
        // };

        // bootstrapApplication(AppComponent, {
        //   providers: [
        //     { provide: APP_CONFIG, useValue: myAppConfig }
        //   ]
        // });

        // config-display.component.ts
        import { Component, Inject } from '@angular/core';
        import { APP_CONFIG, AppConfig } from './app.config'; // Assuming same folder

        @Component({
          selector: 'app-config-display',
          standalone: true,
          template: `
            <p>API URL: {{ config.apiUrl }}</p>
            <p>API Key: {{ config.apiKey ? 'Provided' : 'Not Provided' }}</p>
          `
          // If providing at component level (less common for app-wide config):
          // providers: [{ provide: APP_CONFIG, useValue: { apiUrl: 'local', apiKey: 'local_key' } }]
        })
        export class ConfigDisplayComponent {
          constructor(@Inject(APP_CONFIG) public config: AppConfig) {}
        }
        ```

2.  **`@Optional()`**
    *   **Description:** Makes a dependency optional. If the dependency is not found in the injector hierarchy, Angular injects `null` instead of throwing an error.
    *   **Real-life Example:** A component that can optionally use a logging service if it's provided.
        ```typescript
        // logger.service.ts
        import { Injectable } from '@angular/core';
        @Injectable() // Not providedIn: 'root' to make it optional
        export class LoggerService {
          log(message: string) { console.log(`LOGGER: ${message}`); }
        }

        // optional-logger-user.component.ts
        import { Component, Optional, inject } from '@angular/core';
        import { LoggerService } from './logger.service'; // Assuming same folder

        @Component({
          selector: 'app-optional-logger-user',
          standalone: true,
          // To test, provide LoggerService here or in bootstrapApplication, or not at all
          // providers: [LoggerService],
          template: `
            <button (click)="doSomething()">Do Something</button>
            <p>{{ message }}</p>
          `
        })
        export class OptionalLoggerUserComponent {
          message = 'Check console for logs if logger is available.';

          // Using constructor injection:
          // constructor(@Optional() private logger: LoggerService | null) {}

          // Using inject():
          private logger = inject(LoggerService, { optional: true });


          doSomething(): void {
            if (this.logger) {
              this.logger.log('OptionalLoggerUserComponent: "Do Something" was clicked.');
            } else {
              console.warn('OptionalLoggerUserComponent: LoggerService not available.');
              this.message = 'Logger not available. Check console for warnings.';
            }
          }
        }
        ```

3.  **`@Self()`**
    *   **Description:** Instructs the DI system to look for the dependency only in the injector of the current component/directive itself. It will not look at parent injectors. If not found locally, it throws an error (unless `@Optional` is also used).
    *   **Real-life Example:** A directive that requires a service provided *specifically on its host element* by another directive or the component itself, not an ancestor.
        ```typescript
        // value.service.ts
        import { Injectable } from '@angular/core';
        @Injectable() export class ValueService { value = 'Default Value'; }

        // self-injector.directive.ts
        import { Directive, Self, Optional, HostBinding } from '@angular/core';
        import { ValueService } from './value.service'; // Assuming same folder

        @Directive({
          selector: '[appSelfInjector]',
          standalone: true,
          // This directive ITSELF provides ValueService, so @Self will find it here.
          providers: [ValueService]
        })
        export class SelfInjectorDirective {
          @HostBinding('textContent') textContent: string;

          constructor(@Self() @Optional() private valueService: ValueService | null) {
            if (this.valueService) {
              this.valueService.value = 'Value from SelfInjectorDirective';
              this.textContent = `Self: ${this.valueService.value}`;
            } else {
              this.textContent = 'Self: ValueService not found locally.';
            }
          }
        }

        // parent.component.ts
        // import { Component } from '@angular/core';
        // import { ValueService } from './value.service';
        // import { SelfInjectorDirective } from './self-injector.directive';
        // import { CommonModule } from '@angular/common';

        // @Component({
        //   selector: 'app-parent-comp',
        //   standalone: true,
        //   imports: [SelfInjectorDirective, CommonModule],
        //   providers: [ValueService], // Provides ValueService at parent level
        //   template: `
        //     <p>Parent provides ValueService: {{ parentValueService.value }}</p>
        //     <div appSelfInjector></div>
        //     <!-- The div with appSelfInjector will use its OWN ValueService instance
        //          because of @Self and its own 'providers' array. -->
        //   `
        // })
        // export class ParentComponent {
        //   constructor(public parentValueService: ValueService) {
        //      parentValueService.value = "Value from ParentComponent";
        //   }
        // }
        ```

4.  **`@SkipSelf()`**
    *   **Description:** Instructs the DI system to start searching for the dependency from the parent injector, skipping the current component/directive's own injector.
    *   **Real-life Example:** A child component that wants to ensure it gets a service instance from its parent, not one it might accidentally provide itself (or one provided by a directive on itself).
        ```typescript
        // theme.service.ts
        import { Injectable } from '@angular/core';
        @Injectable() export class ThemeService { theme = 'light'; }

        // child.component.ts
        import { Component, SkipSelf, Optional, HostBinding } from '@angular/core';
        import { CommonModule } from '@angular/common';
        import { ThemeService } from './theme.service'; // Assuming same folder

        @Component({
          selector: 'app-child-comp',
          standalone: true,
          imports: [CommonModule],
          // This child component ALSO provides ThemeService, but @SkipSelf will ignore it.
          providers: [{ provide: ThemeService, useValue: { theme: 'child-theme-override' } }],
          template: `
            <p>Child component using theme: {{ themeService?.theme || 'No theme (SkipSelf found nothing)' }}</p>
            <p>Actual theme on this element (if child provided): {{ myOwnTheme.theme }}</p>
          `
        })
        export class ChildComponent {
          // This will get the ThemeService from the PARENT injector.
          constructor(
            @SkipSelf() @Optional() public themeService: ThemeService | null,
            public myOwnTheme: ThemeService // This gets the one provided by ChildComponent
          ) {}
        }

        // another-parent.component.ts
        // import { Component } from '@angular/core';
        // import { ChildComponent } from './child.component';
        // import { ThemeService } from './theme.service';

        // @Component({
        //   selector: 'app-another-parent',
        //   standalone: true,
        //   imports: [ChildComponent],
        //   providers: [ThemeService], // Parent provides ThemeService
        //   template: `
        //     <button (click)="toggleTheme()">Toggle Parent Theme</button>
        //     <p>Parent theme: {{ themeService.theme }}</p>
        //     <app-child-comp></app-child-comp>
        //   `
        // })
        // export class AnotherParentComponent {
        //   constructor(public themeService: ThemeService) {
        //     this.themeService.theme = "dark-parent";
        //   }
        //   toggleTheme() {
        //     this.themeService.theme = this.themeService.theme === 'dark-parent' ? 'light-parent' : 'dark-parent';
        //   }
        // }
        ```
        In this example, `ChildComponent`'s `themeService` (injected with `@SkipSelf`) will be `'dark-parent'` or `'light-parent'` from `AnotherParentComponent`, while `myOwnTheme` will be `'child-theme-override'`.

5.  **`@Host()`**
    *   **Description:** Instructs the DI system to look for a dependency in the injector of the host component. For a directive, the host component is the component on whose view element the directive is placed. The search stops at the host component; it doesn't go further up the injector tree. If the directive is on a regular HTML element (not a component), `@Host` behaves like `@Self`.
    *   **Real-life Example:** A directive that needs to interact with the component it's attached to. Imagine a form control directive that needs to register itself with a parent `app-form-group` component.
        ```typescript
        // form-group.component.ts (The Host Component)
        import { Component } from '@angular/core';

        @Component({
          selector: 'app-form-group',
          standalone: true,
          template: `
            <fieldset>
              <legend>{{ label }}</legend>
              <ng-content></ng-content> <!-- Where form-control-directive will live -->
            </fieldset>
          `
          // No explicit providers needed here for the service if it's a class the directive interacts with
        })
        export class FormGroupComponent {
          label: string = "My Form Group";
          controls: any[] = [];

          registerControl(control: any) {
            console.log('FormGroupComponent: Registering control', control);
            this.controls.push(control);
          }
        }

        // form-control.directive.ts
        import { Directive, OnInit, Host, Optional, ElementRef } from '@angular/core';
        import { FormGroupComponent } from './form-group.component';

        @Directive({
          selector: '[appFormControl]',
          standalone: true,
        })
        export class FormControlDirective implements OnInit {
          constructor(
            // @Host ensures we only look for FormGroupComponent on the host element or its component injector.
            @Host() @Optional() private formGroup: FormGroupComponent | null,
            private el: ElementRef
          ) {}

          ngOnInit(): void {
            if (this.formGroup) {
              this.formGroup.registerControl({
                name: this.el.nativeElement.getAttribute('name') || 'unnamed-control',
                element: this.el.nativeElement
              });
            } else {
              console.warn('FormControlDirective: Not hosted within an app-form-group component.');
            }
          }
        }

        // usage-example.component.ts
        // import { Component } from '@angular/core';
        // import { FormGroupComponent } from './form-group.component';
        // import { FormControlDirective } from './form-control.directive';

        // @Component({
        //   selector: 'app-my-form',
        //   standalone: true,
        //   imports: [FormGroupComponent, FormControlDirective],
        //   template: `
        //     <app-form-group>
        //       <label for="name">Name:</label>
        //       <input appFormControl type="text" id="name" name="userName">
        //       <br>
        //       <label for="email">Email:</label>
        //       <input appFormControl type="email" id="email" name="userEmail">
        //     </app-form-group>
        //     <hr>
        //     <!-- This directive won't find FormGroupComponent because it's not inside one -->
        //     <input appFormControl type="text" name="orphanControl" placeholder="Orphan control">
        //   `
        // })
        // export class MyFormComponent {}
        ```

---

### IV. `NgModule` Decorator (Legacy, but still exists)

1.  **`@NgModule(metadata)`**
    *   **Description:** While standalone components are the future, `@NgModule` is still fundamental to how Angular applications were structured before and for library development. It marks a class as an Angular Module and provides metadata to organize components, directives, pipes, and services. It configures the injector and the compiler.
    *   **Standalone Context:** You might still interact with NgModules if you're using third-party libraries that haven't fully migrated to standalone APIs, or if you are maintaining older parts of an application. Standalone components can import NgModules in their `imports` array.
    *   **Metadata Properties (common ones):**
        *   `declarations`: Components, directives, and pipes that belong to this NgModule. (Not used if these are standalone).
        *   `imports`: Other modules whose exported components, directives, pipes are needed by templates in this NgModule, or standalone entities.
        *   `exports`: Subset of declarations and imported modules that should be available to other NgModules that import this NgModule.
        *   `providers`: Services that this NgModule contributes to the global collection of services; they become available for injection globally if root NgModule, or locally if lazy-loaded.
        *   `bootstrap`: The main application view, called the root component, that hosts all other app views. Only the root NgModule should set this property.
    *   **Real-life Example:** You won't typically create new NgModules if you're fully embracing standalone components for new features. However, here's how a standalone component might *import* an existing NgModule (like `FormsModule` for template-driven forms):

        ```typescript
        // simple-form.component.ts
        import { Component } from '@angular/core';
        import { CommonModule } from '@angular/common';
        import { FormsModule } from '@angular/forms'; // Importing an NgModule

        @Component({
          selector: 'app-simple-form',
          standalone: true,
          imports: [
            CommonModule,
            FormsModule // Make FormsModule directives (like ngModel) available
          ],
          template: `
            <form #myForm="ngForm" (ngSubmit)="onSubmit(myForm.value)">
              <div>
                <label for="name">Name:</label>
                <input type="text" id="name" name="name" [(ngModel)]="formData.name" required>
              </div>
              <div>
                <label for="email">Email:</label>
                <input type="email" id="email" name="email" [(ngModel)]="formData.email" required email>
              </div>
              <button type="submit" [disabled]="!myForm.valid">Submit</button>
            </form>
            <pre *ngIf="submittedData">{{ submittedData | json }}</pre>
          `
        })
        export class SimpleFormComponent {
          formData = { name: '', email: '' };
          submittedData: any = null;

          onSubmit(formValue: any): void {
            this.submittedData = formValue;
            console.log('Form Submitted:', formValue);
            // In a real app, you'd send this to a service
          }
        }
        ```

---

This list covers the vast majority of decorators you'll encounter and use in Angular development, especially with the modern standalone component architecture. Remember that the examples are simplified to illustrate the decorator's purpose. Real-world applications will involve more complex logic and interactions.