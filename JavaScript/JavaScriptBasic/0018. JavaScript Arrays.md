
JavaScript arrays are versatile data structures that come with a rich set of built-in methods to manipulate, transform, and iterate over their elements. These methods can be categorized based on their purpose, such as **mutating** (changing the original array), **accessing** (returning elements or information), **iterating** (looping over elements), or **transforming** (creating new arrays).

As of 2025, JavaScript includes **over 30 array methods**, including those introduced in ES6 and later (e.g., Array.prototype.at() in ES2022). Below, I’ll list all standard array methods, grouped by category, with brief descriptions and examples. Then, I’ll provide practical Bangla examples to solidify understanding.

---

### Categories of Array Methods

1. **Mutator Methods** (Modify the original array)
2. **Accessor Methods** (Return information without modifying the array)
3. **Iteration Methods** (Loop over elements)
4. **Static Methods** (Operate on the Array constructor)
5. **Other Methods** (Miscellaneous, e.g., creating new arrays)

### 1. Mutator Methods

These methods **change the original array**.

|Method|Description|Example|
|---|---|---|
|push(...items)|Adds one or more elements to the **end** of the array. Returns new length.|let arr = [1, 2]; arr.push(3); // arr = [1, 2, 3]|
|pop()|Removes and returns the **last** element.|let arr = [1, 2, 3]; arr.pop(); // arr = [1, 2], returns 3|
|shift()|Removes and returns the **first** element.|let arr = [1, 2, 3]; arr.shift(); // arr = [2, 3], returns 1|
|unshift(...items)|Adds one or more elements to the **beginning**. Returns new length.|let arr = [2, 3]; arr.unshift(1); // arr = [1, 2, 3]|
|splice(start, deleteCount, ...items)|Removes/adds elements at a specific index. Returns removed elements.|let arr = [1, 2, 3]; arr.splice(1, 1, 'a'); // arr = [1, 'a', 3]|
|reverse()|Reverses the array in place.|let arr = [1, 2, 3]; arr.reverse(); // arr = [3, 2, 1]|
|sort(compareFn)|Sorts the array in place (default: lexicographical order).|let arr = [3, 1, 2]; arr.sort((a, b) => a - b); // arr = [1, 2, 3]|
|fill(value, start, end)|Fills all elements with a value from start to end (exclusive).|let arr = [1, 2, 3]; arr.fill(0, 1); // arr = [1, 0, 0]|
|copyWithin(target, start, end)|Copies a sequence of elements within the array to target index.|let arr = [1, 2, 3, 4]; arr.copyWithin(0, 2); // arr = [3, 4, 3, 4]|
### 2. Accessor Methods

These methods **do not modify the original array** and return information or a new array.

|Method|Description|Example|
|---|---|---|
|concat(...arrays)|Merges arrays and returns a new array.|let arr = [1, 2]; arr.concat([3, 4]); // [1, 2, 3, 4]|
|slice(start, end)|Returns a shallow copy of a portion of the array (from start to end).|let arr = [1, 2, 3]; arr.slice(1, 2); // [2]|
|join(separator)|Joins all elements into a string with a separator (default: comma).|let arr = [1, 2, 3]; arr.join('-'); // "1-2-3"|
|indexOf(element, fromIndex)|Returns the first index of an element, or -1 if not found.|let arr = [1, 2, 3]; arr.indexOf(2); // 1|
|lastIndexOf(element, fromIndex)|Returns the last index of an element, or -1 if not found.|let arr = [1, 2, 2]; arr.lastIndexOf(2); // 2|
|includes(element, fromIndex)|Checks if an element exists in the array (uses strict equality).|let arr = [1, 2, 3]; arr.includes(2); // true|
|toString()|Returns a string representation of the array.|let arr = [1, 2, 3]; arr.toString(); // "1,2,3"|
|toLocaleString()|Returns a localized string representation of the array.|let arr = [1, new Date()]; arr.toLocaleString(); // Localized output|
|at(index)|Returns the element at the specified index (supports negative indices).|let arr = [1, 2, 3]; arr.at(-1); // 3|

---

### 3. Iteration Methods

These methods **loop over the array** and execute a callback function, often returning a result.

|Method|Description|Example|
|---|---|---|
|forEach(callback)|Executes a callback for each element (no return value).|let arr = [1, 2, 3]; arr.forEach(x => console.log(x)); // 1, 2, 3|
|map(callback)|Creates a new array with the results of calling a callback on each element.|let arr = [1, 2, 3]; arr.map(x => x * 2); // [2, 4, 6]|
|filter(callback)|Creates a new array with elements that pass the callback’s test.|let arr = [1, 2, 3]; arr.filter(x => x > 1); // [2, 3]|
|find(callback)|Returns the first element that satisfies the callback, or undefined.|let arr = [1, 2, 3]; arr.find(x => x > 1); // 2|
|findIndex(callback)|Returns the index of the first element that satisfies the callback, or -1.|let arr = [1, 2, 3]; arr.findIndex(x => x > 1); // 1|
|findLast(callback)|Returns the last element that satisfies the callback, or undefined.|let arr = [1, 2, 3]; arr.findLast(x => x > 1); // 3|
|findLastIndex(callback)|Returns the index of the last element that satisfies the callback, or -1.|let arr = [1, 2, 3]; arr.findLastIndex(x => x > 1); // 2|
|every(callback)|Returns true if all elements pass the callback’s test.|let arr = [1, 2, 3]; arr.every(x => x > 0); // true|
|some(callback)|Returns true if at least one element passes the callback’s test.|let arr = [1, 2, 3]; arr.some(x => x > 2); // true|
|reduce(callback, initialValue)|Reduces the array to a single value by applying a callback.|let arr = [1, 2, 3]; arr.reduce((sum, x) => sum + x, 0); // 6|
|reduceRight(callback, initialValue)|Same as reduce, but processes from right to left.|let arr = [1, 2, 3]; arr.reduceRight((sum, x) => sum + x, 0); // 6|

---

### 4. Static Methods

These methods are called on the Array constructor, not on array instances.

|Method|Description|Example|
|---|---|---|
|Array.from(iterable, mapFn)|Creates a new array from an iterable or array-like object.|Array.from("abc"); // ["a", "b", "c"]|
|Array.of(...elements)|Creates a new array with the given elements.|Array.of(1, 2, 3); // [1, 2, 3]|
|Array.isArray(value)|Checks if a value is an array.|Array.isArray([1, 2]); // true|

---

### 5. Other Methods

These methods don’t fit neatly into the above categories but are useful.

|Method|Description|Example|
|---|---|---|
|flat(depth)|Flattens nested arrays into a new array up to the specified depth.|let arr = [1, [2, [3]]]; arr.flat(2); // [1, 2, 3]|
|flatMap(callback)|Maps each element using a callback, then flattens the result by one level.|let arr = [1, 2]; arr.flatMap(x => [x, x * 2]); // [1, 2, 2, 4]|


### Key Notes

- **Mutator vs. Non-Mutator**:
    - Mutator methods (push, pop, etc.) change the original array.
    - Non-mutator methods (map, filter, etc.) return a new array or value.
- **Callback Signatures**:
    - Most iteration methods (map, filter, etc.) take a callback with parameters: (element, index, array).
    - Example: arr.map((item, index) => item + index).
- **Chaining**: Many methods return arrays, allowing chaining (e.g., arr.filter(...).map(...)).
- **Performance**: Methods like forEach are convenient but may be slower than for loops for large arrays.
- **ES6+ Features**: Methods like flat, flatMap, and at are modern additions, fully supported in 2025 browsers.