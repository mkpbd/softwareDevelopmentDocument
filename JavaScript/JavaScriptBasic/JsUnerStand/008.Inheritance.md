
 আজকে জাভাস্ক্রিপ্টের আরেকটি খুবই গুরুত্বপূর্ণ বিষয় – **ইনহেরিটেন্স (Inheritance)** বা উত্তরাধিকার – নিয়ে বাংলায় আলোচনা করবো।

**ইনহেরিটেন্স কী? (What is Inheritance?)**

সাধারণ অর্থে, ইনহেরিটেন্স মানে হলো উত্তরাধিকার সূত্রে কিছু পাওয়া। প্রোগ্রামিংয়ের দুনিয়ায়, বিশেষ করে অবজেক্ট-ওরিয়েন্টেড প্রোগ্রামিং (OOP)-তে, ইনহেরিটেন্স হলো এমন একটি প্রক্রিয়া যার মাধ্যমে একটি অবজেক্ট বা ক্লাস (child/derived class) অন্য একটি অবজেক্ট বা ক্লাসের (parent/base class) বৈশিষ্ট্য (properties) এবং আচরণ (methods) গুলো পেয়ে থাকে।

সহজ ভাষায়:
*   আপনি একটা "মূল" বা "জনক" (parent) ক্লাস তৈরি করলেন যার কিছু সাধারণ বৈশিষ্ট্য ও কাজ আছে।
*   এরপর আপনি এই মূল ক্লাস থেকে নতুন "সন্তান" (child) ক্লাস তৈরি করতে পারবেন।
*   এই সন্তান ক্লাসগুলো স্বয়ংক্রিয়ভাবে তাদের জনক ক্লাসের সব বৈশিষ্ট্য ও কাজ পেয়ে যাবে।
*   শুধু তাই নয়, সন্তান ক্লাসগুলো তাদের নিজস্ব নতুন বৈশিষ্ট্য ও কাজও যোগ করতে পারবে অথবা জনকের কোনো কাজকে নিজের মতো করে পরিবর্তন (override) করতে পারবে।

**জাভাস্ক্রিপ্টে ইনহেরিটেন্স:**

জাভাস্ক্রিপ্ট মূলত একটি প্রোটোটাইপ-ভিত্তিক (prototype-based) ভাষা। যদিও ES6 (ECMAScript 2015) থেকে `class` সিনট্যাক্স চালু হয়েছে যা অন্যান্য ক্লাসিক্যাল OOP ভাষার মতো দেখায়, ভেতরে ভেতরে জাভাস্ক্রিপ্ট এখনও প্রোটোটাইপ ব্যবহার করেই ইনহেরিটেন্স বাস্তবায়ন করে।

আমরা দুটি প্রধান উপায় দেখবো:
১. প্রোটোটাইপ-ভিত্তিক ইনহেরিটেন্স (ES5 এবং তার আগের পদ্ধতিতে)
২. ক্লাস-ভিত্তিক ইনহেরিটেন্স (ES6 `class` সিনট্যাক্স ব্যবহার করে)

---

**১. প্রোটোটাইপ-ভিত্তিক ইনহেরিটেন্স (Prototypal Inheritance)**

এই পদ্ধতিতে আমরা কন্সট্রাক্টর ফাংশন (constructor functions) এবং তাদের `prototype` অবজেক্ট ব্যবহার করি।

**উদাহরণ:**

ধরুন, আমাদের একটা `Animal` (প্রাণী) নামে একটা কন্সট্রাক্টর ফাংশন আছে:

```javascript
// জনক কন্সট্রাক্টর ফাংশন (Parent Constructor Function)
function Animal(name) {
    this.name = name; // প্রতিটি প্রাণীর একটি নাম থাকবে
}

// Animal এর প্রোটোটাইপে একটি মেথড যোগ করি
Animal.prototype.eat = function() {
    console.log(this.name + " খাচ্ছে...");
};

Animal.prototype.sleep = function() {
    console.log(this.name + " ঘুমাচ্ছে...");
};

// --- এখন আমরা একটি Dog (কুকুর) কন্সট্রাক্টর ফাংশন তৈরি করবো যা Animal থেকে ইনহেরিট করবে ---

// সন্তান কন্সট্রাক্টর ফাংশন (Child Constructor Function)
function Dog(name, breed) {
    // ১. জনক কন্সট্রাক্টরের বৈশিষ্ট্যগুলো সন্তানের মধ্যে আনতে হবে
    Animal.call(this, name); // 'this' Dog অবজেক্টকে নির্দেশ করে
    this.breed = breed; // Dog এর নিজস্ব বৈশিষ্ট্য
}

// ২. প্রোটোটাইপ চেইন সেটআপ করা (সবচেয়ে গুরুত্বপূর্ণ ধাপ)
// Dog.prototype এখন Animal.prototype এর বৈশিষ্ট্যগুলো ইনহেরিট করবে
Dog.prototype = Object.create(Animal.prototype);

// ৩. কন্সট্রাক্টর ঠিক করা (ঐচ্ছিক কিন্তু ভালো অভ্যাস)
// Object.create() ব্যবহারের ফলে Dog.prototype.constructor Animal হয়ে যায়,
// তাই এটাকে ঠিক করে Dog এ সেট করতে হবে।
Dog.prototype.constructor = Dog;

// Dog এর নিজস্ব মেথড যোগ করি
Dog.prototype.bark = function() {
    console.log(this.name + " ঘেউ ঘেউ করছে!");
};

// --- পরীক্ষা করে দেখা যাক ---
let myDog = new Dog("টমি", "জার্মান শেফার্ড");

console.log(myDog.name);    // আউটপুট: টমি (Animal থেকে প্রাপ্ত)
console.log(myDog.breed);   // আউটপুট: জার্মান শেফার্ড (Dog এর নিজস্ব)

myDog.eat();    // আউটপুট: টমি খাচ্ছে... (Animal.prototype থেকে প্রাপ্ত)
myDog.sleep();  // আউটপুট: টমি ঘুমাচ্ছে... (Animal.prototype থেকে প্রাপ্ত)
myDog.bark();   // আউটপুট: টমি ঘেউ ঘেউ করছে! (Dog.prototype এর নিজস্ব)

console.log(myDog instanceof Dog);    // আউটপুট: true
console.log(myDog instanceof Animal); // আউটপুট: true
```

**ব্যাখ্যা:**
*   `Animal.call(this, name);`: এই লাইনের মাধ্যমে `Animal` কন্সট্রাক্টরের কোড `Dog` এর `this` (অর্থাৎ নতুন `Dog` অবজেক্ট) এর উপর চালানো হয়। ফলে `name` প্রপার্টি `Dog` অবজেক্টে সেট হয়ে যায়। একে বলা হয় "constructor stealing" বা "borrowing constructor"।
*   `Dog.prototype = Object.create(Animal.prototype);`: এটাই মূল ইনহেরিটেন্সের ধাপ। `Object.create()` মেথড একটি নতুন অবজেক্ট তৈরি করে যার প্রোটোটাইপ (`__proto__`) হয় `Animal.prototype`। এর ফলে `Dog` এর ইনস্ট্যান্সগুলো `Animal.prototype`-এ থাকা মেথডগুলো (যেমন `eat`, `sleep`) অ্যাক্সেস করতে পারে।
*   `Dog.prototype.constructor = Dog;`: `Object.create` ব্যবহার করলে `Dog.prototype` এর `constructor` প্রপার্টি `Animal` হয়ে যায়। এই লাইনটি সেটাকে ঠিক করে `Dog`-এ সেট করে, যা `instanceof` অপারেটরের সঠিক আচরণের জন্য এবং ডিবাগিংয়ের জন্য সহায়ক।

---

**২. ক্লাস-ভিত্তিক ইনহেরিটেন্স (ES6 `class` Syntax)**

ES6 `class` সিনট্যাক্স প্রোটোটাইপ-ভিত্তিক ইনহেরিটেন্সকে অনেক সহজ এবং পড়ার উপযোগী করে তুলেছে। এটি মূলত উপরের প্রোটোটাইপ মডেলের উপর একটি "সিনট্যাকটিক সুগার" (syntactic sugar), অর্থাৎ কোড লেখার একটা সুন্দর ও সহজ পদ্ধতি।

**একই উদাহরণ `class` ব্যবহার করে:**

```javascript
// জনক ক্লাস (Parent Class)
class Animal {
    constructor(name) {
        this.name = name;
    }

    eat() {
        console.log(`${this.name} খাচ্ছে...`);
    }

    sleep() {
        console.log(`${this.name} ঘুমাচ্ছে...`);
    }
}

// সন্তান ক্লাস (Child Class) যা Animal থেকে ইনহেরিট করছে
class Dog extends Animal { // 'extends' কীওয়ার্ড ব্যবহার করা হয়
    constructor(name, breed) {
        super(name); // জনক ক্লাসের কন্সট্রাক্টরকে কল করে (Animal.call(this, name) এর মতো)
        this.breed = breed; // Dog এর নিজস্ব বৈশিষ্ট্য
    }

    bark() {
        console.log(`${this.name} ঘেউ ঘেউ করছে!`);
    }

    // মেথড ওভাররাইডিং (Method Overriding)
    // যদি সন্তান ক্লাস জনকের কোনো মেথডকে নিজের মতো করে সংজ্ঞায়িত করে
    eat() {
        // জনকের eat মেথডকেও কল করা যেতে পারে
        super.eat(); // এটি Animal ক্লাসের eat() মেথডকে কল করবে
        console.log(`${this.name} তার বাটিতে খাচ্ছে।`); // Dog এর নিজস্ব আচরণ
    }
}

// --- পরীক্ষা করে দেখা যাক ---
let myES6Dog = new Dog("লালি", "স্প্যানিয়েল");

console.log(myES6Dog.name);    // আউটপুট: লালি
console.log(myES6Dog.breed);   // আউটপুট: স্প্যানিয়েল

myES6Dog.eat();
// আউটপুট:
// লালি খাচ্ছে...
// লালি তার বাটিতে খাচ্ছে।

myES6Dog.sleep();  // আউটপুট: লালি ঘুমাচ্ছে...
myES6Dog.bark();   // আউটপুট: লালি ঘেউ ঘেউ করছে!

console.log(myES6Dog instanceof Dog);    // আউটপুট: true
console.log(myES6Dog instanceof Animal); // আউটপুট: true
```

**ব্যাখ্যা (`class` সিনট্যাক্স):**
*   `class Animal { ... }`: `Animal` নামে একটি ক্লাস তৈরি করা হলো।
*   `constructor(name) { ... }`: ক্লাসের কন্সট্রাক্টর মেথড, যা `new Animal(...)` কল করার সময় স্বয়ংক্রিয়ভাবে কল হয়।
*   `class Dog extends Animal { ... }`: `Dog` ক্লাস `Animal` ক্লাসকে `extends` করছে। এর মানে `Dog` হলো `Animal` এর সন্তান।
*   `super(name);`: সন্তান ক্লাসের কন্সট্রাক্টরের ভেতরে `super()` কল করা আবশ্যক যদি জনক ক্লাসের কন্সট্রাক্টর থাকে। এটি জনক ক্লাসের কন্সট্রাক্টরকে (`Animal` এর `constructor`) কল করে। `this` ব্যবহার করার আগে `super()` কল করতে হবে।
*   `super.eat();`: সন্তান ক্লাসের কোনো মেথডের ভেতর থেকে `super.methodName()` ব্যবহার করে জনক ক্লাসের একই নামের মেথডকে কল করা যায়। একে মেথড ওভাররাইডিংয়ের সময় কাজে লাগানো হয়।

**ইনহেরিটেন্সের সুবিধা:**
*   **কোডের পুনঃব্যবহার (Code Reusability):** জনক ক্লাসে লেখা কোড একাধিক সন্তান ক্লাস ব্যবহার করতে পারে, ফলে একই কোড বারবার লেখার প্রয়োজন হয় না।
*   **সংগঠিত কোড (Organized Code):** সম্পর্কিত ক্লাসগুলোকে একটি হায়ারার্কি বা ক্রমবিন্যাসে সাজানো যায়, যা কোডকে আরও কাঠামোবদ্ধ এবং বোঝার উপযোগী করে।
*   **পলিমরফিজম (Polymorphism - সীমিত অর্থে জাভাস্ক্রিপ্টে):** একই ইন্টারফেস (যেমন `eat` মেথড) বিভিন্ন অবজেক্টে ভিন্ন ভিন্ন আচরণ করতে পারে। (জাভাস্ক্রিপ্টে এটি ডাক টাইপিংয়ের মাধ্যমেও অর্জিত হয়)।
*   **সহজে রক্ষণাবেক্ষণ (Easier Maintenance):** যদি সাধারণ কোনো লজিক পরিবর্তন করার দরকার হয়, তাহলে শুধু জনক ক্লাসে পরিবর্তন করলেই সব সন্তান ক্লাসে তার প্রভাব পড়বে।

**কিছু বিবেচ্য বিষয়:**
*   ইনহেরিটেন্স একটি "is-a" সম্পর্ক নির্দেশ করে (যেমন, একটি `Dog` "is an" `Animal`)। যদি এই সম্পর্ক না থাকে, তাহলে ইনহেরিটেন্স ব্যবহার করা উচিত নয়। সেক্ষেত্রে "কম্পোজিশন" (Composition - "has-a" সম্পর্ক) একটি ভালো বিকল্প হতে পারে।
*   খুব গভীর ইনহেরিটেন্স হায়ারার্কি (অনেকগুলো লেভেলের ইনহেরিটেন্স) কোডকে জটিল করে তুলতে পারে এবং রক্ষণাবেক্ষণে সমস্যা তৈরি করতে পারে।

**শেষ কথা:**

জাভাস্ক্রিপ্টে ইনহেরিটেন্স, বিশেষ করে ES6 `class` সিনট্যাক্সের মাধ্যমে, কোডকে আরও OOP-বান্ধব এবং কাঠামোবদ্ধ করতে সাহায্য করে। যদিও এর মূলে প্রোটোটাইপ মডেল কাজ করে, `class` সিনট্যাক্স ডেভেলপারদের জন্য এটিকে ব্যবহার করা অনেক সহজ করে দিয়েছে।

আশা করি জাভাস্ক্রিপ্টে ইনহেরিটেন্সের ধারণাটি আপনাদের কাছে পরিষ্কার হয়েছে। প্র্যাকটিস করতে থাকুন, আর কোনো প্রশ্ন থাকলে অবশ্যই জানাবেন!