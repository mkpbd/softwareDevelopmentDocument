
দারুণ! রিফ্লেকশনের পর জাভাস্ক্রিপ্টের আরেকটি অ্যাডভান্সড এবং বর্তমানে খুবই আলোচিত বিষয় হলো **ডেকোরেটর (Decorators)**। এটি সিনট্যাকটিক সুগার (syntactic sugar) যা জাভাস্ক্রিপ্টে মেটাপ্রোগ্রামিংকে আরও সহজ ও সুন্দর করে তোলে।

**ডেকোরেটর কী? (What are Decorators?)**

ডেকোরেটর হলো একটি বিশেষ ধরনের ডিক্লারেশন যা ক্লাস, মেথড, অ্যাক্সেসর (getter/setter), অথবা প্রপার্টিকে পরিবর্তন বা "ডেকোরেট" (decorate) করতে ব্যবহৃত হয়। এটি ফাংশনাল প্রোগ্রামিংয়ের উচ্চ-ক্রমের ফাংশন (Higher-Order Functions) এর ধারণার উপর ভিত্তি করে তৈরি।

সহজ ভাষায়, ডেকোরেটর হলো একটি ফাংশন যা অন্য একটি ফাংশন বা ক্লাসকে আর্গুমেন্ট হিসেবে নেয় এবং তাকে কিছু অতিরিক্ত কার্যকারিতা যোগ করে বা তার আচরণ পরিবর্তন করে নতুন একটি সংস্করণ রিটার্ন করে। ডেকোরেটর প্যাটার্নের এটি একটি সিনট্যাকটিক প্রয়োগ।

**ডেকোরেটরের সিনট্যাক্স:**

ডেকোরেটর সিনট্যাক্স `@expression` আকারে লেখা হয়, যেখানে `expression` অবশ্যই একটি ফাংশন হতে হবে যা ডেকোরেট করা হচ্ছে এমন টার্গেট (যেমন ক্লাস বা মেথড) এবং অন্যান্য প্রাসঙ্গিক তথ্য (যেমন প্রপার্টির নাম, ডেসক্রিপ্টর) আর্গুমেন্ট হিসেবে গ্রহণ করে।

**গুরুত্বপূর্ণ:** জাভাস্ক্রিপ্টে ডেকোরেটর বর্তমানে একটি **ECMAScript প্রস্তাব (proposal)** এবং এটি স্টেজ ৩ এ আছে (জুলাই ২০২৩ অনুযায়ী)। এর মানে হলো এটি এখনও স্ট্যান্ডার্ড জাভাস্ক্রিপ্টের অংশ নয়, তবে Babel এর মতো ট্রান্সপাইলার ব্যবহার করে অথবা TypeScript (যা ডেকোরেটর সমর্থন করে) এর মাধ্যমে এটি ব্যবহার করা যায়। ব্রাউজার এবং নোড.জেএস এ নেটিভ সমর্থন আসতে আরও কিছু সময় লাগতে পারে। সিনট্যাক্স এবং কার্যকারিতা চূড়ান্ত হওয়ার আগে কিছুটা পরিবর্তিতও হতে পারে।

**ডেকোরেটরের প্রকারভেদ ও উদাহরণ:**

ডেকোরেটর বিভিন্ন জিনিসের উপর প্রয়োগ করা যায়:

১.  **ক্লাস ডেকোরেটর (Class Decorators):**
    *   একটি ক্লাসের কন্সট্রাক্টরকে ডেকোরেট করে।
    *   এটি ক্লাসের কন্সট্রাক্টরকে আর্গুমেন্ট হিসেবে পায় এবং একটি নতুন কন্সট্রাক্টর (বা `undefined`) রিটার্ন করতে পারে।

```javascript
    // একটি সাধারণ ক্লাস ডেকোরেটর ফাংশন
    function logClass(targetConstructor) {
        console.log(`ক্লাস "${targetConstructor.name}" লোড করা হয়েছে।`);
        // চাইলে মূল কন্সট্রাক্টর পরিবর্তন করে নতুন কন্সট্রাক্টর রিটার্ন করা যেত
        // return class extends targetConstructor { /* ... অতিরিক্ত কার্যকারিতা ... */ }
    }

    @logClass // ডেকোরেটর প্রয়োগ
    class Person {
        constructor(name) {
            this.name = name;
        }
    }

    const person = new Person("আবির");
    // আউটপুট (ক্লাস ডিক্লারেশনের সময়):
    // ক্লাস "Person" লোড করা হয়েছে।
    ```

২.  **মেথড ডেকোরেটর (Method Decorators):**
    *   একটি ক্লাসের মেথডকে ডেকোরেট করে।
    *   এটি তিনটি আর্গুমেন্ট পায়:
        ১.  `target`: ক্লাসের প্রোটোটাইপ (ইনস্ট্যান্স মেথডের জন্য) অথবা ক্লাসের কন্সট্রাক্টর (স্ট্যাটিক মেথডের জন্য)।
        ২.  `propertyKey`: মেথডের নাম (স্ট্রিং)।
        ৩.  `descriptor`: প্রপার্টি ডেসক্রিপ্টর অবজেক্ট (যেমন `Object.getOwnPropertyDescriptor` থেকে প্রাপ্ত)।
    *   এটি একটি নতুন প্রপার্টি ডেসক্রিপ্টর রিটার্ন করতে পারে অথবা মূল ডেসক্রিপ্টরকে পরিবর্তন করতে পারে।

```javascript
    // একটি মেথড ডেকোরেটর যা মেথড কলের আগে ও পরে লগ করে
    function logMethodExecution(target, propertyKey, descriptor) {
        const originalMethod = descriptor.value; // মূল মেথড

        descriptor.value = function(...args) { // মূল মেথডকে একটি নতুন ফাংশন দিয়ে প্রতিস্থাপন করা হচ্ছে
            console.log(`মেথড "${propertyKey}" কল করা হচ্ছে আর্গুমেন্ট ${JSON.stringify(args)} সহ`);
            const result = originalMethod.apply(this, args); // মূল মেথড কল
            console.log(`মেথড "${propertyKey}" এক্সিকিউশন সম্পন্ন করেছে, ফলাফল: ${result}`);
            return result;
        };
        return descriptor;
    }

    class Calculator {
        @logMethodExecution
        add(a, b) {
            return a + b;
        }
    }

    const calc = new Calculator();
    calc.add(5, 3);
    // আউটপুট:
    // মেথড "add" কল করা হচ্ছে আর্গুমেন্ট [5,3] সহ
    // মেথড "add" এক্সিকিউশন সম্পন্ন করেছে, ফলাফল: 8
    ```

৩.  **অ্যাক্সেসর ডেকোরেটর (Accessor Decorators):**
    *   ক্লাসের getter বা setter মেথডকে ডেকোরেট করে।
    *   এরাও মেথড ডেকোরেটরের মতোই `target`, `propertyKey`, এবং `descriptor` আর্গুমেন্ট পায়।

৪.  **প্রপার্টি ডেকোরেটর (Property Decorators):**
    *   ক্লাসের প্রপার্টিকে ডেকোরেট করে।
    *   এরা দুটি আর্গুমেন্ট পায়: `target` (ক্লাসের প্রোটোটাইপ) এবং `propertyKey` (প্রপার্টির নাম)।
    *   **গুরুত্বপূর্ণ:** প্রপার্টি ডেকোরেটর সরাসরি প্রপার্টির ভ্যালু অ্যাক্সেস বা পরিবর্তন করতে পারে না (কারণ এটি ক্লাসের প্রোটোটাইপে রান করে যখন প্রপার্টি ইনিশিয়ালাইজ হয় না)। এর পরিবর্তে, এটি `Object.defineProperty` ব্যবহার করে প্রপার্টির আচরণ পরিবর্তন করতে পারে অথবা মেটাডেটা সেট করতে পারে। এটি ডেকরটের প্রস্তাবের বিভিন্ন সংস্করণে কিছুটা ভিন্নভাবে কাজ করে।

```javascript
    // একটি প্রপার্টি ডেকোরেটর (খুবই সরলীকৃত, মেটাডেটা সংরক্ষণের জন্য)
    // এই উদাহরণটি ডেকোরেটর প্রপোজালের পুরনো সিনট্যাক্সের উপর ভিত্তি করে হতে পারে
    function readonly(target, propertyKey, descriptor) {
        // যদি descriptor থাকে (অ্যাক্সেসরের ক্ষেত্রে), তাহলে writable: false করুন
        if (descriptor) {
            descriptor.writable = false;
            return descriptor;
        }
        // যদি শুধু প্রপার্টি হয়, তাহলে getter/setter দিয়ে readonly করা যেতে পারে
        // অথবা, ইনিশিয়ালাইজেশনের সময় error থ্রো করা যেতে পারে
        // এটি ডেকোরেটর স্পেসিফিকেশনের উপর নির্ভরশীল
        console.warn(`@readonly ডেকোরেটর "${propertyKey}" প্রপার্টিতে সেভাবে কাজ করবে না যেমনটি প্রত্যাশিত।`);
    }

    class Circle {
        @readonly // এটি PI কে readonly করার চেষ্টা করছে
        PI = 3.14159;

        constructor(radius) {
            this.radius = radius;
        }
    }

    const c = new Circle(5);
    // c.PI = 3; // এটি পরিবর্তন করা উচিত নয়, কিন্তু ডেকোরেটরের ইমপ্লিমেন্টেশনের উপর নির্ভর করবে
    console.log(c.PI);
    ```
    আধুনিক ডেকোরেটর প্রস্তাবে, প্রপার্টি ডেকোরেটর একটি ইনিশিয়ালাইজার ফাংশন রিটার্ন করতে পারে।

৫.  **প্যারামিটার ডেকোরেটর (Parameter Decorators) (TypeScript এ আছে):**
    *   মেথডের প্যারামিটারকে ডেকোরেট করে।
    *   এরা তিনটি আর্গুমেন্ট পায়: `target`, `propertyKey` (মেথডের নাম), এবং `parameterIndex` (প্যারামিটারের অবস্থান)।
    *   জাভাস্ক্রিপ্টের বর্তমান ডেকোরেটর প্রস্তাবে প্যারামিটার ডেকোরেটর সরাসরি অন্তর্ভুক্ত নয়, তবে TypeScript এটি সমর্থন করে।

**ডেকোরেটরের ব্যবহারিক ক্ষেত্র:**

*   **লগিং (Logging):** মেথড কল, আর্গুমেন্ট, ফলাফল ইত্যাদি লগ করা।
*   **অ্যাক্সেস কন্ট্রোল / অথরাইজেশন (Access Control / Authorization):** মেথড কল করার আগে ইউজারের পারমিশন চেক করা।
*   **ডেটা ভ্যালিডেশন (Data Validation):** মেথডের আর্গুমেন্ট বা ক্লাসের প্রপার্টি ভ্যালিডেট করা।
*   **মেমোইজেশন (Memoization):** এক্সপেন্সিভ মেথডের ফলাফল ক্যাশ করা।
*   **ডিপেন্ডেন্সি ইনজেকশন (Dependency Injection):** ক্লাসের ডিপেন্ডেন্সি স্বয়ংক্রিয়ভাবে ইনজেক্ট করা।
*   **এপিআই রাউটিং (API Routing):** ফ্রেমওয়ার্ক যেমন NestJS (Node.js) এপিআই এন্ডপয়েন্ট ডিফাইন করতে ডেকোরেটর ব্যবহার করে (যেমন `@Get()`, `@Post()`)।
*   **ডেটাবেস স্কিমা / ORM:** টাইপ এবং রিলেশনশিপ ডিফাইন করতে (যেমন TypeORM)।

**ডেকোরেটর কীভাবে কাজ করে (পেছনের কথা):**

ডেকোরেটর `@expression` সিনট্যাক্সটি আসলে নিচের মতো একটি ফাংশন কলের সমতুল্য:
`target = expression(target, propertyKey, descriptor) || target;` (এটি একটি সরলীকৃত ধারণা)

অর্থাৎ, ডেকোরেটর ফাংশনটি কল হয় এবং তার রিটার্ন ভ্যালু (যদি থাকে) মূল টার্গেটকে প্রতিস্থাপন করে।

**ডেকোরেটর ব্যবহারের সুবিধা:**

*   **ডিক্লারেটিভ সিনট্যাক্স:** কোড দেখতে অনেক পরিষ্কার এবং বর্ণনামূলক হয়। আপনি সহজেই বুঝতে পারেন একটি ক্লাস বা মেথডের সাথে কী ধরনের অতিরিক্ত আচরণ যুক্ত করা হয়েছে।
*   **পুনঃব্যবহারযোগ্যতা:** একই ডেকোরেটর ফাংশন বিভিন্ন ক্লাস বা মেথডে ব্যবহার করা যায়।
*   **কোডের পৃথকীকরণ (Separation of Concerns):** মূল বিজনেস লজিক থেকে ক্রস-কাটিং কনসার্ন (cross-cutting concerns) যেমন লগিং, ভ্যালিডেশন ইত্যাদি আলাদা করা যায়।
*   **মেটাপ্রোগ্রামিং সহজ করে:** রানটাইমে কোডের আচরণ পরিবর্তন করার একটি সুন্দর উপায়।

**সীমাবদ্ধতা ও বিবেচ্য বিষয়:**

*   **স্ট্যান্ডার্ডাইজেশন:** যেহেতু এটি এখনও প্রস্তাবনা পর্যায়ে আছে, তাই সিনট্যাক্স বা আচরণে সামান্য পরিবর্তন আসতে পারে।
*   **ট্রান্সপাইলেশন:** বর্তমানে ব্যবহারের জন্য Babel বা TypeScript এর মতো টুলের উপর নির্ভর করতে হয়।
*   **ডিবাগিং:** ডেকোরেটর অনেকগুলো লেয়ার যোগ করতে পারে, যা ডিবাগিংকে কিছুটা জটিল করে তুলতে পারে।
*   **পারফরম্যান্স:** অতিরিক্ত ফাংশন কল এবং মেটাপ্রোগ্রামিংয়ের কারণে সামান্য পারফরম্যান্স ওভারহেড হতে পারে, যদিও বেশিরভাগ ক্ষেত্রে এটি নগণ্য।
*   **অতিরিক্ত ব্যবহার (Overuse):** সবকিছুর জন্য ডেকোরেটর ব্যবহার করা উচিত নয়। এটি কোডকে অতিরঞ্জিত এবং বোঝা কঠিন করে তুলতে পারে যদি সঠিকভাবে ব্যবহার না করা হয়।

**শেষ কথা:**

ডেকোরেটর জাভাস্ক্রিপ্ট ইকোসিস্টেমে একটি খুবই উত্তেজনাপূর্ণ সংযোজন। এটি কোড লেখার একটি শক্তিশালী এবং মার্জিত উপায় সরবরাহ করে, বিশেষ করে যখন আপনি ক্রস-কাটিং কনসার্ন নিয়ে কাজ করছেন বা ডিক্লারেটিভ সিনট্যাক্সের মাধ্যমে কোডের পঠনযোগ্যতা বাড়াতে চাইছেন।

যদিও এটি এখনও পুরোপুরি স্ট্যান্ডার্ড হয়ে ওঠেনি, TypeScript এর ব্যাপক ব্যবহার এবং Babel এর সমর্থনের কারণে অনেক ডেভেলপার ইতিমধ্যেই ডেকোরেটর ব্যবহার করছেন। জাভাস্ক্রিপ্টের ভবিষ্যৎ সংস্করণগুলোতে এটি নেটিভভাবে সমর্থিত হলে, এর ব্যবহার আরও বাড়বে বলে আশা করা যায়।

আশা করি, ডেকোরেটর নিয়ে এই বিস্তারিত আলোচনা আপনাদের জন্য সহায়ক হয়েছে!