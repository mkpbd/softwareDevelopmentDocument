### Data models.
• Data model relationship between documents.
• Modeling tree structures.
• Aggregation operations.
• SQL aggregation terms and corresponding MongoDB aggregation operations

### Data Models
MongoDB provides two data model designs for data modeling:
• Embedded data models.
• Normalized data models.

#### Embedded Data Models
In MongoDB, you can embed related data in a single document. This schema design is known as denormalized models.


![[Screenshot_81.png]]
### Normalized Data Models
Normalized data models describe relationships using references


![[Screenshot_82.png]]

Normalized data models can best be used in the following circumstances:
• When embedding data model results duplication of data.
• To represent complex many-to-many relationships.
• To model large hierarchical data sets.
Normalized data models do not provide good read performance.


## Data Model Using an Embedded Document

Step 1: One-to-One Relationships
```json
{
_id: "James",
name: "James William"
}
{
student_id: "James",
street: "123 Hill Street",
city: "New York",
state: "US",
}
```

Here, we have student and address relationships in which an address
belongs to the student. If we are going to retrieve address data with the
name frequently, then referencing requires multiple queries to resolve
references. In this scenario, we can embed address data with the student
data to provide a better data model, as shown here.

```json
{
_id: "James",
name: "James William",
address: {
street: "123 Hill Street",
city: "New York",
state: "US",
}
}
```

Step 2: One-to-Many Relationships

```json
{
_id: "James",
name: "James William"
}
{
student_id: "James",
street: "123 Hill Street",
city: "New York",
state: "US",
}
{
student_id: "James",
street: "234 Thomas Street",
city: "New Jersey",
state: "US",
}
```

Here, we have a student and multiple address relationships (a student
has multiple addresses). If we are going to retrieve address data with the
name frequently, then referencing requires multiple queries to resolve
references. In this scenario, the optimal way to design the schema is to
embed address data with the student data as shown here.
```json
{
_id: "James",
name: "James William",
address: [{
street: "123 Hill Street",
city: "New York",
state: "US",
},
{
street: "234 Thomas Street",
city: "New Jersey",
state: "US",
}]
}
```


### Data Model Using Document References


Step 1: One-to-Many Relationships

```json
{
title: "Practical Apache Spark",
author: [ "Subhashini Chellappan", "Dharanitharan Ganesan" ],
published_date: ISODate("2018-11-30"),
pages: 300,
language: "English",
publisher: {
name: "Apress",
founded: 1999,
location: "US"
}
}
```

Here, the publisher document is embedded inside the book document,
which leads to repetition of the publisher data model.
In this scenario, we can document references to avoid repetition of
data. In document references, the growth of relationships determines
where to store the references. If the number of books per publisher is
small, then we can store the book reference inside the publisher document as shown here.

```json
{
name: "Apress",
founded: 1999,
location: "US",
books: [123456, 456789, ...]
}
{
_id: 123456,
title: "Practical Apache Spark",
author: [ "Subhashini Chellappan", "Dharanitharan Ganesan"
],
published_date: ISODate("2018-11-30"),
pages: 300,
language: "English"
}
{
_id: 456789,
title: "MongoDB Recipes",
author: [ "Subhashini Chellappan"],
published_date: ISODate("2018-11-30"),
pages: 120,
language: "English"
}
```




## SQL Aggregation Terms and Corresponding MongoDB Aggregation Operators



| SQL term | MongoDB Operator |
| -------- | ---------------- |
| WHERE    | $match           |
| GROUP BY | $group           |
| HAVING   | $match           |
| SELECT   | $project         |
| ORDER BY | $sort            |
| LIMIT    | $limit           |
| SUM      | $sum<br>         |
| COUNT    | $sum             |
| JOIN     | $lookup          |
|          |                  |

```js
db.orders.find()
```

count 
```sql
SELECT COUNT(*) AS count FROM orders
```

mongoCount 

```json 
db.orders.aggregate( [ { $group: { _id: null, count: {
$sum: 1 } } } ] )
```