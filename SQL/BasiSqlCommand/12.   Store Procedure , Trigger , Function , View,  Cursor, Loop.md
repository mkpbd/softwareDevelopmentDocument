

## What Is a Trigger in SQL?

In SQL, a trigger is a database object containing SQL code that is automatically executed when a specific database event occurs. In other words, a database trigger is "triggered" by a particular event.

SQL triggers are generally associated with a particular table. This means that when the table is deleted, all its associated triggers are deleted accordingly. Given a table, an SQL trigger can be invoked before or after the following events:

- `INSERT`: a new row is inserted in the table.
- `UPDATE`: an existing row of the table gets updated.
- `DELETE`: a row in the table gets deleted.

Thus, when an `INSERT`, `UPDATE`, or `DELETE` SQL query is performed, the RDBMS takes care of automatically firing the corresponding trigger.

Let's learn more about what types of SQL triggers are available.


## Types of SQL Triggers

There are two types of triggers: **row-level triggers** and **statement-level triggers**. Let’s dig into them.

### Row-Level Triggers

A row-level trigger is executed once for each row affected by the triggering event, which is typically an `INSERT`, `UPDATE`, or `DELETE` statement.

For example, let’s assume you defined an `INSERT` trigger for a table. Then, you add several rows to that table with a single query. So, the row trigger will be automatically fired for each new row.

Row-level triggers are particularly useful to enforce business rules, maintain database integrity, and automatically perform SQL tasks. At the same time, they can have a significant impact on the performance of a database. This is especially true if they are used extensively or contain complex queries. So, you need to use row-level triggers only when really necessary.

### Statement-Level Triggers

A statement-level trigger is executed once for the entire triggering event, instead of once for each row affected by the event. Statement-level triggers are useful to perform an action based on the overall effect of an `INSERT`, `UPDATE`, or `DELETE` statement, rather than on individual rows.


## Use Cases for SQL Triggers

### Automating tasks

Triggers are great for automating tasks in a database and avoiding performing scheduling tasks. For example, you can use SQL triggers to automatically log data, update a data aggregation table, or populate a user notification table.

### Maintaining database integrity

Triggers can be used to ensure that data in a database remains consistent and accurate. For example, you can define an SQL trigger to make sure a foreign key is copied in a summary table when a new record is inserted.

### How To Create a SQL Trigger

```sql 
CREATE
    [DEFINER = user]
    TRIGGER [IF NOT EXISTS] <trigger_name> 
    <trigger_time> <trigger_event> 
    ON <table_name> FOR EACH ROW
    [<trigger_order>]
    <trigger_body>
```
- `<trigger_name>` is the name given to the trigger.
- `<trigger_time>` can have two values - BEFORE or AFTER - they define when the trigger should be invoked.
- `<trigger_event>` can be INSERT, UPDATE, or DELETE and defines the database event that fires the trigger.
- `<table_name>` is the table to associate with the trigger.
- `<trigger_body>` has FOLLOWS | PRECEDES syntax and allows you to define the order of execution of triggers in a table in case there are multiple triggers.
- `<trigger_body>` is the SQL code that is executed when the trigger is invoked.

When `<trigger_event>` occurs on the `<table_name>` table, the `<trigger_name>` trigger will be executed on <trigger_time>. In detail, MySQL will run the SQL code. This is how a trigger works in SQL.

### Example of an INSERT trigger

```sql
CREATE TRIGGER log_user_data
AFTER INSERT ON users
FOR EACH ROW
BEGIN
    INSERT INTO user_creation_log(id, created_at, created_by)
    VALUES (NEW.id, NOW(), NEW.created_by)
END;
```

This trigger will be fired whenever a new record is inserted into the `users` table. In detail, it automatically logs some data into the `user_creation_log` table. Note that `NEW.id` and `NEW.created_by` refer to the values of the id and `created_by` columns of the new row that was just inserted into the `users` table.


Trigger    : https://www.javatpoint.com/triggers-in-sql-server

https://www.geeksforgeeks.org/sql-trigger-book-management-database/?ref=ml_lbp

https://www.c-sharpcorner.com/UploadFile/63f5c2/triggers-in-sql-server/
https://www.freecodecamp.org/news/sql-triggers/


# Cursor in SQL

In SQL, a cursor is a temporary workstation that is allocated by the database server during the execution of a statement.

It is a database object that allows us to access data of one row at a time. This concept of SQL is useful when the user wants to update the rows of the table one by one.

The cursor in SQL is the same as the looping technique of other programming languages. The collection of tuples held by the cursor is known as the active set.

In SQL database systems, users define the cursor using DECLARE statement and take the SELECT statement as the parameter, which helps in returning the set of rows.

In this SQL article, we will learn about the types of a cursor, the life cycle of a cursor, syntax of a cursor, and the implementation of a cursor.

## Types of Cursor in SQL


Following are the two types of Cursor in Structured Query Language:

1. Implicit Cursor
2. Explicit Cursor

### Implicit Cursor

These types of cursors are generated and allocated by the SQL server when the system performs INSERT, DELETE, and UPDATE operations on SQL queries.

This cursor is also referred to as the default cursor in SQL.

An implicit cursor is also created by the system when the SELECT query selects the single row.

### Explicit Cursor

These types of cursors are created by the user using the SELECT query.

An explicit cursor holds multiple records but processes a single row at a time. It uses the pointer, which moves to another row after reading one row.

It is basically used for gaining extra control over the temporary workstation.

## Life Cycle of Cursor

The life cycle of the cursor is described into the following five stages:

1. Declare a Cursor
2. Open Cursor
3. Fetch Data from Cursor
4. Close Cursor Connection
5. Deallocate cursor

Let's discuss each stage in brief:

### 1. Declare a Cursor

First, we have to declare the cursor by using the following SQL syntax:

1. DECLARE Cursor_Name CURSOR FOR Select_Statement;  

In this syntax, we have to specify the name and data type of the cursor just after the DECLARE keyword. After that, we have to write the SELECT statement, which defines the result set for the cursor.

### 2. Open Cursor

It is the second stage that opens the cursor for storing the data retrieved from the result set. We can open the cursor by using the following SQL syntax:


1. OPEN Cursor_Name;  

### 3. Fetch Cursor

It is the third stage in the cursor life cycle that fetches the rows for performing the insertion, deletion, and updation operations on the currently active tuple in the cursor.

Following are the six options that are used in syntax for fetching data from the cursor:

**i. FIRST:** This option allows the system to access only the first record from the cursor table. The syntax for the FIRST option is given below:


1. FETCH FIRST FROM Cursor_Name;  

**ii. LAST:** This option allows the system to access only the last record from the cursor table. The syntax for the LAST option is as follows:



1. FETCH LAST FROM Cursor_Name;  

**iii. NEXT:** This method allows the system to access the data in the forward direction from the cursor table. It is the default option. The syntax of this method is as follows:


1. FETCH NEXT FROM Cursor_Name;  

**iv. PRIOR:** This method allows the system to access the data in the backward direction from the cursor table. The syntax of this option is as follows:


1. FETCH PRIOR FROM Cursor_Name;  

**v. ABSOLUTE n:** This method allows the system to access the data of the exact nth row from the cursor table. The syntax of this option is mentioned below:


1. FETCH ABSOLUTE n FROM Cursor_Name;  

**vi. RELATIVE n:** This method allows the system to access the data in both incremental and decremental processes. The syntax of this option is mentioned below:

1. FETCH RELATIVE n FROM Cursor_Name;  

### 4. Close Cursor

It is the fourth stage in the process of the cursor. When we complete the work with the cursor, we have to close the cursor in this stage. We can close the cursor in SQL by using the following query:

CLOSE Cursor_Name;

### 5. Deallocate Cursor

It is the last and fifth stage of the cursor life cycle. In this part, we have to erase the definition of the cursor and discharge all the system resources combined with the cursor.

## Syntax of a Cursor in SQL

```sql
1. DECLARE @YourVariables nvarchar(50)  //You have to declare all the required variables             
2. DECLARE My_Cursor_Name CURSOR    // You have to declare the Name of your Cursor  
3.[LOCAL | GLOBAL]                // You have to specify the Scope of your Cursor  
4. [FORWARD_ONLY | SCROLL]// You have to specify the movement direction of your Cursor  
5. [ KEYSET | DYNAMIC |STATIC | FAST_FORWARD]  // You have to specify the Basic type of your Cursor  
6. [  SCROLL_LOCKS | OPTIMISTIC |READ_ONLY ]  // You have to specify the Locks for your Cursor  
7. OPEN My_Cursor_Name  // You have to Open Your Cursor  
8. FETCH NEXT FROM My_Cursor_Name // This line fetches the data from your Cursor  
9. CLOSE My_Cursor_Name // Here, you have to close Your Cursor  
10. DEALLOCATE My_Cursor_Name // Here, you have to deallocate the cursor memory.
```



```sql 
 CREATE TABLE Student  
(  
Student_RollNo INT PRIMARY KEY,    
Student_Name nvarchar(60) NOT NULL,      
 Student_Course nvarchar(20) NOT NULL,        
 Student_Age INTNOT NULL,      
 Student_Marks INT NOT NULL  
) ;
```
```sql
INSERT INTO Student (Student_RollNo, Student_Name, Student_Course, Student_Age, Student_Marks) VALUES ( 1, Amit, BCA, 19, 88),  
 ( 2, Rahul, MCA, 21, 98),  
( 3, Jones, B.tech, 20, 93),  
 ( 4, Riya, BCA, 19, 89),  
 ( 5, Aaniya, BBA, 21, 92),  
 ( 6, Saket, MCA, 19, 95),  
 ( 7, Shobhit, MBA, 20, 90),  
 ( 8, Ishika, BCA, 21, 89),  
 ( 9, Parul, B.tech, 19, 91),  
 ( 10, Yukti, BCA, 20, 96);
```


### Cursor 

```sql 
DECLARE @Student_RollNo INT, @Student_Name NVARCHAR(50), @Student_Course NVARCHAR(50)     /*Here, we declare the variables for holding data.  */  
 /* Here, we declare and set counter */  
 DECLARE @Counter INT    
 SET @Counter = 1    
 PRINT '-------- Record of Students --------';  
/* Declare the cursor*/  
 DECLARE Print_Student_Details CURSOR    
FOR    
 SELECT Student_RollNo, Student_Name, Student_Course FROM Student    
 /* Open the cursor */  
 OPEN Print_Student_Details     
 /* Fetch the record from the cursor into the variables.  */  
 FETCH NEXT FROM Print_Student_Details INTO    
 @Student_RollNo, @Student_Name, @Student_Course    
 /* LOOP UNTIL RECORDS ARE AVAILABLE.  */  
 WHILE @@FETCH_STATUS = 0    
 BEGIN    
 IF @Counter = 1    
BEGIN    
PRINT 'Student_RollNo' + CHAR(9) + 'Student_Name' + CHAR(9) + CHAR(9) + 'Student_Course'  
 PRINT '--------------------------'  
 END    
/* This statement prints the current record */  
PRINT CAST(@ Student_RollNo AS NVARCHAR(10)) + CHAR(9) + @Student_Name + CHAR(9) + CHAR(9) + @Student_Course    
 /* This statement increments the counter variable */  
 SET @Counter = @Counter + 1  
 /* This statament fetch the next record into the variables. */    
FETCH NEXT FROM Print_Student_Details INTO  
 @Student_RollNo, @Student_Name, @Student_Course  
 END  
 /* This statement closes the cursor*/  
 CLOSE Print_Student_Details  
 /* This statement deallocates the cursor*/  
 DEALLOCATE Print_Student_Details
```


