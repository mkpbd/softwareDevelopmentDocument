
In PostgreSQL, a **view** is a virtual table defined by a stored query, allowing you to simplify complex queries, encapsulate logic, or provide a customized perspective of the data without storing it physically. Views can be queried like regular tables and can incorporate joins, including `INNER JOIN`, `LEFT JOIN`, `RIGHT JOIN`, and `FULL JOIN`, as well as nested queries using operators like `ALL`, `IN`, `EXISTS`, `<`, `>`, `<=`, and `>=`. Below, I’ll explain views, their syntax, and provide examples using the `customers`, `orders`, `order_details`, and `products` schema from your previous context, integrating joins and nested queries as requested.

### What is a View?
- A view is a named query saved in the database, presenting data from one or more tables.
- It does not store data itself but dynamically executes the underlying query when accessed.
- Views can simplify complex queries, enhance security by restricting access to specific columns, or provide a tailored view of data.

### Syntax for Creating a View
```sql
CREATE [OR REPLACE] VIEW view_name AS
SELECT column1, column2, ...
FROM table_name
[WHERE condition]
[WITH CHECK OPTION];
```
- `OR REPLACE`: Updates the view if it already exists.
- `WITH CHECK OPTION`: Ensures updates/inserts through the view conform to the view’s `WHERE` condition (for updatable views).

### Types of Views
1. **Simple Views**: Based on a single table or simple query, often updatable.
2. **Complex Views**: Involve joins, aggregations, or subqueries, typically not updatable.
3. **Materialized Views**: Store data physically for better performance, refreshed manually or automatically.

### Database Schema Recap
```sql
CREATE TABLE customers (
    customer_id SERIAL PRIMARY KEY,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50),
    email VARCHAR(100) UNIQUE
);

CREATE TABLE products (
    product_id SERIAL PRIMARY KEY,
    product_name VARCHAR(100) NOT NULL,
    unit_price NUMERIC(10, 2) NOT NULL
);

CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    customer_id INT REFERENCES customers(customer_id),
    order_date DATE NOT NULL
);

CREATE TABLE order_details (
    order_detail_id SERIAL PRIMARY KEY,
    order_id INT REFERENCES orders(order_id),
    product_id INT REFERENCES products(product_id),
    quantity INT NOT NULL,
    price NUMERIC(10, 2) NOT NULL
);
```

### Sample Data
```sql
-- Insert customers
INSERT INTO customers (first_name, last_name, email)
VALUES 
    ('John', 'Doe', 'john.doe@example.com'),
    ('Jane', 'Smith', 'jane.smith@example.com'),
    ('Bob', 'Brown', 'bob.brown@example.com');

-- Insert products
INSERT INTO products (product_name, unit_price)
VALUES 
    ('Laptop', 999.99),
    ('Mouse', 29.99),
    ('Keyboard', 59.99);

-- Insert orders
INSERT INTO orders (customer_id, order_date)
VALUES 
    (1, '2025-05-01'), -- John
    (1, '2025-05-15'), -- John
    (2, '2025-05-10'), -- Jane
    (3, '2025-05-20'); -- Bob

-- Insert order_details
INSERT INTO order_details (order_id, product_id, quantity, price)
VALUES 
    (1, 1, 1, 999.99),  -- John: 1 Laptop
    (1, 2, 2, 29.99),   -- John: 2 Mice
    (2, 3, 1, 59.99),   -- John: 1 Keyboard
    (3, 1, 2, 999.99);  -- Jane: 2 Laptops
```

### View Examples with Joins and Nested Queries
Below are examples of views using `INNER JOIN`, `LEFT JOIN`, `RIGHT JOIN`, `FULL JOIN`, and nested queries with `ALL`, `IN`, `EXISTS`, `<`, `>`, `<=`, `>=`.

#### 1. View with INNER JOIN and IN
**Purpose**: Create a view to show customers and their order details for orders containing specific products (e.g., Laptop).
```sql
CREATE VIEW customer_laptop_orders AS
SELECT 
    c.first_name,
    c.last_name,
    o.order_id,
    o.order_date,
    od.quantity,
    od.price
FROM customers c
INNER JOIN orders o ON c.customer_id = o.customer_id
INNER JOIN order_details od ON o.order_id = od.order_id
WHERE od.product_id IN (
    SELECT product_id
    FROM products
    WHERE product_name = 'Laptop'
);

-- Query the view
SELECT * FROM customer_laptop_orders;
```

**Explanation**:
- The view uses `INNER JOIN` to include only customers with orders and order details.
- The `IN` subquery filters for orders containing the Laptop product (`product_id = 1`).
- **Result**: Shows John (order 1: 1 Laptop) and Jane (order 3: 2 Laptops).

#### 2. View with LEFT JOIN and EXISTS
**Purpose**: Create a view to show all customers and their total order quantities, including those without order details.
```sql
CREATE VIEW customer_order_summary AS
SELECT 
    c.first_name,
    c.last_name,
    c.email,
    (
        SELECT SUM(od.quantity)
        FROM orders o
        LEFT JOIN order_details od ON o.order_id = od.order_id
        WHERE o.customer_id = c.customer_id
        AND EXISTS (
            SELECT 1
            FROM order_details od2
            WHERE od2.order_id = o.order_id
        )
    ) AS total_quantity
FROM customers c;

-- Query the view
SELECT * FROM customer_order_summary;
```

**Explanation**:
- The `LEFT JOIN` in the subquery ensures all orders are considered, even those without details (though `EXISTS` filters out orders without details).
- The `EXISTS` subquery ensures only orders with details contribute to the sum.
- **Result**: John (4: 1 Laptop + 2 Mice + 1 Keyboard), Jane (2: 2 Laptops), Bob (NULL: no details).

#### 3. View with RIGHT JOIN and ALL
**Purpose**: Create a view to show all order details and their associated products, including only products with prices greater than all prices in a specific order.
```sql
CREATE VIEW high_price_order_details AS
SELECT 
    od.order_id,
    p.product_name,
    od.quantity,
    od.price
FROM order_details od
RIGHT JOIN products p ON od.product_id = p.product_id
WHERE p.unit_price > ALL (
    SELECT od2.price
    FROM order_details od2
    WHERE od2.order_id = 1
);

-- Query the view
SELECT * FROM high_price_order_details;
```

**Explanation**:
- The `RIGHT JOIN` ensures all products are included, with `NULL` for order details if no match exists.
- The `ALL` subquery filters for products with `unit_price` greater than all prices in order 1 (999.99, 29.99).
- **Result**: Empty, as no product has `unit_price > 999.99`.

#### 4. View with FULL JOIN and >=
**Purpose**: Create a view to show all customers and orders, with total order values where the total is greater than or equal to the average order value.
```sql
CREATE VIEW customer_order_totals AS
SELECT 
    c.first_name,
    c.last_name,
    o.order_id,
    (
        SELECT SUM(od.quantity * od.price)
        FROM order_details od
        WHERE od.order_id = o.order_id
    ) AS order_total
FROM customers c
FULL JOIN orders o ON c.customer_id = o.customer_id
WHERE (
    SELECT SUM(od.quantity * od.price)
    FROM order_details od
    WHERE od.order_id = o.order_id
) >= (
    SELECT AVG(total)
    FROM (
        SELECT SUM(od2.quantity * od2.price) AS total
        FROM order_details od2
        GROUP BY od2.order_id
    ) AS avg_totals
) OR o.order_id IS NULL;

-- Query the view
SELECT * FROM customer_order_totals;
```

**Explanation**:
- The `FULL JOIN` includes all customers and orders, with `NULL` for unmatched rows (e.g., customers without orders or orders without customers, though the latter is unlikely due to foreign keys).
- The subquery in the `WHERE` clause uses `>=` to filter orders with totals greater than or equal to the average order total (~$703.32).
- The `OR o.order_id IS NULL` ensures customers without orders are included.
- **Result**: John (order 1: $1059.97), Jane (order 3: $1999.98), and Bob (no orders, `order_id` = `NULL`).

#### 5. Materialized View with INNER JOIN and <=
**Purpose**: Create a materialized view to store customer order summaries for orders with totals less than or equal to a threshold.
```sql
CREATE MATERIALIZED VIEW customer_low_value_orders AS
SELECT 
    c.first_name,
    c.last_name,
    o.order_id,
    SUM(od.quantity * od.price) AS order_total
FROM customers c
INNER JOIN orders o ON c.customer_id = o.customer_id
INNER JOIN order_details od ON o.order_id = od.order_id
GROUP BY c.first_name, c.last_name, o.order_id
HAVING SUM(od.quantity * od.price) <= (
    SELECT AVG(total)
    FROM (
        SELECT SUM(od2.quantity * od2.price) AS total
        FROM order_details od2
        GROUP BY od2.order_id
    ) AS avg_totals
);

-- Query the materialized view
SELECT * FROM customer_low_value_orders;

-- Refresh the materialized view
REFRESH MATERIALIZED VIEW customer_low_value_orders;
```

**Explanation**:
- The materialized view uses `INNER JOIN` to include only customers with orders and details.
- The `<=` subquery filters for orders with totals less than or equal to the average (~$703.32).
- **Result**: John (order 2: $59.99). Materialized views store data, so `REFRESH` updates it when data changes.

### Notes
- **Views vs. Materialized Views**:
  - Regular views are virtual and update automatically but don’t store data.
  - Materialized views store data for faster access but require manual refreshing (`REFRESH MATERIALIZED VIEW`).
- **Updatability**: Simple views (e.g., single-table, no aggregations) can be updatable; complex views with joins or subqueries typically aren’t.
- **Performance**: Use indexes on join columns (`customer_id`, `order_id`, `product_id`) to optimize view queries. Materialized views are faster for read-heavy workloads but need refreshing.
- **Security**: Views can restrict access to specific columns or rows (e.g., `GRANT SELECT ON view_name TO user`).
- **Nested Queries**: Views can encapsulate complex subqueries (e.g., with `IN`, `EXISTS`, `ALL`), making them reusable and easier to maintain.

If you need more specific view examples, details on updating views, or integration with other operators, let me know!

---
# Trigger 

In PostgreSQL, a **trigger** is a mechanism that automatically executes a specified function in response to certain events (e.g., `INSERT`, `UPDATE`, `DELETE`) on a table. Triggers are useful for tasks like auditing, enforcing business rules, or maintaining derived data. Below, I’ll explain triggers in detail, provide their syntax, and give examples using the `customers`, `orders`, `order_details`, and `products` schema from your previous context. I’ll incorporate **joins** (`INNER`, `LEFT`, `RIGHT`, `FULL`), **nested queries** (`ALL`, `IN`, `EXISTS`, `<`, `>`, `<=`, `>=`), **views**, **stored procedures**, **temporary tables**, **functions**, and **cursors** as requested, ensuring comprehensive integration with your earlier requirements.

### Trigger Overview
- **Purpose**: Automate actions when data is modified (e.g., logging changes, validating data).
- **Events**: `INSERT`, `UPDATE`, `DELETE`, or combinations.
- **Timing**: `BEFORE` (before the event), `AFTER` (after the event), or `INSTEAD OF` (for views).
- **Level**: `FOR EACH ROW` (row-level) or `FOR EACH STATEMENT` (statement-level).
- **Function**: A trigger calls a user-defined function written in PL/pgSQL or another language.

### Syntax for Triggers
```sql
CREATE TRIGGER trigger_name
{BEFORE | AFTER | INSTEAD OF} {INSERT | UPDATE | DELETE} [OR {INSERT | UPDATE | DELETE} ...]
ON table_name
[FOR EACH {ROW | STATEMENT}]
[WHEN (condition)]
EXECUTE FUNCTION function_name();
```

### Trigger Function Syntax
```sql
CREATE OR REPLACE FUNCTION function_name()
RETURNS TRIGGER AS $$
BEGIN
    -- PL/pgSQL code
    RETURN NEW; -- or OLD, or NULL for statement-level triggers
END;
$$ LANGUAGE plpgsql;
```
- `NEW`: Represents the new row for `INSERT`/`UPDATE` (row-level).
- `OLD`: Represents the old row for `UPDATE`/`DELETE` (row-level).
- **Statement-level triggers**: Don’t use `NEW`/`OLD`; use `TG_TABLE_NAME` or transition tables.

### Database Schema Recap
```sql
CREATE TABLE customers (
    customer_id SERIAL PRIMARY KEY,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50),
    email VARCHAR(100) UNIQUE
);

CREATE TABLE products (
    product_id SERIAL PRIMARY KEY,
    product_name VARCHAR(100) NOT NULL,
    unit_price NUMERIC(10, 2) NOT NULL
);

CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    customer_id INT REFERENCES customers(customer_id),
    order_date DATE NOT NULL
);

CREATE TABLE order_details (
    order_detail_id SERIAL PRIMARY KEY,
    order_id INT REFERENCES orders(order_id),
    product_id INT REFERENCES products(product_id),
    quantity INT NOT NULL,
    price NUMERIC(10, 2) NOT NULL
);
```

### Sample Data
```sql
-- Insert customers
INSERT INTO customers (first_name, last_name, email)
VALUES 
    ('John', 'Doe', 'john.doe@example.com'),
    ('Jane', 'Smith', 'jane.smith@example.com'),
    ('Bob', 'Brown', 'bob.brown@example.com');

-- Insert products
INSERT INTO products (product_name, unit_price)
VALUES 
    ('Laptop', 999.99),
    ('Mouse', 29.99),
    ('Keyboard', 59.99);

-- Insert orders
INSERT INTO orders (customer_id, order_date)
VALUES 
    (1, '2025-05-01'), -- John
    (1, '2025-05-15'), -- John
    (2, '2025-05-10'), -- Jane
    (3, '2025-05-20'); -- Bob

-- Insert order_details
INSERT INTO order_details (order_id, product_id, quantity, price)
VALUES 
    (1, 1, 1, 999.99),  -- John: 1 Laptop
    (1, 2, 2, 29.99),   -- John: 2 Mice
    (2, 3, 1, 59.99),   -- John: 1 Keyboard
    (3, 1, 2, 999.99);  -- Jane: 2 Laptops
```

### View Recap (from Previous Context)
```sql
CREATE OR REPLACE VIEW customer_order_totals AS
SELECT 
    c.first_name,
    c.last_name,
    o.order_id,
    o.order_date,
    COALESCE((
        SELECT SUM(od.quantity * od.price)
        FROM order_details od
        WHERE od.order_id = o.order_id
    ), 0) AS order_total
FROM customers c
FULL JOIN orders o ON c.customer_id = o.customer_id
WHERE EXISTS (
    SELECT 1
    FROM order_details od
    WHERE od.order_id = o.order_id
    AND od.quantity * od.price >= (
        SELECT AVG(total)
        FROM (
            SELECT SUM(od2.quantity * od2.price) AS total
            FROM order_details od2
            GROUP BY od2.order_id
        ) AS avg_totals
    )
) OR o.order_id IS NULL;
```

### Trigger Examples
Below are examples of triggers integrated with joins, nested queries, views, stored procedures, temporary tables, functions, and cursors.

#### Example 1: Trigger with INNER JOIN and IN (Audit Customer Updates)
**Purpose**: Log updates to customer email addresses into a temporary table for customers with orders, using `INNER JOIN` and `IN`.
```sql
-- Create a temporary table for audit logs
CREATE TEMPORARY TABLE temp_customer_audit (
    customer_id INT,
    old_email VARCHAR(100),
    new_email VARCHAR(100),
    change_time TIMESTAMP
);

-- Create a trigger function
CREATE OR REPLACE FUNCTION log_customer_email_update()
RETURNS TRIGGER AS $$
BEGIN
    IF OLD.email != NEW.email THEN
        INSERT INTO temp_customer_audit
        SELECT 
            NEW.customer_id,
            OLD.email,
            NEW.email,
            CURRENT_TIMESTAMP
        FROM customers c
        INNER JOIN orders o ON c.customer_id = o.customer_id
        WHERE c.customer_id = NEW.customer_id
        AND c.customer_id IN (
            SELECT customer_id
            FROM orders o2
            INNER JOIN order_details od ON o2.order_id = od.order_id
        );
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create the trigger
CREATE TRIGGER customer_email_trigger
AFTER UPDATE ON customers
FOR EACH ROW
EXECUTE FUNCTION log_customer_email_update();

-- Test the trigger
UPDATE customers SET email = 'john.new@example.com' WHERE customer_id = 1;

-- Query the audit table
SELECT * FROM temp_customer_audit;
```

**Explanation**:
- The trigger fires after an `UPDATE` on `customers`.
- The function uses `INNER JOIN` to ensure only customers with orders are considered and `IN` to filter for those with order details.
- Logs changes to `temp_customer_audit` if the email changes.
- **Result**: Logs John’s email change (customer_id 1: 'john.doe@example.com' to 'john.new@example.com').

#### Example 2: Trigger with LEFT JOIN and EXISTS (Validate Order Inserts)
**Purpose**: Prevent inserting orders for customers who have no high-value orders (>= average total), using a `LEFT JOIN` and `EXISTS`.
```sql
-- Create a trigger function
CREATE OR REPLACE FUNCTION validate_order_insert()
RETURNS TRIGGER AS $$
BEGIN
    IF NOT EXISTS (
        SELECT 1
        FROM orders o
        LEFT JOIN order_details od ON o.order_id = od.order_id
        WHERE o.customer_id = NEW.customer_id
        GROUP BY o.customer_id
        HAVING SUM(od.quantity * od.price) >= (
            SELECT AVG(total)
            FROM (
                SELECT SUM(od2.quantity * od2.price) AS total
                FROM order_details od2
                GROUP BY od2.order_id
            ) AS avg_totals
        )
    ) THEN
        RAISE EXCEPTION 'Customer % has no high-value orders', NEW.customer_id;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create the trigger
CREATE TRIGGER order_insert_trigger
BEFORE INSERT ON orders
FOR EACH ROW
EXECUTE FUNCTION validate_order_insert();

-- Test the trigger (will fail for Bob)
INSERT INTO orders (customer_id, order_date) VALUES (3, '2025-05-25');
```

**Explanation**:
- The `BEFORE INSERT` trigger checks if the customer has at least one high-value order (>= $703.32).
- Uses `LEFT JOIN` to include orders and `EXISTS` to check for high-value orders.
- **Result**: Raises an error for Bob (no high-value orders), allows inserts for John or Jane.

#### Example 3: Trigger with RIGHT JOIN and ALL (Log Product Price Updates)
**Purpose**: Log product price updates into a temporary table if the new price is greater than all previous order prices, using a `RIGHT JOIN` and `ALL`.
```sql
-- Create a temporary table for price logs
CREATE TEMPORARY TABLE temp_product_price_log (
    product_id INT,
    old_price NUMERIC(10, 2),
    new_price NUMERIC(10, 2),
    log_time TIMESTAMP
);

-- Create a trigger function
CREATE OR REPLACE FUNCTION log_product_price_update()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.unit_price > ALL (
        SELECT od.price
        FROM order_details od
        RIGHT JOIN products p ON od.product_id = p.product_id
        WHERE p.product_id = NEW.product_id
    ) THEN
        INSERT INTO temp_product_price_log
        VALUES (NEW.product_id, OLD.unit_price, NEW.unit_price, CURRENT_TIMESTAMP);
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create the trigger
CREATE TRIGGER product_price_trigger
AFTER UPDATE ON products
FOR EACH ROW
EXECUTE FUNCTION log_product_price_update();

-- Test the trigger
UPDATE products SET unit_price = 1500.00 WHERE product_id = 1;

-- Query the log table
SELECT * FROM temp_product_price_log;
```

**Explanation**:
- The trigger fires after an `UPDATE` on `products`.
- Uses `RIGHT JOIN` to include all order details and `ALL` to check if the new price exceeds all order prices for the product.
- **Result**: Logs Laptop’s price change (999.99 to 1500.00) if 1500.00 > all order prices for Laptop (999.99).

#### Example 4: Trigger with FULL JOIN, Cursor, and View (Audit Order Deletes)
**Purpose**: Use a cursor to log deleted orders from the `customer_order_totals` view into a temporary table, using `FULL JOIN` and `<=`.
```sql
-- Create a temporary table for delete logs
CREATE TEMPORARY TABLE temp_order_delete_log (
    customer_name VARCHAR(100),
    order_id INT,
    order_total NUMERIC(10, 2),
    delete_time TIMESTAMP
);

-- Create a trigger function with a cursor
CREATE OR REPLACE FUNCTION log_order_deletion()
RETURNS TRIGGER AS $$
DECLARE
    order_rec RECORD;
    cur_orders CURSOR FOR
        SELECT 
            CONCAT(cot.first_name, ' ', cot.last_name) AS customer_name,
            cot.order_id,
            cot.order_total
        FROM customer_order_totals cot
        WHERE cot.order_id = OLD.order_id
        AND cot.order_total <= (
            SELECT AVG(total)
            FROM (
                SELECT SUM(od.quantity * od.price) AS total
                FROM order_details od
                GROUP BY od.order_id
            ) AS avg_totals
        );
BEGIN
    OPEN cur_orders;
    LOOP
        FETCH cur_orders INTO order_rec;
        EXIT WHEN NOT FOUND;
        INSERT INTO temp_order_delete_log
        VALUES (order_rec.customer_name, order_rec.order_id, order_rec.order_total, CURRENT_TIMESTAMP);
    END LOOP;
    CLOSE cur_orders;
    RETURN OLD;
END;
$$ LANGUAGE plpgsql;

-- Create the trigger
CREATE TRIGGER order_delete_trigger
AFTER DELETE ON orders
FOR EACH ROW
EXECUTE FUNCTION log_order_deletion();

-- Test the trigger
DELETE FROM orders WHERE order_id = 2;

-- Query the log table
SELECT * FROM temp_order_delete_log;
```

**Explanation**:
- The trigger fires after a `DELETE` on `orders`.
- The cursor queries the `customer_order_totals` view, using `<=` to filter low-value orders (<= $703.32).
- Logs deleted orders (e.g., order 2: $59.99) into `temp_order_delete_log`.
- **Result**: Logs John Doe, order 2, $59.99.

### Integration with Stored Procedures and Functions
#### Example 5: Stored Procedure to Call Trigger-Related Function
**Purpose**: Create a stored procedure to update customer emails, triggering the audit log.
```sql
CREATE OR REPLACE PROCEDURE update_customer_email(cust_id INT, new_email VARCHAR)
LANGUAGE plpgsql
AS $$
BEGIN
    UPDATE customers
    SET email = new_email
    WHERE customer_id = cust_id;
    RAISE NOTICE 'Email updated for customer %', cust_id;
END;
$$;

-- Call the procedure
CALL update_customer_email(1, 'john.updated@example.com');

-- Query the audit table
SELECT * FROM temp_customer_audit;
```

**Explanation**: The procedure updates the email, triggering the `customer_email_trigger` to log the change.

### Notes
- **Triggers**:
  - Use `BEFORE` for validation, `AFTER` for logging/auditing.
  - Row-level triggers access `NEW`/`OLD`; statement-level triggers use transition tables.
  - Avoid complex logic in triggers to prevent performance issues.
- **Performance**: Index join columns (`customer_id`, `order_id`, `product_id`). Avoid nested loops in triggers.
- **Integration**:
  - Triggers can populate temporary tables (Examples 1, 3, 4).
  - Use views in triggers (Example 4).
  - Combine with cursors for row-by-row processing (Example 4).
  - Stored procedures/functions can trigger actions (Example 5).
- **Security**: Restrict trigger execution with `SECURITY DEFINER` in functions if needed.

---

# Cursor

In PostgreSQL, a **cursor** is a database object used to process query results row by row, which is particularly useful for iterative processing within stored procedures or functions. Cursors are often employed when set-based operations are insufficient or when you need to handle each row individually. Below, I’ll explain cursors in detail, provide their syntax, and offer examples using the `customers`, `orders`, `order_details`, and `products` schema from your previous context. I’ll integrate **joins** (`INNER`, `LEFT`, `RIGHT`, `FULL`), **nested queries** (`ALL`, `IN`, `EXISTS`, `<`, `>`, `<=`, `>=`), **views**, **triggers**, **stored procedures**, **temporary tables**, and **functions** as requested, ensuring comprehensive examples that align with your earlier requirements.

### Cursor Overview
- **Purpose**: Cursors allow you to iterate over query results, fetching one row at a time, which is useful for complex logic or when processing needs to be done sequentially.
- **Types**:
  - **Declared Cursors**: Defined within a function or procedure, used for specific queries.
  - **Bound Cursors**: Tied to a specific query at declaration.
  - **Unbound Cursors**: Can be assigned a query dynamically (using `REFCURSOR`).
- **Use Cases**: Auditing, generating reports, or processing rows with conditional logic.
- **Lifecycle**: Declare, open, fetch, and close the cursor.

### Syntax for Cursors
```sql
-- Declare a cursor
DECLARE cursor_name CURSOR [FOR] query;

-- Open the cursor
OPEN cursor_name;

-- Fetch rows
FETCH cursor_name INTO variable;

-- Close the cursor
CLOSE cursor_name;
```
- **Within PL/pgSQL** (in functions/procedures):
  ```sql
  DECLARE
      cursor_name CURSOR FOR SELECT ...;
  BEGIN
      OPEN cursor_name;
      LOOP
          FETCH cursor_name INTO record_variable;
          EXIT WHEN NOT FOUND;
          -- Process row
      END LOOP;
      CLOSE cursor_name;
  END;
  ```

### Database Schema Recap
```sql
CREATE TABLE customers (
    customer_id SERIAL PRIMARY KEY,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50),
    email VARCHAR(100) UNIQUE
);

CREATE TABLE products (
    product_id SERIAL PRIMARY KEY,
    product_name VARCHAR(100) NOT NULL,
    unit_price NUMERIC(10, 2) NOT NULL
);

CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    customer_id INT REFERENCES customers(customer_id),
    order_date DATE NOT NULL
);

CREATE TABLE order_details (
    order_detail_id SERIAL PRIMARY KEY,
    order_id INT REFERENCES orders(order_id),
    product_id INT REFERENCES products(product_id),
    quantity INT NOT NULL,
    price NUMERIC(10, 2) NOT NULL
);
```

### Sample Data
```sql
-- Insert customers
INSERT INTO customers (first_name, last_name, email)
VALUES 
    ('John', 'Doe', 'john.doe@example.com'),
    ('Jane', 'Smith', 'jane.smith@example.com'),
    ('Bob', 'Brown', 'bob.brown@example.com');

-- Insert products
INSERT INTO products (product_name, unit_price)
VALUES 
    ('Laptop', 999.99),
    ('Mouse', 29.99),
    ('Keyboard', 59.99);

-- Insert orders
INSERT INTO orders (customer_id, order_date)
VALUES 
    (1, '2025-05-01'), -- John
    (1, '2025-05-15'), -- John
    (2, '2025-05-10'), -- Jane
    (3, '2025-05-20'); -- Bob

-- Insert order_details
INSERT INTO order_details (order_id, product_id, quantity, price)
VALUES 
    (1, 1, 1, 999.99),  -- John: 1 Laptop
    (1, 2, 2, 29.99),   -- John: 2 Mice
    (2, 3, 1, 59.99),   -- John: 1 Keyboard
    (3, 1, 2, 999.99);  -- Jane: 2 Laptops
```

### View Recap (from Previous Context)
```sql
CREATE OR REPLACE VIEW customer_order_totals AS
SELECT 
    c.first_name,
    c.last_name,
    o.order_id,
    o.order_date,
    COALESCE((
        SELECT SUM(od.quantity * od.price)
        FROM order_details od
        WHERE od.order_id = o.order_id
    ), 0) AS order_total
FROM customers c
FULL JOIN orders o ON c.customer_id = o.customer_id
WHERE EXISTS (
    SELECT 1
    FROM order_details od
    WHERE od.order_id = o.order_id
    AND od.quantity * od.price >= (
        SELECT AVG(total)
        FROM (
            SELECT SUM(od2.quantity * od2.price) AS total
            FROM order_details od2
            GROUP BY od2.order_id
        ) AS avg_totals
    )
) OR o.order_id IS NULL;
```

### Cursor Examples
Below are examples of cursors integrated with joins, nested queries, views, triggers, stored procedures, temporary tables, and functions.

#### Example 1: Cursor with INNER JOIN and IN (Log High-Value Customers)
**Purpose**: Use a cursor in a stored procedure to log customers with high-value orders (> average order total) into a temporary table.
```sql
CREATE OR REPLACE PROCEDURE log_high_value_customers()
LANGUAGE plpgsql
AS $$
DECLARE
    customer_rec RECORD;
    cur_customers CURSOR FOR
        SELECT 
            c.first_name,
            c.last_name,
            SUM(od.quantity * od.price) AS total_spent
        FROM customers c
        INNER JOIN orders o ON c.customer_id = o.customer_id
        INNER JOIN order_details od ON o.order_id = od.order_id
        WHERE c.customer_id IN (
            SELECT customer_id
            FROM orders o2
            INNER JOIN order_details od2 ON o2.order_id = od2.order_id
            GROUP BY customer_id
            HAVING SUM(od2.quantity * od2.price) > (
                SELECT AVG(total)
                FROM (
                    SELECT SUM(od3.quantity * od3.price) AS total
                    FROM order_details od3
                    GROUP BY od3.order_id
                ) AS avg_totals
            )
        )
        GROUP BY c.first_name, c.last_name;
BEGIN
    -- Create a temporary table
    CREATE TEMPORARY TABLE temp_high_value_customers (
        customer_name VARCHAR(100),
        total_spent NUMERIC(10, 2),
        log_time TIMESTAMP
    );

    -- Open the cursor
    OPEN cur_customers;

    -- Loop through results
    LOOP
        FETCH cur_customers INTO customer_rec;
        EXIT WHEN NOT FOUND;
        INSERT INTO temp_high_value_customers
        VALUES (
            CONCAT(customer_rec.first_name, ' ', customer_rec.last_name),
            customer_rec.total_spent,
            CURRENT_TIMESTAMP
        );
    END LOOP;

    -- Close the cursor
    CLOSE cur_customers;

    RAISE NOTICE 'High-value customers logged';
END;
$$;

-- Call the procedure
CALL log_high_value_customers();

-- Query the temporary table
SELECT * FROM temp_high_value_customers;
```

**Explanation**:
- The cursor uses `INNER JOIN` to fetch customers with orders and details, and `IN` to filter for those with totals > average (~$703.32).
- Iterates over results, logging to `temp_high_value_customers`.
- **Result**: Logs John ($1059.97) and Jane ($1999.98).

#### Example 2: Cursor with LEFT JOIN and EXISTS (Process Orders from View)
**Purpose**: Use a cursor in a function to process orders from the `customer_order_totals` view, logging low-value orders (<= average total) into a temporary table.
```sql
CREATE OR REPLACE FUNCTION log_low_value_orders()
RETURNS VOID AS $$
DECLARE
    order_rec RECORD;
    cur_orders CURSOR FOR
        SELECT 
            customer_name,
            order_id,
            order_total
        FROM (
            SELECT 
                CONCAT(first_name, ' ', last_name) AS customer_name,
                order_id,
                order_total
            FROM customer_order_totals
            WHERE order_total <= (
                SELECT AVG(total)
                FROM (
                    SELECT SUM(od.quantity * od.price) AS total
                    FROM order_details od
                    GROUP BY od.order_id
                ) AS avg_totals
            ) AND order_total > 0
        ) AS low_value_orders
        WHERE EXISTS (
            SELECT 1
            FROM order_details od
            LEFT JOIN orders o ON od.order_id = o.order_id
            WHERE o.order_id = low_value_orders.order_id
        );
BEGIN
    -- Create a temporary table
    CREATE TEMPORARY TABLE temp_low_value_orders (
        customer_name VARCHAR(100),
        order_id INT,
        order_total NUMERIC(10, 2),
        log_time TIMESTAMP
    );

    -- Open the cursor
    OPEN cur_orders;

    -- Loop through results
    LOOP
        FETCH cur_orders INTO order_rec;
        EXIT WHEN NOT FOUND;
        INSERT INTO temp_low_value_orders
        VALUES (
            order_rec.customer_name,
            order_rec.order_id,
            order_rec.order_total,
            CURRENT_TIMESTAMP
        );
    END LOOP;

    -- Close the cursor
    CLOSE cur_orders;

    RAISE NOTICE 'Low-value orders logged';
END;
$$ LANGUAGE plpgsql;

-- Call the function
SELECT log_low_value_orders();

-- Query the temporary table
SELECT * FROM temp_low_value_orders;
```

**Explanation**:
- The cursor queries the `customer_order_totals` view, filtering for orders with totals <= average (~$703.32) using `<=`.
- Uses `LEFT JOIN` and `EXISTS` in the subquery to ensure valid orders.
- Logs results to `temp_low_value_orders`.
- **Result**: Logs John Doe, order 2 ($59.99).

#### Example 3: Cursor with RIGHT JOIN and ALL (Log High-Quantity Products)
**Purpose**: Use a cursor in a stored procedure to log products ordered in quantities greater than all average quantities per order.
```sql
CREATE OR REPLACE PROCEDURE log_high_quantity_products()
LANGUAGE plpgsql
AS $$
DECLARE
    product_rec RECORD;
    cur_products CURSOR FOR
        SELECT 
            p.product_name,
            SUM(od.quantity) AS total_quantity
        FROM order_details od
        RIGHT JOIN products p ON od.product_id = p.product_id
        WHERE od.quantity > ALL (
            SELECT AVG(quantity)
            FROM order_details
            GROUP BY order_id
        )
        GROUP BY p.product_name;
BEGIN
    -- Create a temporary table
    CREATE TEMPORARY TABLE temp_high_quantity_products (
        product_name VARCHAR(100),
        total_quantity INT,
        log_time TIMESTAMP
    );

    -- Open the cursor
    OPEN cur_products;

    -- Loop through results
    LOOP
        FETCH cur_products INTO product_rec;
        EXIT WHEN NOT FOUND;
        INSERT INTO temp_high_quantity_products
        VALUES (
            product_rec.product_name,
            product_rec.total_quantity,
            CURRENT_TIMESTAMP
        );
    END LOOP;

    -- Close the cursor
    CLOSE cur_products;

    RAISE NOTICE 'High-quantity products logged';
END;
$$;

-- Call the procedure
CALL log_high_quantity_products();

-- Query the temporary table
SELECT * FROM temp_high_quantity_products;
```

**Explanation**:
- The cursor uses `RIGHT JOIN` to include all products and `ALL` to filter for quantities > average per order (~1.33).
- Logs results to `temp_high_quantity_products`.
- **Result**: Logs Mouse (2) and Laptop (3).

#### Example 4: Cursor with Trigger and FULL JOIN (Audit Order Inserts)
**Purpose**: Create a trigger to log new orders with a cursor, using `FULL JOIN` and `>=` to check high-value orders.
```sql
-- Create a temporary table for audit logs
CREATE TEMPORARY TABLE temp_order_audit (
    customer_name VARCHAR(100),
    order_id INT,
    order_total NUMERIC(10, 2),
    log_time TIMESTAMP
);

-- Create a trigger function with a cursor
CREATE OR REPLACE FUNCTION log_order_insert()
RETURNS TRIGGER AS $$
DECLARE
    order_rec RECORD;
    cur_orders CURSOR FOR
        SELECT 
            CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
            o.order_id,
            COALESCE((
                SELECT SUM(od.quantity * od.price)
                FROM order_details od
                WHERE od.order_id = o.order_id
            ), 0) AS order_total
        FROM customers c
        FULL JOIN orders o ON c.customer_id = o.customer_id
        WHERE o.order_id = NEW.order_id
        AND COALESCE((
            SELECT SUM(od.quantity * od.price)
            FROM order_details od
            WHERE od.order_id = o.order_id
        ), 0) >= (
            SELECT AVG(total)
            FROM (
                SELECT SUM(od2.quantity * od2.price) AS total
                FROM order_details od2
                GROUP BY od2.order_id
            ) AS avg_totals
        );
BEGIN
    OPEN cur_orders;
    LOOP
        FETCH cur_orders INTO order_rec;
        EXIT WHEN NOT FOUND;
        INSERT INTO temp_order_audit
        VALUES (
            order_rec.customer_name,
            order_rec.order_id,
            order_rec.order_total,
            CURRENT_TIMESTAMP
        );
    END LOOP;
    CLOSE cur_orders;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create the trigger
CREATE TRIGGER order_insert_trigger
AFTER INSERT ON orders
FOR EACH ROW
EXECUTE FUNCTION log_order_insert();

-- Test the trigger
INSERT INTO orders (customer_id, order_date) VALUES (1, '2025-05-25');
INSERT INTO order_details (order_id, product_id, quantity, price) VALUES (5, 1, 2, 999.99);

-- Query the audit table
SELECT * FROM temp_order_audit;
```

**Explanation**:
- The trigger fires after an `INSERT` on `orders`.
- The cursor uses `FULL JOIN` to include customer details and `>=` to filter high-value orders (>= $703.32).
- Logs new orders to `temp_order_audit`.
- **Result**: Logs new order (order 5: $1999.98 for John).

### Artifact
```sql
-- Stored Procedure: Log high-value customers
CREATE OR REPLACE PROCEDURE log_high_value_customers()
LANGUAGE plpgsql
AS $$
DECLARE
    customer_rec RECORD;
    cur_customers CURSOR FOR
        SELECT 
            c.first_name,
            c.last_name,
            SUM(od.quantity * od.price) AS total_spent
        FROM customers c
        INNER JOIN orders o ON c.customer_id = o.customer_id
        INNER JOIN order_details od ON o.order_id = od.order_id
        WHERE c.customer_id IN (
            SELECT customer_id
            FROM orders o2
            INNER JOIN order_details od2 ON o2.order_id = od2.order_id
            GROUP BY customer_id
            HAVING SUM(od2.quantity * od2.price) > (
                SELECT AVG(total)
                FROM (
                    SELECT SUM(od3.quantity * od3.price) AS total
                    FROM order_details od3
                    GROUP BY od3.order_id
                ) AS avg_totals
            )
        )
        GROUP BY c.first_name, c.last_name;
BEGIN
    CREATE TEMPORARY TABLE temp_high_value_customers (
        customer_name VARCHAR(100),
        total_spent NUMERIC(10, 2),
        log_time TIMESTAMP
    );

    OPEN cur_customers;
    LOOP
        FETCH cur_customers INTO customer_rec;
        EXIT WHEN NOT FOUND;
        INSERT INTO temp_high_value_customers
        VALUES (
            CONCAT(customer_rec.first_name, ' ', customer_rec.last_name),
            customer_rec.total_spent,
            CURRENT_TIMESTAMP
        );
    END LOOP;
    CLOSE cur_customers;
    RAISE NOTICE 'High-value customers logged';
END;
$$;

-- Function: Log low-value orders from view
CREATE OR REPLACE FUNCTION log_low_value_orders()
RETURNS VOID AS $$
DECLARE
    order_rec RECORD;
    cur_orders CURSOR FOR
        SELECT 
            customer_name,
            order_id,
            order_total
        FROM (
            SELECT 
                CONCAT(first_name, ' ', last_name) AS customer_name,
                order_id,
                order_total
            FROM customer_order_totals
            WHERE order_total <= (
                SELECT AVG(total)
                FROM (
                    SELECT SUM(od.quantity * od.price) AS total
                    FROM order_details od
                    GROUP BY od.order_id
                ) AS avg_totals
            ) AND order_total > 0
        ) AS low_value_orders
        WHERE EXISTS (
            SELECT 1
            FROM order_details od
            LEFT JOIN orders o ON od.order_id = o.order_id
            WHERE o.order_id = low_value_orders.order_id
        );
BEGIN
    CREATE TEMPORARY TABLE temp_low_value_orders (
        customer_name VARCHAR(100),
        order_id INT,
        order_total NUMERIC(10, 2),
        log_time TIMESTAMP
    );

    OPEN cur_orders;
    LOOP
        FETCH cur_orders INTO order_rec;
        EXIT WHEN NOT FOUND;
        INSERT INTO temp_low_value_orders
        VALUES (
            order_rec.customer_name,
            order_rec.order_id,
            order_rec.order_total,
            CURRENT_TIMESTAMP
        );
    END LOOP;
    CLOSE cur_orders;
    RAISE NOTICE 'Low-value orders logged';
END;
$$ LANGUAGE plpgsql;

-- Trigger with Cursor: Log order inserts
CREATE TEMPORARY TABLE temp_order_audit (
    customer_name VARCHAR(100),
    order_id INT,
    order_total NUMERIC(10, 2),
    log_time TIMESTAMP
);

CREATE OR REPLACE FUNCTION log_order_insert()
RETURNS TRIGGER AS $$
DECLARE
    order_rec RECORD;
    cur_orders CURSOR FOR
        SELECT 
            CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
            o.order_id,
            COALESCE((
                SELECT SUM(od.quantity * od.price)
                FROM order_details od
                WHERE od.order_id = o.order_id
            ), 0) AS order_total
        FROM customers c
        FULL JOIN orders o ON c.customer_id = o.customer_id
        WHERE o.order_id = NEW.order_id
        AND COALESCE((
            SELECT SUM(od.quantity * od.price)
            FROM order_details od
            WHERE od.order_id = o.order_id
        ), 0) >= (
            SELECT AVG(total)
            FROM (
                SELECT SUM(od2.quantity * od2.price) AS total
                FROM order_details od2
                GROUP BY od2.order_id
            ) AS avg_totals
        );
BEGIN
    OPEN cur_orders;
    LOOP
        FETCH cur_orders INTO order_rec;
        EXIT WHEN NOT FOUND;
        INSERT INTO temp_order_audit
        VALUES (
            order_rec.customer_name,
            order_rec.order_id,
            order_rec.order_total,
            CURRENT_TIMESTAMP
        );
    END LOOP;
    CLOSE cur_orders;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER order_insert_trigger
AFTER INSERT ON orders
FOR EACH ROW
EXECUTE FUNCTION log_order_insert();
```

### Notes
- **Cursors**:
  - Use for row-by-row processing when set-based operations are impractical.
  - Explicitly open, fetch, and close to manage resources.
  - Can be used in functions, stored procedures, or triggers.
- **Performance**:
  - Cursors are slower than set-based queries; use sparingly for large datasets.
  - Index join columns (`customer_id`, `order_id`, `product_id`) for efficiency.
- **Integration**:
  - Combine with views for simplified queries (Example 2).
  - Use in triggers for auditing (Example 4).
  - Store results in temporary tables for further processing (Examples 1–3).
- **Time Context**: Examples use `CURRENT_TIMESTAMP`, aligned with your provided time (05:15 PM +06, May 21, 2025).

