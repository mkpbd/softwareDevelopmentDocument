
Here's a breakdown of the thinking process to generate the School Management System design:

1.  **Deconstruct the Request:**

    *   **Role:** System Designer
    *   **Goal:** Design a School Management System
    *   **Key Requirements:**
        *   Scalable
        *   Robust
        *   Technologies: C#, .NET (implicitly .NET Core/.NET 5+ for Web API & EF Core), Web API, EF Core
        *   Output: Design, Project Architecture, Generate Code (sample)

2.  **Core Functionalities of a School Management System (Brainstorming):**

    *   Student Management (Enrollment, Info, Attendance, Grades)
    *   Teacher Management (Info, Assignments, Classes)
    *   Course Management (Subjects, Curriculum)
    *   Class Management (Schedules, Sections)
    *   Attendance Tracking
    *   Grading/Report Cards
    *   Parent Portal (View student progress, attendance)
    *   Admin Portal (User management, system settings)
    *   Communication (Announcements, messages)
    *   Timetable Management
    *   Fee Management (Optional, but common)
    *   Library Management (Optional)
    *   Exam Management

3.  **Architectural Considerations (High-Level):**

    *   **Layered Architecture:** This is a standard for maintainability and separation of concerns.
        *   Presentation (API for now, could be a UI later)
        *   Application/Business Logic
        *   Domain (Core entities and rules)
        *   Infrastructure (Database, external services)
    *   **Clean Architecture / Onion Architecture:** A more refined version of layered, emphasizing dependency inversion. The Domain is at the core, with other layers depending inward. This is good for testability and decoupling.
    *   **Microservices (Scalability):** While a monolithic start is fine, think about how it *could* be broken down later if extreme scalability is needed (e.g., separate services for Attendance, Grading, User Management). For now, a well-structured monolith is a good starting point.
    *   **Database:** Relational (SQL Server, PostgreSQL) is a natural fit for structured school data. EF Core is specified, so this aligns.
    *   **API Design:** RESTful principles.

4.  **Technology Choices (Confirming from Request):**

    *   **Backend:** C#, .NET (ASP.NET Core Web API)
    *   **ORM:** Entity Framework Core
    *   **Database:** (Implied by EF Core, let's assume SQL Server for example, but make it configurable).
    *   **Authentication/Authorization:** ASP.NET Core Identity, JWT.
    *   **Frontend (Not explicitly requested for backend design, but good to keep in mind):** Could be anything (React, Angular, Vue, Blazor). The API should be frontend-agnostic.

5.  **Project Structure (Mapping to Clean Architecture):**

    *   `SchoolManagement.Domain`: Entities, Enums, Domain Services (if any), Interfaces for Repositories. No external dependencies.
    *   `SchoolManagement.Application`: Application Services (use cases), DTOs, Interfaces for Infrastructure services (e.g., IEmailService), Validation, MediatR (CQRS pattern). Depends on Domain.
    *   `SchoolManagement.Infrastructure`: EF Core DbContext, Repositories implementation, Email Service implementation, other external service integrations. Depends on Application (interfaces).
    *   `SchoolManagement.Api`: ASP.NET Core Web API project. Controllers, Middleware, Startup/Program.cs configuration. Depends on Application and Infrastructure (for DI).
    *   `SchoolManagement.Tests`: Unit tests, Integration tests.

6.  **Key Design Decisions for Scalability & Robustness:**

    *   **Asynchronous Operations:** `async/await` throughout (especially for I/O like DB access).
    *   **Dependency Injection (DI):** Built into ASP.NET Core. Essential for loose coupling and testability.
    *   **CQRS (Command Query Responsibility Segregation):** Using MediatR can simplify application services. Commands for writes, Queries for reads. Good for scaling different parts of the system.
    *   **Error Handling:** Global exception handling middleware. Consistent error responses.
    *   **Logging:** Serilog or NLog.
    *   **Configuration:** `appsettings.json` and environment variables.
    *   **Caching:** For frequently accessed, rarely changing data (e.g., list of subjects, school years).
    *   **Background Jobs:** (e.g., Hangfire) for tasks like sending bulk emails, report generation.
    *   **Database Migrations:** EF Core Migrations.
    *   **Security:**
        *   Authentication (ASP.NET Core Identity + JWT).
        *   Authorization (Role-based, Policy-based).
        *   Input Validation (FluentValidation).
        *   HTTPS.
        *   Protection against common web vulnerabilities (OWASP Top 10).

7.  **Database Schema (High-Level Entities - initial thoughts):**

    *   `User` (Id, Username, PasswordHash, Role - Student, Teacher, Admin, Parent)
    *   `Student` (UserId, FirstName, LastName, DateOfBirth, EnrollmentDate, ClassId)
    *   `Teacher` (UserId, FirstName, LastName, Specialization)
    *   `Course` (Id, Name, Code, Description)
    *   `Class` (Id, Name, GradeLevel, TeacherId) - A group of students for a year.
    *   `Subject` (Id, Name, Code) - Could be same as Course, or Course could be an instance of a Subject. Let's refine: `Course` is better, representing a specific subject offering.
    *   `Enrollment` (StudentId, CourseId, Grade, AcademicYearId) - For courses students take.
    *   `Attendance` (StudentId, CourseId, Date, IsPresent)
    *   `Assignment` (Id, CourseId, Title, Description, DueDate)
    *   `Submission` (StudentId, AssignmentId, SubmittedDate, Grade)
    *   `AcademicYear` (Id, StartDate, EndDate, Name)
    *   `TimeTableSlot` (DayOfWeek, StartTime, EndTime, ClassId, CourseId, TeacherId)

    *Refinement:*
    *   `User` should be base. `Student`, `Teacher` can inherit or have a 1:1 with User. ASP.NET Core Identity handles `User`. Let's make `Student` and `Teacher` profiles that link to an `IdentityUser`.
    *   `Class` can be called `SchoolClass` to avoid C# keyword clash.
    *   Maybe `Enrollment` is too granular for initial design if we have `Student` linked to a `SchoolClass`. Perhaps a student is enrolled in a `SchoolClass`, and that `SchoolClass` has a set of `Courses` (Subjects). Let's simplify for now: A `Student` belongs to a `SchoolClass`. A `SchoolClass` has `Courses` assigned to it (often through a `Teacher` teaching a `Course` to a `SchoolClass`).

8.  **API Endpoints (Examples):**

    *   `POST /api/auth/register`
    *   `POST /api/auth/login`
    *   `GET /api/students`
    *   `POST /api/students`
    *   `GET /api/students/{id}`
    *   `PUT /api/students/{id}`
    *   `GET /api/courses`
    *   `POST /api/courses`
    *   ...and so on for Teachers, Classes, Attendance.

9.  **Code Generation Strategy:**

    *   Pick a core entity (e.g., `Student`).
    *   Define the `Student` entity in `Domain`.
    *   Define `IStudentRepository` in `Domain`.
    *   Implement `StudentRepository` in `Infrastructure`.
    *   Define `StudentDto` and `CreateStudentCommand` in `Application`.
    *   Implement `CreateStudentCommandHandler` (using MediatR) in `Application`.
    *   Create `StudentsController` in `Api`.
    *   Show `DbContext` and DI setup.

10. **Refine and Structure the Output:**

    *   Start with a clear introduction.
    *   List Core Modules/Features.
    *   Describe the Chosen Architecture (Clean Architecture).
    *   Detail the Project Structure.
    *   Explain Key Technical Choices (C#, .NET, EF Core, etc.).
    *   Discuss Scalability and Robustness aspects.
    *   Provide Sample Code (Entities, DTO, Repository, Service, Controller, DbContext, Program.cs).
    *   Add a "Next Steps" or "Further Considerations" section.
    *   Ensure consistent terminology.

**(Self-Correction during the process):**
*   Initially, I might think of putting DTOs in Domain, but Clean Architecture best practices put them in Application layer as they are data transfer objects for use cases, not core domain concepts.
*   Realized the distinction between `Course` (a subject like "Math 101") and `Class` (a group of students like "Grade 10A"). A `Class` might take multiple `Courses`.
*   Ensure to mention JWT for API security.
*   Emphasize `async/await`.
*   Make sure the code examples are reasonably complete but not overwhelmingly long.
*   The request asked for "Generate Code" which implies more than just snippets. I'll provide a representative slice.

This structured thinking helps cover all aspects of the request and produces a comprehensive design.

Okay, as a System Designer, let's architect a School Management System using C#, .NET (specifically ASP.NET Core Web API), and Entity Framework Core, focusing on scalability and robustness.

## School Management System Design

### 1. Core Modules & Features:

1.  **User Management & Authentication:**
    *   Roles: Admin, Teacher, Student, Parent.
    *   Registration, Login, Profile Management.
    *   Password Reset.
2.  **Student Management:**
    *   Enrollment, Admission.
    *   Student Information (Personal, Contact, Guardian details).
    *   Class/Section Assignment.
3.  **Teacher Management:**
    *   Teacher Information (Personal, Contact, Qualifications).
    *   Subject/Class Assignment.
4.  **Academic Management:**
    *   **Courses/Subjects:** Define subjects offered.
    *   **Classes/Sections:** Manage different classes (e.g., Grade 10A, Grade 10B).
    *   **Timetable:** Schedule classes for teachers and students.
    *   **Syllabus:** Manage curriculum for each subject.
5.  **Attendance Management:**
    *   Marking student attendance (daily/per-class).
    *   Generating attendance reports.
6.  **Examination & Grades Management:**
    *   Defining examination types (Mid-term, Final).
    *   Entering marks/grades.
    *   Generating report cards.
7.  **Communication:**
    *   Announcements (School-wide, Class-specific).
    *   Messaging (Teacher-Student, Teacher-Parent - optional).
8.  **Reporting & Analytics:**
    *   Student performance reports.
    *   Teacher workload reports.
    *   Attendance summaries.

### 2. Architectural Choice: Clean Architecture (Onion Architecture)

This architecture promotes separation of concerns, testability, and maintainability. It keeps the core business logic (Domain) independent of UI, database, and external frameworks.

**Layers:**

*   **Domain:** Contains enterprise logic and types. Entities, Value Objects, Domain Events, Repository Interfaces. *No dependencies on other layers.*
*   **Application:** Contains application-specific business logic. Application Services (Use Cases), DTOs (Data Transfer Objects), Command/Query handlers (CQRS pattern), Interfaces for infrastructure concerns (e.g., IEmailService, IFileStorage). *Depends only on Domain.*
*   **Infrastructure:** Implements interfaces defined in the Application layer. Data access (EF Core DbContext, Repositories), external services (Email, File Storage), Caching implementations. *Depends on Application.*
*   **Presentation (API):** ASP.NET Core Web API. Controllers, Middleware, Configuration. *Depends on Application (and Infrastructure for DI setup).*

```mermaid
graph TD
    A[Presentation (API)] --> B{Application}
    C[Infrastructure] --> B
    B --> D{Domain}

    subgraph Legend
        direction LR
        X[Layer X] --> Y[Depends on Layer Y]
    end
```

### 3. Technology Stack:

*   **Backend Framework:** ASP.NET Core (.NET 7/8+)
*   **Language:** C#
*   **API Style:** RESTful APIs (using ASP.NET Core Web API)
*   **Database:** SQL Server (or PostgreSQL/MySQL) - flexible due to EF Core
*   **ORM:** Entity Framework Core
*   **Authentication:** ASP.NET Core Identity (for user management) + JWT (JSON Web Tokens) for stateless API authentication.
*   **Validation:** FluentValidation (for robust request validation).
*   **Logging:** Serilog or NLog.
*   **API Documentation:** Swagger/OpenAPI (Swashbuckle.AspNetCore).
*   **Real-time (Optional):** SignalR for real-time notifications/chat.
*   **Background Jobs (Optional):** Hangfire or Quartz.NET for report generation, bulk emails.

### 4. Project Structure (Solution in Visual Studio):

```
SchoolManagement.sln
├───src
│   ├───SchoolManagement.Domain
│   │   ├───Entities (e.g., Student.cs, Teacher.cs, Course.cs, Class.cs, Enrollment.cs, Attendance.cs)
│   │   ├───Enums (e.g., Gender.cs, Role.cs)
│   │   ├───ValueObjects (e.g., Address.cs, FullName.cs)
│   │   ├───Interfaces
│   │   │   └───Repositories (e.g., IStudentRepository.cs, IGenericRepository.cs)
│   │   └───Common (e.g., AuditableEntity.cs, DomainEvent.cs)
│   │
│   ├───SchoolManagement.Application
│   │   ├───Contracts
│   │   │   ├───Infrastructure (e.g., IEmailService.cs, IDateTimeService.cs)
│   │   │   └───Persistence (mirrors Domain repository interfaces, for DI)
│   │   ├───DTOs (e.g., StudentDto.cs, CreateStudentRequest.cs, LoginRequest.cs)
│   │   ├───Features (CQRS Style - one folder per feature or entity)
│   │   │   └───Students
│   │   │       ├───Commands
│   │   │       │   └───CreateStudent (CreateStudentCommand.cs, CreateStudentCommandHandler.cs)
│   │   │       │   └───UpdateStudent (UpdateStudentCommand.cs, UpdateStudentCommandHandler.cs)
│   │   │       └───Queries
│   │   │           └───GetStudentById (GetStudentByIdQuery.cs, GetStudentByIdQueryHandler.cs)
│   │   │           └───GetAllStudents (GetAllStudentsQuery.cs, GetAllStudentsQueryHandler.cs)
│   │   ├───Mappings (e.g., AutoMapper profiles)
│   │   ├───Exceptions (e.g., NotFoundException.cs, ValidationException.cs)
│   │   ├───Behaviours (MediatR pipeline behaviours for logging, validation)
│   │   └───Common (e.g., ResponseWrapper.cs)
│   │
│   ├───SchoolManagement.Infrastructure
│   │   ├───Persistence
│   │   │   ├───Repositories (e.g., StudentRepository.cs, GenericRepository.cs)
│   │   │   ├───Migrations
│   │   │   └───SchoolDbContext.cs
│   │   │   └───Configurations (EF Core entity configurations)
│   │   ├───Identity (e.g., ApplicationUser.cs, IdentityDbContext extension)
│   │   ├───Services (e.g., EmailService.cs, DateTimeService.cs)
│   │   └───DependencyInjection.cs (extension method for DI registration)
│   │
│   └───SchoolManagement.Api
│       ├───Controllers (e.g., StudentsController.cs, AuthController.cs)
│       ├───Middleware (e.g., ErrorHandlingMiddleware.cs)
│       ├───Extensions (e.g., ServiceCollectionExtensions.cs for app services)
│       ├───appsettings.json
│       └───Program.cs
│
└───tests
    ├───SchoolManagement.Domain.Tests
    ├───SchoolManagement.Application.Tests
    └───SchoolManagement.Infrastructure.Tests
    └───SchoolManagement.Api.Tests (Integration tests)
```

### 5. Scalability & Robustness Considerations:

*   **Asynchronous Operations:** Use `async/await` extensively for I/O bound operations (database, external API calls) to prevent thread blocking.
*   **Stateless API:** JWT authentication makes APIs stateless, which is crucial for horizontal scaling.
*   **Connection Pooling:** EF Core uses connection pooling by default.
*   **Caching:**
    *   **Response Caching:** For GET requests that return static or rarely changing data.
    *   **Data Caching (Distributed):** Redis or Memcached for frequently accessed data (e.g., list of countries, system settings).
*   **Database Optimization:**
    *   Proper indexing.
    *   Efficient queries (avoid N+1 problems, use projections).
    *   Read Replicas: For heavy read scenarios, consider directing read queries to a read replica.
*   **CQRS (Command Query Responsibility Segregation):**
    *   Separating read (queries) and write (commands) paths allows for independent optimization and scaling. MediatR is a great library for implementing this.
*   **Load Balancing:** If deploying to multiple instances, use a load balancer (e.g., Nginx, Azure Load Balancer, AWS ELB).
*   **Microservices (Future):** While starting with a well-structured monolith is fine, the Clean Architecture makes it easier to break out specific modules (e.g., Notification Service, Reporting Service) into microservices later if extreme scalability is required for those parts.
*   **Error Handling & Logging:**
    *   Global exception handling middleware to catch unhandled exceptions and return consistent error responses.
    *   Structured logging (Serilog with sinks for Seq, ELK stack, or cloud logging services) for better diagnostics.
*   **Health Checks:** ASP.NET Core Health Checks to monitor the application and its dependencies (database, external services).
*   **Rate Limiting & Throttling:** Protect APIs from abuse.
*   **Configuration Management:** Use `appsettings.json` with environment-specific overrides and User Secrets for sensitive data during development. For production, use Azure Key Vault, AWS Secrets Manager, or HashiCorp Vault.
*   **Idempotency:** For critical write operations (e.g., payment processing, if added), ensure idempotency.
*   **Resilience:** Use Polly for transient fault handling (retries, circuit breakers) when calling external services.

### 6. Code Generation (Illustrative Samples):

Let's generate some basic code snippets.

#### a. Domain Layer (`SchoolManagement.Domain`)

**`Entities/Student.cs`**
```csharp
// SchoolManagement.Domain/Entities/Student.cs
namespace SchoolManagement.Domain.Entities
{
    public enum Gender
    {
        Male,
        Female,
        Other
    }

    public class Student : AuditableEntity // Assuming AuditableEntity has Id, CreatedDate, ModifiedDate
    {
        public string FirstName { get; set; } = string.Empty;
        public string LastName { get; set; } = string.Empty;
        public DateTime DateOfBirth { get; set; }
        public Gender Gender { get; set; }
        public string Email { get; set; } = string.Empty; // Could be linked to IdentityUser
        public string PhoneNumber { get; set; } = string.Empty;
        public string Address { get; set; } = string.Empty;

        // Navigation Properties
        public Guid? ClassId { get; set; } // Foreign key
        public virtual Class? Class { get; set; } // A student belongs to one class
        public virtual ICollection<Enrollment> Enrollments { get; set; } = new List<Enrollment>();
        public virtual ICollection<Attendance> Attendances { get; set; } = new List<Attendance>();
    }

    public class AuditableEntity
    {
        public Guid Id { get; set; }
        public DateTime CreatedAt { get; set; }
        public string? CreatedBy { get; set; } // User ID or name
        public DateTime LastModifiedAt { get; set; }
        public string? LastModifiedBy { get; set; }
    }
}
```

**`Interfaces/Repositories/IStudentRepository.cs`**
```csharp
// SchoolManagement.Domain/Interfaces/Repositories/IStudentRepository.cs
using SchoolManagement.Domain.Entities;

namespace SchoolManagement.Domain.Interfaces.Repositories
{
    public interface IStudentRepository : IGenericRepository<Student>
    {
        Task<IEnumerable<Student>> GetStudentsByClassAsync(Guid classId);
        Task<Student?> GetStudentByEmailAsync(string email);
    }

    // Generic repository interface (can be in a common place)
    public interface IGenericRepository<T> where T : class
    {
        Task<T?> GetByIdAsync(Guid id);
        Task<IEnumerable<T>> GetAllAsync();
        Task AddAsync(T entity);
        void Update(T entity); // EF Core tracks changes, so just mark as modified
        void Remove(T entity);
        // Task<int> SaveChangesAsync(); // Usually handled by UnitOfWork or DbContext directly
    }
}
```

#### b. Application Layer (`SchoolManagement.Application`)

**`DTOs/StudentDto.cs`**
```csharp
// SchoolManagement.Application/DTOs/StudentDto.cs
using SchoolManagement.Domain.Entities; // For Gender enum

namespace SchoolManagement.Application.DTOs
{
    public class StudentDto
    {
        public Guid Id { get; set; }
        public string FirstName { get; set; } = string.Empty;
        public string LastName { get; set; } = string.Empty;
        public DateTime DateOfBirth { get; set; }
        public Gender Gender { get; set; }
        public string Email { get; set; } = string.Empty;
        public Guid? ClassId { get; set; }
        public string? ClassName { get; set; } // Denormalized for convenience
    }

    public class CreateStudentRequest
    {
        public string FirstName { get; set; } = string.Empty;
        public string LastName { get; set; } = string.Empty;
        public DateTime DateOfBirth { get; set; }
        public Gender Gender { get; set; }
        public string Email { get; set; } = string.Empty;
        public string PhoneNumber { get; set; } = string.Empty;
        public string Address { get; set; } = string.Empty;
        public Guid? ClassId { get; set; }
    }
}
```

**`Features/Students/Commands/CreateStudent/CreateStudentCommand.cs`**
```csharp
// SchoolManagement.Application/Features/Students/Commands/CreateStudent/CreateStudentCommand.cs
using MediatR;
using SchoolManagement.Application.DTOs;
using SchoolManagement.Domain.Entities; // For Gender

namespace SchoolManagement.Application.Features.Students.Commands.CreateStudent
{
    public class CreateStudentCommand : IRequest<StudentDto>
    {
        public string FirstName { get; set; } = string.Empty;
        public string LastName { get; set; } = string.Empty;
        public DateTime DateOfBirth { get; set; }
        public Gender Gender { get; set; }
        public string Email { get; set; } = string.Empty;
        public string PhoneNumber { get; set; } = string.Empty;
        public string Address { get; set; } = string.Empty;
        public Guid? ClassId { get; set; }
    }
}
```

**`Features/Students/Commands/CreateStudent/CreateStudentCommandHandler.cs`**
```csharp
// SchoolManagement.Application/Features/Students/Commands/CreateStudent/CreateStudentCommandHandler.cs
using AutoMapper;
using MediatR;
using SchoolManagement.Application.Contracts.Persistence; // IUnitOfWork
using SchoolManagement.Application.DTOs;
using SchoolManagement.Domain.Entities;
using SchoolManagement.Application.Exceptions; // For ValidationException


namespace SchoolManagement.Application.Features.Students.Commands.CreateStudent
{
    public class CreateStudentCommandHandler : IRequestHandler<CreateStudentCommand, StudentDto>
    {
        private readonly IUnitOfWork _unitOfWork;
        private readonly IMapper _mapper;

        public CreateStudentCommandHandler(IUnitOfWork unitOfWork, IMapper mapper)
        {
            _unitOfWork = unitOfWork;
            _mapper = mapper;
        }

        public async Task<StudentDto> Handle(CreateStudentCommand request, CancellationToken cancellationToken)
        {
            // 1. Validate request (FluentValidation can be used via MediatR pipeline behavior)
            // Example manual validation (replace with FluentValidation)
            if (string.IsNullOrWhiteSpace(request.FirstName) || string.IsNullOrWhiteSpace(request.LastName))
            {
                // This would typically be a custom ValidationException caught by middleware
                throw new ArgumentException("First name and Last name are required.");
            }

            var existingStudent = await _unitOfWork.StudentRepository.GetStudentByEmailAsync(request.Email);
            if (existingStudent != null)
            {
                // This would typically be a custom ValidationException
                throw new ArgumentException($"Student with email {request.Email} already exists.");
            }

            // 2. Map to Domain Entity
            var student = _mapper.Map<Student>(request);
            student.Id = Guid.NewGuid(); // Or let DB generate
            student.CreatedAt = DateTime.UtcNow;
            // student.CreatedBy = ... // Get current user ID if applicable

            // 3. Add to Repository
            await _unitOfWork.StudentRepository.AddAsync(student);

            // 4. Save Changes (Unit of Work pattern)
            var result = await _unitOfWork.CompleteAsync(cancellationToken);
            if(result <= 0)
            {
                throw new Exception("Failed to create student."); // Or a more specific exception
            }

            // 5. Map to DTO and return
            return _mapper.Map<StudentDto>(student);
        }
    }
}
```
**`Mappings/MappingProfile.cs` (using AutoMapper)**
```csharp
// SchoolManagement.Application/Mappings/MappingProfile.cs
using AutoMapper;
using SchoolManagement.Application.DTOs;
using SchoolManagement.Application.Features.Students.Commands.CreateStudent;
using SchoolManagement.Domain.Entities;

namespace SchoolManagement.Application.Mappings
{
    public class MappingProfile : Profile
    {
        public MappingProfile()
        {
            CreateMap<Student, StudentDto>()
                .ForMember(dest => dest.ClassName, opt => opt.MapFrom(src => src.Class != null ? src.Class.Name : null));
            CreateMap<CreateStudentCommand, Student>();
            CreateMap<CreateStudentRequest, CreateStudentCommand>(); // If you have separate API request models
        }
    }
}
```
**`Contracts/Persistence/IUnitOfWork.cs`**
```csharp
// SchoolManagement.Application/Contracts/Persistence/IUnitOfWork.cs
using SchoolManagement.Domain.Interfaces.Repositories; // For IStudentRepository etc.

namespace SchoolManagement.Application.Contracts.Persistence
{
    public interface IUnitOfWork : IDisposable
    {
        IStudentRepository StudentRepository { get; }
        // ... other repositories like ITeacherRepository, ICourseRepository etc.

        Task<int> CompleteAsync(CancellationToken cancellationToken = default);
    }
}
```

#### c. Infrastructure Layer (`SchoolManagement.Infrastructure`)

**`Persistence/SchoolDbContext.cs`**
```csharp
// SchoolManagement.Infrastructure/Persistence/SchoolDbContext.cs
using Microsoft.EntityFrameworkCore;
using SchoolManagement.Domain.Entities;
using System.Reflection;

namespace SchoolManagement.Infrastructure.Persistence
{
    public class SchoolDbContext : DbContext // Or IdentityDbContext<ApplicationUser> if using ASP.NET Core Identity
    {
        public SchoolDbContext(DbContextOptions<SchoolDbContext> options) : base(options)
        {
        }

        public DbSet<Student> Students { get; set; }
        public DbSet<Teacher> Teachers { get; set; }
        public DbSet<Course> Courses { get; set; }
        public DbSet<Class> Classes { get; set; }
        public DbSet<Enrollment> Enrollments { get; set; }
        public DbSet<Attendance> Attendances { get; set; }
        // ... other DbSets

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            base.OnModelCreating(modelBuilder);
            // Apply all IEntityTypeConfiguration from the current assembly
            modelBuilder.ApplyConfigurationsFromAssembly(Assembly.GetExecutingAssembly());

            // Example of a simple relationship configuration (if not using separate config files)
            modelBuilder.Entity<Student>()
                .HasOne(s => s.Class)
                .WithMany(c => c.Students)
                .HasForeignKey(s => s.ClassId)
                .OnDelete(DeleteBehavior.SetNull); // Or Restrict, Cascade depending on business rules
        }

        public override Task<int> SaveChangesAsync(CancellationToken cancellationToken = default)
        {
            foreach (var entry in ChangeTracker.Entries<AuditableEntity>())
            {
                switch (entry.State)
                {
                    case EntityState.Added:
                        entry.Entity.CreatedAt = DateTime.UtcNow;
                        // entry.Entity.CreatedBy = _currentUserService.UserId; // If you have a current user service
                        break;
                    case EntityState.Modified:
                        entry.Entity.LastModifiedAt = DateTime.UtcNow;
                        // entry.Entity.LastModifiedBy = _currentUserService.UserId;
                        break;
                }
            }
            return base.SaveChangesAsync(cancellationToken);
        }
    }
}
```

**`Persistence/Repositories/StudentRepository.cs`**
```csharp
// SchoolManagement.Infrastructure/Persistence/Repositories/StudentRepository.cs
using Microsoft.EntityFrameworkCore;
using SchoolManagement.Domain.Entities;
using SchoolManagement.Domain.Interfaces.Repositories;

namespace SchoolManagement.Infrastructure.Persistence.Repositories
{
    public class StudentRepository : GenericRepository<Student>, IStudentRepository
    {
        private readonly SchoolDbContext _dbContext;

        public StudentRepository(SchoolDbContext dbContext) : base(dbContext)
        {
            _dbContext = dbContext;
        }

        public async Task<Student?> GetStudentByEmailAsync(string email)
        {
            return await _dbContext.Students.FirstOrDefaultAsync(s => s.Email == email);
        }

        public async Task<IEnumerable<Student>> GetStudentsByClassAsync(Guid classId)
        {
            return await _dbContext.Students
                                 .Where(s => s.ClassId == classId)
                                 .ToListAsync();
        }
    }
    // GenericRepository implementation would also be here or in a base class
}
```

**`Persistence/UnitOfWork.cs`**
```csharp
// SchoolManagement.Infrastructure/Persistence/UnitOfWork.cs
using SchoolManagement.Application.Contracts.Persistence;
using SchoolManagement.Domain.Interfaces.Repositories;
using SchoolManagement.Infrastructure.Persistence.Repositories; // For specific repository implementations

namespace SchoolManagement.Infrastructure.Persistence
{
    public class UnitOfWork : IUnitOfWork
    {
        private readonly SchoolDbContext _context;
        private IStudentRepository? _studentRepository;
        // ... other private repository fields

        public UnitOfWork(SchoolDbContext context)
        {
            _context = context;
        }

        public IStudentRepository StudentRepository => _studentRepository ??= new StudentRepository(_context);
        // ... other repository properties with lazy initialization

        public async Task<int> CompleteAsync(CancellationToken cancellationToken = default)
        {
            return await _context.SaveChangesAsync(cancellationToken);
        }

        public void Dispose()
        {
            _context.Dispose();
            GC.SuppressFinalize(this);
        }
    }
}
```

**`DependencyInjection.cs` (for service registration)**
```csharp
// SchoolManagement.Infrastructure/DependencyInjection.cs
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using SchoolManagement.Application.Contracts.Persistence;
using SchoolManagement.Domain.Interfaces.Repositories;
using SchoolManagement.Infrastructure.Persistence;
using SchoolManagement.Infrastructure.Persistence.Repositories;

namespace SchoolManagement.Infrastructure
{
    public static class DependencyInjection
    {
        public static IServiceCollection AddInfrastructureServices(this IServiceCollection services, IConfiguration configuration)
        {
            services.AddDbContext<SchoolDbContext>(options =>
                options.UseSqlServer(configuration.GetConnectionString("DefaultConnection"),
                    b => b.MigrationsAssembly(typeof(SchoolDbContext).Assembly.FullName)));

            // Repositories & Unit of Work
            services.AddScoped(typeof(IGenericRepository<>), typeof(GenericRepository<>));
            services.AddScoped<IStudentRepository, StudentRepository>();
            // ... register other repositories
            services.AddScoped<IUnitOfWork, UnitOfWork>();

            // Other infrastructure services (Email, DateTime, etc.)
            // services.AddTransient<IEmailService, EmailService>();

            return services;
        }
    }
}
```

#### d. Presentation Layer (`SchoolManagement.Api`)

**`Controllers/StudentsController.cs`**
```csharp
// SchoolManagement.Api/Controllers/StudentsController.cs
using MediatR;
using Microsoft.AspNetCore.Mvc;
using SchoolManagement.Application.DTOs;
using SchoolManagement.Application.Features.Students.Commands.CreateStudent;
using SchoolManagement.Application.Features.Students.Queries.GetAllStudents; // Assuming you create this
using SchoolManagement.Application.Features.Students.Queries.GetStudentById; // Assuming you create this


namespace SchoolManagement.Api.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class StudentsController : ControllerBase
    {
        private readonly IMediator _mediator;

        public StudentsController(IMediator mediator)
        {
            _mediator = mediator;
        }

        [HttpPost]
        [ProducesResponseType(typeof(StudentDto), StatusCodes.Status201Created)]
        [ProducesResponseType(StatusCodes.Status400BadRequest)]
        public async Task<IActionResult> CreateStudent([FromBody] CreateStudentCommand command)
        {
            // In a real app, CreateStudentRequest would come from body, then mapped to CreateStudentCommand
            // Or the command itself can be the request model if simple.
            var result = await _mediator.Send(command);
            return CreatedAtAction(nameof(GetStudentById), new { id = result.Id }, result);
        }

        [HttpGet("{id}")]
        [ProducesResponseType(typeof(StudentDto), StatusCodes.Status200OK)]
        [ProducesResponseType(StatusCodes.Status404NotFound)]
        public async Task<IActionResult> GetStudentById(Guid id)
        {
            var query = new GetStudentByIdQuery { Id = id }; // Assuming this query exists
            var student = await _mediator.Send(query);
            // The query handler should throw NotFoundException if student not found,
            // which is then handled by middleware.
            return Ok(student);
        }

        [HttpGet]
        [ProducesResponseType(typeof(IEnumerable<StudentDto>), StatusCodes.Status200OK)]
        public async Task<IActionResult> GetAllStudents()
        {
            var query = new GetAllStudentsQuery(); // Assuming this query exists
            var students = await _mediator.Send(query);
            return Ok(students);
        }

        // ... Other endpoints (PUT, DELETE)
    }
}
```

**`Program.cs` (ASP.NET Core 6+ minimal API setup style)**
```csharp
// SchoolManagement.Api/Program.cs
using SchoolManagement.Application; // For AddApplicationServices
using SchoolManagement.Infrastructure; // For AddInfrastructureServices
using SchoolManagement.Api.Middleware; // For ErrorHandlingMiddleware

var builder = WebApplication.CreateBuilder(args);

// 1. Add services to the container.
builder.Services.AddApplicationServices(); // Extension method in Application layer (for MediatR, AutoMapper, FluentValidation)
builder.Services.AddInfrastructureServices(builder.Configuration); // Extension method in Infrastructure layer (for DbContext, Repositories)

builder.Services.AddControllers();
// Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

// Add CORS policy if your frontend is on a different domain
builder.Services.AddCors(options =>
{
    options.AddPolicy("AllowAll",
        policy => policy.AllowAnyOrigin()
                        .AllowAnyMethod()
                                                .AllowAnyHeader());
});


var app = builder.Build();

// 2. Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseHttpsRedirection();

app.UseCors("AllowAll"); // Apply CORS policy

// Custom Middleware
app.UseMiddleware<ErrorHandlingMiddleware>(); // Ensure this is defined

// app.UseAuthentication(); // Add if using ASP.NET Core Identity + JWT
app.UseAuthorization();

app.MapControllers();

app.Run();
```

**`Application/DependencyInjection.cs` (for Application layer DI)**
```csharp
// SchoolManagement.Application/DependencyInjection.cs
using Microsoft.Extensions.DependencyInjection;
using System.Reflection;
using MediatR;
using FluentValidation;
// using SchoolManagement.Application.Behaviours; // For MediatR pipeline behaviours

namespace SchoolManagement.Application
{
    public static class DependencyInjection
    {
        public static IServiceCollection AddApplicationServices(this IServiceCollection services)
        {
            services.AddAutoMapper(Assembly.GetExecutingAssembly());
            services.AddMediatR(cfg => cfg.RegisterServicesFromAssembly(Assembly.GetExecutingAssembly()));
            services.AddValidatorsFromAssembly(Assembly.GetExecutingAssembly()); // For FluentValidation

            // Optional: Add MediatR pipeline behaviours for common concerns
            // services.AddTransient(typeof(IPipelineBehavior<,>), typeof(UnhandledExceptionBehaviour<,>));
            // services.AddTransient(typeof(IPipelineBehavior<,>), typeof(ValidationBehaviour<,>));
            // services.AddTransient(typeof(IPipelineBehavior<,>), typeof(LoggingBehaviour<,>));


            return services;
        }
    }
}
```

### 7. Next Steps & Further Considerations:

*   **Implement ASP.NET Core Identity:** For robust user management and authentication.
*   **JWT Implementation:** Secure your API endpoints.
*   **FluentValidation:** Add comprehensive validation rules for all DTOs/Commands.
*   **Global Error Handling Middleware:** Create a middleware to catch exceptions and return standardized JSON error responses.
*   **Logging:** Integrate Serilog.
*   **Unit & Integration Tests:** Write tests for all layers.
*   **Complete other features:** Implement remaining modules (Teachers, Courses, Timetable, etc.).
*   **API Versioning:** Plan for API versioning if breaking changes are anticipated.
*   **Deployment Strategy:** Docker, Kubernetes, Azure App Service, AWS Elastic Beanstalk.
*   **CI/CD Pipeline:** Set up automated build, test, and deployment.

This comprehensive design provides a solid foundation for building a scalable and robust School Management System. The Clean Architecture ensures that the system remains maintainable and adaptable to future changes. The code snippets give a starting point for implementation. Remember to flesh out all entities, relationships, use cases, and error handling thoroughly.