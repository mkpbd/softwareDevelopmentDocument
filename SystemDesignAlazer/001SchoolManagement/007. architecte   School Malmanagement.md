
Here's a breakdown of the thinking process to generate the School Management System design:

1.  **Deconstruct the Request:**

    *   **Role:** System Designer
    *   **Goal:** Design a School Management System
    *   **Key Requirements:**
        *   Scalable
        *   Robust
        *   Technologies: C#, .NET (implicitly .NET Core/.NET 5+ for Web API & EF Core), Web API, EF Core
        *   Output: Design, Project Architecture, Generate Code (sample)

2.  **Core Functionalities of a School Management System (Brainstorming):**

    *   Student Management (Enrollment, Info, Attendance, Grades)
    *   Teacher Management (Info, Assignments, Classes)
    *   Course Management (Subjects, Curriculum)
    *   Class Management (Schedules, Sections)
    *   Attendance Tracking
    *   Grading/Report Cards
    *   Parent Portal (View student progress, attendance)
    *   Admin Portal (User management, system settings)
    *   Communication (Announcements, messages)
    *   Timetable Management
    *   Fee Management (Optional, but common)
    *   Library Management (Optional)
    *   Exam Management

3.  **Architectural Considerations (High-Level):**

    *   **Layered Architecture:** This is a standard for maintainability and separation of concerns.
        *   Presentation (API for now, could be a UI later)
        *   Application/Business Logic
        *   Domain (Core entities and rules)
        *   Infrastructure (Database, external services)
    *   **Clean Architecture / Onion Architecture:** A more refined version of layered, emphasizing dependency inversion. The Domain is at the core, with other layers depending inward. This is good for testability and decoupling.
    *   **Microservices (Scalability):** While a monolithic start is fine, think about how it *could* be broken down later if extreme scalability is needed (e.g., separate services for Attendance, Grading, User Management). For now, a well-structured monolith is a good starting point.
    *   **Database:** Relational (SQL Server, PostgreSQL) is a natural fit for structured school data. EF Core is specified, so this aligns.
    *   **API Design:** RESTful principles.

4.  **Technology Choices (Confirming from Request):**

    *   **Backend:** C#, .NET (ASP.NET Core Web API)
    *   **ORM:** Entity Framework Core
    *   **Database:** (Implied by EF Core, let's assume SQL Server for example, but make it configurable).
    *   **Authentication/Authorization:** ASP.NET Core Identity, JWT.
    *   **Frontend (Not explicitly requested for backend design, but good to keep in mind):** Could be anything (React, Angular, Vue, Blazor). The API should be frontend-agnostic.

5.  **Project Structure (Mapping to Clean Architecture):**

    *   `SchoolManagement.Domain`: Entities, Enums, Domain Services (if any), Interfaces for Repositories. No external dependencies.
    *   `SchoolManagement.Application`: Application Services (use cases), DTOs, Interfaces for Infrastructure services (e.g., IEmailService), Validation, MediatR (CQRS pattern). Depends on Domain.
    *   `SchoolManagement.Infrastructure`: EF Core DbContext, Repositories implementation, Email Service implementation, other external service integrations. Depends on Application (interfaces).
    *   `SchoolManagement.Api`: ASP.NET Core Web API project. Controllers, Middleware, Startup/Program.cs configuration. Depends on Application and Infrastructure (for DI).
    *   `SchoolManagement.Tests`: Unit tests, Integration tests.

6.  **Key Design Decisions for Scalability & Robustness:**

    *   **Asynchronous Operations:** `async/await` throughout (especially for I/O like DB access).
    *   **Dependency Injection (DI):** Built into ASP.NET Core. Essential for loose coupling and testability.
    *   **CQRS (Command Query Responsibility Segregation):** Using MediatR can simplify application services. Commands for writes, Queries for reads. Good for scaling different parts of the system.
    *   **Error Handling:** Global exception handling middleware. Consistent error responses.
    *   **Logging:** Serilog or NLog.
    *   **Configuration:** `appsettings.json` and environment variables.
    *   **Caching:** For frequently accessed, rarely changing data (e.g., list of subjects, school years).
    *   **Background Jobs:** (e.g., Hangfire) for tasks like sending bulk emails, report generation.
    *   **Database Migrations:** EF Core Migrations.
    *   **Security:**
        *   Authentication (ASP.NET Core Identity + JWT).
        *   Authorization (Role-based, Policy-based).
        *   Input Validation (FluentValidation).
        *   HTTPS.
        *   Protection against common web vulnerabilities (OWASP Top 10).

7.  **Database Schema (High-Level Entities - initial thoughts):**

    *   `User` (Id, Username, PasswordHash, Role - Student, Teacher, Admin, Parent)
    *   `Student` (UserId, FirstName, LastName, DateOfBirth, EnrollmentDate, ClassId)
    *   `Teacher` (UserId, FirstName, LastName, Specialization)
    *   `Course` (Id, Name, Code, Description)
    *   `Class` (Id, Name, GradeLevel, TeacherId) - A group of students for a year.
    *   `Subject` (Id, Name, Code) - Could be same as Course, or Course could be an instance of a Subject. Let's refine: `Course` is better, representing a specific subject offering.
    *   `Enrollment` (StudentId, CourseId, Grade, AcademicYearId) - For courses students take.
    *   `Attendance` (StudentId, CourseId, Date, IsPresent)
    *   `Assignment` (Id, CourseId, Title, Description, DueDate)
    *   `Submission` (StudentId, AssignmentId, SubmittedDate, Grade)
    *   `AcademicYear` (Id, StartDate, EndDate, Name)
    *   `TimeTableSlot` (DayOfWeek, StartTime, EndTime, ClassId, CourseId, TeacherId)

    *Refinement:*
    *   `User` should be base. `Student`, `Teacher` can inherit or have a 1:1 with User. ASP.NET Core Identity handles `User`. Let's make `Student` and `Teacher` profiles that link to an `IdentityUser`.
    *   `Class` can be called `SchoolClass` to avoid C# keyword clash.
    *   Maybe `Enrollment` is too granular for initial design if we have `Student` linked to a `SchoolClass`. Perhaps a student is enrolled in a `SchoolClass`, and that `SchoolClass` has a set of `Courses` (Subjects). Let's simplify for now: A `Student` belongs to a `SchoolClass`. A `SchoolClass` has `Courses` assigned to it (often through a `Teacher` teaching a `Course` to a `SchoolClass`).

8.  **API Endpoints (Examples):**

    *   `POST /api/auth/register`
    *   `POST /api/auth/login`
    *   `GET /api/students`
    *   `POST /api/students`
    *   `GET /api/students/{id}`
    *   `PUT /api/students/{id}`
    *   `GET /api/courses`
    *   `POST /api/courses`
    *   ...and so on for Teachers, Classes, Attendance.

9.  **Code Generation Strategy:**

    *   Pick a core entity (e.g., `Student`).
    *   Define the `Student` entity in `Domain`.
    *   Define `IStudentRepository` in `Domain`.
    *   Implement `StudentRepository` in `Infrastructure`.
    *   Define `StudentDto` and `CreateStudentCommand` in `Application`.
    *   Implement `CreateStudentCommandHandler` (using MediatR) in `Application`.
    *   Create `StudentsController` in `Api`.
    *   Show `DbContext` and DI setup.

10. **Refine and Structure the Output:**

    *   Start with a clear introduction.
    *   List Core Modules/Features.
    *   Describe the Chosen Architecture (Clean Architecture).
    *   Detail the Project Structure.
    *   Explain Key Technical Choices (C#, .NET, EF Core, etc.).
    *   Discuss Scalability and Robustness aspects.
    *   Provide Sample Code (Entities, DTO, Repository, Service, Controller, DbContext, Program.cs).
    *   Add a "Next Steps" or "Further Considerations" section.
    *   Ensure consistent terminology.

**(Self-Correction during the process):**
*   Initially, I might think of putting DTOs in Domain, but Clean Architecture best practices put them in Application layer as they are data transfer objects for use cases, not core domain concepts.
*   Realized the distinction between `Course` (a subject like "Math 101") and `Class` (a group of students like "Grade 10A"). A `Class` might take multiple `Courses`.
*   Ensure to mention JWT for API security.
*   Emphasize `async/await`.
*   Make sure the code examples are reasonably complete but not overwhelmingly long.
*   The request asked for "Generate Code" which implies more than just snippets. I'll provide a representative slice.

This structured thinking helps cover all aspects of the request and produces a comprehensive design.

Okay, as a System Designer, let's architect a School Management System using C#, .NET (specifically ASP.NET Core Web API), and Entity Framework Core, focusing on scalability and robustness.

## School Management System Design

### 1. Core Modules & Features:

1.  **User Management & Authentication:**
    *   Roles: Admin, Teacher, Student, Parent.
    *   Registration, Login, Profile Management.
    *   Password Reset.
2.  **Student Management:**
    *   Enrollment, Admission.
    *   Student Information (Personal, Contact, Guardian details).
    *   Class/Section Assignment.
3.  **Teacher Management:**
    *   Teacher Information (Personal, Contact, Qualifications).
    *   Subject/Class Assignment.
4.  **Academic Management:**
    *   **Courses/Subjects:** Define subjects offered.
    *   **Classes/Sections:** Manage different classes (e.g., Grade 10A, Grade 10B).
    *   **Timetable:** Schedule classes for teachers and students.
    *   **Syllabus:** Manage curriculum for each subject.
5.  **Attendance Management:**
    *   Marking student attendance (daily/per-class).
    *   Generating attendance reports.
6.  **Examination & Grades Management:**
    *   Defining examination types (Mid-term, Final).
    *   Entering marks/grades.
    *   Generating report cards.
7.  **Communication:**
    *   Announcements (School-wide, Class-specific).
    *   Messaging (Teacher-Student, Teacher-Parent - optional).
8.  **Reporting & Analytics:**
    *   Student performance reports.
    *   Teacher workload reports.
    *   Attendance summaries.

### 2. Architectural Choice: Clean Architecture (Onion Architecture)

This architecture promotes separation of concerns, testability, and maintainability. It keeps the core business logic (Domain) independent of UI, database, and external frameworks.

**Layers:**

*   **Domain:** Contains enterprise logic and types. Entities, Value Objects, Domain Events, Repository Interfaces. *No dependencies on other layers.*
*   **Application:** Contains application-specific business logic. Application Services (Use Cases), DTOs (Data Transfer Objects), Command/Query handlers (CQRS pattern), Interfaces for infrastructure concerns (e.g., IEmailService, IFileStorage). *Depends only on Domain.*
*   **Infrastructure:** Implements interfaces defined in the Application layer. Data access (EF Core DbContext, Repositories), external services (Email, File Storage), Caching implementations. *Depends on Application.*
*   **Presentation (API):** ASP.NET Core Web API. Controllers, Middleware, Configuration. *Depends on Application (and Infrastructure for DI setup).*

```mermaid
graph TD
    A[Presentation (API)] --> B{Application}
    C[Infrastructure] --> B
    B --> D{Domain}

    subgraph Legend
        direction LR
        X[Layer X] --> Y[Depends on Layer Y]
    end
```

### 3. Technology Stack:

*   **Backend Framework:** ASP.NET Core (.NET 7/8+)
*   **Language:** C#
*   **API Style:** RESTful APIs (using ASP.NET Core Web API)
*   **Database:** SQL Server (or PostgreSQL/MySQL) - flexible due to EF Core
*   **ORM:** Entity Framework Core
*   **Authentication:** ASP.NET Core Identity (for user management) + JWT (JSON Web Tokens) for stateless API authentication.
*   **Validation:** FluentValidation (for robust request validation).
*   **Logging:** Serilog or NLog.
*   **API Documentation:** Swagger/OpenAPI (Swashbuckle.AspNetCore).
*   **Real-time (Optional):** SignalR for real-time notifications/chat.
*   **Background Jobs (Optional):** Hangfire or Quartz.NET for report generation, bulk emails.

### 4. Project Structure (Solution in Visual Studio):

```
SchoolManagement.sln
├───src
│   ├───SchoolManagement.Domain
│   │   ├───Entities (e.g., Student.cs, Teacher.cs, Course.cs, Class.cs, Enrollment.cs, Attendance.cs)
│   │   ├───Enums (e.g., Gender.cs, Role.cs)
│   │   ├───ValueObjects (e.g., Address.cs, FullName.cs)
│   │   ├───Interfaces
│   │   │   └───Repositories (e.g., IStudentRepository.cs, IGenericRepository.cs)
│   │   └───Common (e.g., AuditableEntity.cs, DomainEvent.cs)
│   │
│   ├───SchoolManagement.Application
│   │   ├───Contracts
│   │   │   ├───Infrastructure (e.g., IEmailService.cs, IDateTimeService.cs)
│   │   │   └───Persistence (mirrors Domain repository interfaces, for DI)
│   │   ├───DTOs (e.g., StudentDto.cs, CreateStudentRequest.cs, LoginRequest.cs)
│   │   ├───Features (CQRS Style - one folder per feature or entity)
│   │   │   └───Students
│   │   │       ├───Commands
│   │   │       │   └───CreateStudent (CreateStudentCommand.cs, CreateStudentCommandHandler.cs)
│   │   │       │   └───UpdateStudent (UpdateStudentCommand.cs, UpdateStudentCommandHandler.cs)
│   │   │       └───Queries
│   │   │           └───GetStudentById (GetStudentByIdQuery.cs, GetStudentByIdQueryHandler.cs)
│   │   │           └───GetAllStudents (GetAllStudentsQuery.cs, GetAllStudentsQueryHandler.cs)
│   │   ├───Mappings (e.g., AutoMapper profiles)
│   │   ├───Exceptions (e.g., NotFoundException.cs, ValidationException.cs)
│   │   ├───Behaviours (MediatR pipeline behaviours for logging, validation)
│   │   └───Common (e.g., ResponseWrapper.cs)
│   │
│   ├───SchoolManagement.Infrastructure
│   │   ├───Persistence
│   │   │   ├───Repositories (e.g., StudentRepository.cs, GenericRepository.cs)
│   │   │   ├───Migrations
│   │   │   └───SchoolDbContext.cs
│   │   │   └───Configurations (EF Core entity configurations)
│   │   ├───Identity (e.g., ApplicationUser.cs, IdentityDbContext extension)
│   │   ├───Services (e.g., EmailService.cs, DateTimeService.cs)
│   │   └───DependencyInjection.cs (extension method for DI registration)
│   │
│   └───SchoolManagement.Api
│       ├───Controllers (e.g., StudentsController.cs, AuthController.cs)
│       ├───Middleware (e.g., ErrorHandlingMiddleware.cs)
│       ├───Extensions (e.g., ServiceCollectionExtensions.cs for app services)
│       ├───appsettings.json
│       └───Program.cs
│
└───tests
    ├───SchoolManagement.Domain.Tests
    ├───SchoolManagement.Application.Tests
    └───SchoolManagement.Infrastructure.Tests
    └───SchoolManagement.Api.Tests (Integration tests)
```

### 5. Scalability & Robustness Considerations:

*   **Asynchronous Operations:** Use `async/await` extensively for I/O bound operations (database, external API calls) to prevent thread blocking.
*   **Stateless API:** JWT authentication makes APIs stateless, which is crucial for horizontal scaling.
*   **Connection Pooling:** EF Core uses connection pooling by default.
*   **Caching:**
    *   **Response Caching:** For GET requests that return static or rarely changing data.
    *   **Data Caching (Distributed):** Redis or Memcached for frequently accessed data (e.g., list of countries, system settings).
*   **Database Optimization:**
    *   Proper indexing.
    *   Efficient queries (avoid N+1 problems, use projections).
    *   Read Replicas: For heavy read scenarios, consider directing read queries to a read replica.
*   **CQRS (Command Query Responsibility Segregation):**
    *   Separating read (queries) and write (commands) paths allows for independent optimization and scaling. MediatR is a great library for implementing this.
*   **Load Balancing:** If deploying to multiple instances, use a load balancer (e.g., Nginx, Azure Load Balancer, AWS ELB).
*   **Microservices (Future):** While starting with a well-structured monolith is fine, the Clean Architecture makes it easier to break out specific modules (e.g., Notification Service, Reporting Service) into microservices later if extreme scalability is required for those parts.
*   **Error Handling & Logging:**
    *   Global exception handling middleware to catch unhandled exceptions and return consistent error responses.
    *   Structured logging (Serilog with sinks for Seq, ELK stack, or cloud logging services) for better diagnostics.
*   **Health Checks:** ASP.NET Core Health Checks to monitor the application and its dependencies (database, external services).
*   **Rate Limiting & Throttling:** Protect APIs from abuse.
*   **Configuration Management:** Use `appsettings.json` with environment-specific overrides and User Secrets for sensitive data during development. For production, use Azure Key Vault, AWS Secrets Manager, or HashiCorp Vault.
*   **Idempotency:** For critical write operations (e.g., payment processing, if added), ensure idempotency.
*   **Resilience:** Use Polly for transient fault handling (retries, circuit breakers) when calling external services.

### 6. Code Generation (Illustrative Samples):

Let's generate some basic code snippets.

#### a. Domain Layer (`SchoolManagement.Domain`)

**`Entities/Student.cs`**
```csharp
// SchoolManagement.Domain/Entities/Student.cs
namespace SchoolManagement.Domain.Entities
{
    public enum Gender
    {
        Male,
        Female,
        Other
    }

    public class Student : AuditableEntity // Assuming AuditableEntity has Id, CreatedDate, ModifiedDate
    {
        public string FirstName { get; set; } = string.Empty;
        public string LastName { get; set; } = string.Empty;
        public DateTime DateOfBirth { get; set; }
        public Gender Gender { get; set; }
        public string Email { get; set; } = string.Empty; // Could be linked to IdentityUser
        public string PhoneNumber { get; set; } = string.Empty;
        public string Address { get; set; } = string.Empty;

        // Navigation Properties
        public Guid? ClassId { get; set; } // Foreign key
        public virtual Class? Class { get; set; } // A student belongs to one class
        public virtual ICollection<Enrollment> Enrollments { get; set; } = new List<Enrollment>();
        public virtual ICollection<Attendance> Attendances { get; set; } = new List<Attendance>();
    }

    public class AuditableEntity
    {
        public Guid Id { get; set; }
        public DateTime CreatedAt { get; set; }
        public string? CreatedBy { get; set; } // User ID or name
        public DateTime LastModifiedAt { get; set; }
        public string? LastModifiedBy { get; set; }
    }
}
```

**`Interfaces/Repositories/IStudentRepository.cs`**
```csharp
// SchoolManagement.Domain/Interfaces/Repositories/IStudentRepository.cs
using SchoolManagement.Domain.Entities;

namespace SchoolManagement.Domain.Interfaces.Repositories
{
    public interface IStudentRepository : IGenericRepository<Student>
    {
        Task<IEnumerable<Student>> GetStudentsByClassAsync(Guid classId);
        Task<Student?> GetStudentByEmailAsync(string email);
    }

    // Generic repository interface (can be in a common place)
    public interface IGenericRepository<T> where T : class
    {
        Task<T?> GetByIdAsync(Guid id);
        Task<IEnumerable<T>> GetAllAsync();
        Task AddAsync(T entity);
        void Update(T entity); // EF Core tracks changes, so just mark as modified
        void Remove(T entity);
        // Task<int> SaveChangesAsync(); // Usually handled by UnitOfWork or DbContext directly
    }
}
```

#### b. Application Layer (`SchoolManagement.Application`)

**`DTOs/StudentDto.cs`**
```csharp
// SchoolManagement.Application/DTOs/StudentDto.cs
using SchoolManagement.Domain.Entities; // For Gender enum

namespace SchoolManagement.Application.DTOs
{
    public class StudentDto
    {
        public Guid Id { get; set; }
        public string FirstName { get; set; } = string.Empty;
        public string LastName { get; set; } = string.Empty;
        public DateTime DateOfBirth { get; set; }
        public Gender Gender { get; set; }
        public string Email { get; set; } = string.Empty;
        public Guid? ClassId { get; set; }
        public string? ClassName { get; set; } // Denormalized for convenience
    }

    public class CreateStudentRequest
    {
        public string FirstName { get; set; } = string.Empty;
        public string LastName { get; set; } = string.Empty;
        public DateTime DateOfBirth { get; set; }
        public Gender Gender { get; set; }
        public string Email { get; set; } = string.Empty;
        public string PhoneNumber { get; set; } = string.Empty;
        public string Address { get; set; } = string.Empty;
        public Guid? ClassId { get; set; }
    }
}
```

**`Features/Students/Commands/CreateStudent/CreateStudentCommand.cs`**
```csharp
// SchoolManagement.Application/Features/Students/Commands/CreateStudent/CreateStudentCommand.cs
using MediatR;
using SchoolManagement.Application.DTOs;
using SchoolManagement.Domain.Entities; // For Gender

namespace SchoolManagement.Application.Features.Students.Commands.CreateStudent
{
    public class CreateStudentCommand : IRequest<StudentDto>
    {
        public string FirstName { get; set; } = string.Empty;
        public string LastName { get; set; } = string.Empty;
        public DateTime DateOfBirth { get; set; }
        public Gender Gender { get; set; }
        public string Email { get; set; } = string.Empty;
        public string PhoneNumber { get; set; } = string.Empty;
        public string Address { get; set; } = string.Empty;
        public Guid? ClassId { get; set; }
    }
}
```

**`Features/Students/Commands/CreateStudent/CreateStudentCommandHandler.cs`**
```csharp
// SchoolManagement.Application/Features/Students/Commands/CreateStudent/CreateStudentCommandHandler.cs
using AutoMapper;
using MediatR;
using SchoolManagement.Application.Contracts.Persistence; // IUnitOfWork
using SchoolManagement.Application.DTOs;
using SchoolManagement.Domain.Entities;
using SchoolManagement.Application.Exceptions; // For ValidationException


namespace SchoolManagement.Application.Features.Students.Commands.CreateStudent
{
    public class CreateStudentCommandHandler : IRequestHandler<CreateStudentCommand, StudentDto>
    {
        private readonly IUnitOfWork _unitOfWork;
        private readonly IMapper _mapper;

        public CreateStudentCommandHandler(IUnitOfWork unitOfWork, IMapper mapper)
        {
            _unitOfWork = unitOfWork;
            _mapper = mapper;
        }

        public async Task<StudentDto> Handle(CreateStudentCommand request, CancellationToken cancellationToken)
        {
            // 1. Validate request (FluentValidation can be used via MediatR pipeline behavior)
            // Example manual validation (replace with FluentValidation)
            if (string.IsNullOrWhiteSpace(request.FirstName) || string.IsNullOrWhiteSpace(request.LastName))
            {
                // This would typically be a custom ValidationException caught by middleware
                throw new ArgumentException("First name and Last name are required.");
            }

            var existingStudent = await _unitOfWork.StudentRepository.GetStudentByEmailAsync(request.Email);
            if (existingStudent != null)
            {
                // This would typically be a custom ValidationException
                throw new ArgumentException($"Student with email {request.Email} already exists.");
            }

            // 2. Map to Domain Entity
            var student = _mapper.Map<Student>(request);
            student.Id = Guid.NewGuid(); // Or let DB generate
            student.CreatedAt = DateTime.UtcNow;
            // student.CreatedBy = ... // Get current user ID if applicable

            // 3. Add to Repository
            await _unitOfWork.StudentRepository.AddAsync(student);

            // 4. Save Changes (Unit of Work pattern)
            var result = await _unitOfWork.CompleteAsync(cancellationToken);
            if(result <= 0)
            {
                throw new Exception("Failed to create student."); // Or a more specific exception
            }

            // 5. Map to DTO and return
            return _mapper.Map<StudentDto>(student);
        }
    }
}
```
**`Mappings/MappingProfile.cs` (using AutoMapper)**
```csharp
// SchoolManagement.Application/Mappings/MappingProfile.cs
using AutoMapper;
using SchoolManagement.Application.DTOs;
using SchoolManagement.Application.Features.Students.Commands.CreateStudent;
using SchoolManagement.Domain.Entities;

namespace SchoolManagement.Application.Mappings
{
    public class MappingProfile : Profile
    {
        public MappingProfile()
        {
            CreateMap<Student, StudentDto>()
                .ForMember(dest => dest.ClassName, opt => opt.MapFrom(src => src.Class != null ? src.Class.Name : null));
            CreateMap<CreateStudentCommand, Student>();
            CreateMap<CreateStudentRequest, CreateStudentCommand>(); // If you have separate API request models
        }
    }
}
```
**`Contracts/Persistence/IUnitOfWork.cs`**
```csharp
// SchoolManagement.Application/Contracts/Persistence/IUnitOfWork.cs
using SchoolManagement.Domain.Interfaces.Repositories; // For IStudentRepository etc.

namespace SchoolManagement.Application.Contracts.Persistence
{
    public interface IUnitOfWork : IDisposable
    {
        IStudentRepository StudentRepository { get; }
        // ... other repositories like ITeacherRepository, ICourseRepository etc.

        Task<int> CompleteAsync(CancellationToken cancellationToken = default);
    }
}
```

#### c. Infrastructure Layer (`SchoolManagement.Infrastructure`)

**`Persistence/SchoolDbContext.cs`**
```csharp
// SchoolManagement.Infrastructure/Persistence/SchoolDbContext.cs
using Microsoft.EntityFrameworkCore;
using SchoolManagement.Domain.Entities;
using System.Reflection;

namespace SchoolManagement.Infrastructure.Persistence
{
    public class SchoolDbContext : DbContext // Or IdentityDbContext<ApplicationUser> if using ASP.NET Core Identity
    {
        public SchoolDbContext(DbContextOptions<SchoolDbContext> options) : base(options)
        {
        }

        public DbSet<Student> Students { get; set; }
        public DbSet<Teacher> Teachers { get; set; }
        public DbSet<Course> Courses { get; set; }
        public DbSet<Class> Classes { get; set; }
        public DbSet<Enrollment> Enrollments { get; set; }
        public DbSet<Attendance> Attendances { get; set; }
        // ... other DbSets

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            base.OnModelCreating(modelBuilder);
            // Apply all IEntityTypeConfiguration from the current assembly
            modelBuilder.ApplyConfigurationsFromAssembly(Assembly.GetExecutingAssembly());

            // Example of a simple relationship configuration (if not using separate config files)
            modelBuilder.Entity<Student>()
                .HasOne(s => s.Class)
                .WithMany(c => c.Students)
                .HasForeignKey(s => s.ClassId)
                .OnDelete(DeleteBehavior.SetNull); // Or Restrict, Cascade depending on business rules
        }

        public override Task<int> SaveChangesAsync(CancellationToken cancellationToken = default)
        {
            foreach (var entry in ChangeTracker.Entries<AuditableEntity>())
            {
                switch (entry.State)
                {
                    case EntityState.Added:
                        entry.Entity.CreatedAt = DateTime.UtcNow;
                        // entry.Entity.CreatedBy = _currentUserService.UserId; // If you have a current user service
                        break;
                    case EntityState.Modified:
                        entry.Entity.LastModifiedAt = DateTime.UtcNow;
                        // entry.Entity.LastModifiedBy = _currentUserService.UserId;
                        break;
                }
            }
            return base.SaveChangesAsync(cancellationToken);
        }
    }
}
```

**`Persistence/Repositories/StudentRepository.cs`**
```csharp
// SchoolManagement.Infrastructure/Persistence/Repositories/StudentRepository.cs
using Microsoft.EntityFrameworkCore;
using SchoolManagement.Domain.Entities;
using SchoolManagement.Domain.Interfaces.Repositories;

namespace SchoolManagement.Infrastructure.Persistence.Repositories
{
    public class StudentRepository : GenericRepository<Student>, IStudentRepository
    {
        private readonly SchoolDbContext _dbContext;

        public StudentRepository(SchoolDbContext dbContext) : base(dbContext)
        {
            _dbContext = dbContext;
        }

        public async Task<Student?> GetStudentByEmailAsync(string email)
        {
            return await _dbContext.Students.FirstOrDefaultAsync(s => s.Email == email);
        }

        public async Task<IEnumerable<Student>> GetStudentsByClassAsync(Guid classId)
        {
            return await _dbContext.Students
                                 .Where(s => s.ClassId == classId)
                                 .ToListAsync();
        }
    }
    // GenericRepository implementation would also be here or in a base class
}
```

**`Persistence/UnitOfWork.cs`**
```csharp
// SchoolManagement.Infrastructure/Persistence/UnitOfWork.cs
using SchoolManagement.Application.Contracts.Persistence;
using SchoolManagement.Domain.Interfaces.Repositories;
using SchoolManagement.Infrastructure.Persistence.Repositories; // For specific repository implementations

namespace SchoolManagement.Infrastructure.Persistence
{
    public class UnitOfWork : IUnitOfWork
    {
        private readonly SchoolDbContext _context;
        private IStudentRepository? _studentRepository;
        // ... other private repository fields

        public UnitOfWork(SchoolDbContext context)
        {
            _context = context;
        }

        public IStudentRepository StudentRepository => _studentRepository ??= new StudentRepository(_context);
        // ... other repository properties with lazy initialization

        public async Task<int> CompleteAsync(CancellationToken cancellationToken = default)
        {
            return await _context.SaveChangesAsync(cancellationToken);
        }

        public void Dispose()
        {
            _context.Dispose();
            GC.SuppressFinalize(this);
        }
    }
}
```

**`DependencyInjection.cs` (for service registration)**
```csharp
// SchoolManagement.Infrastructure/DependencyInjection.cs
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using SchoolManagement.Application.Contracts.Persistence;
using SchoolManagement.Domain.Interfaces.Repositories;
using SchoolManagement.Infrastructure.Persistence;
using SchoolManagement.Infrastructure.Persistence.Repositories;

namespace SchoolManagement.Infrastructure
{
    public static class DependencyInjection
    {
        public static IServiceCollection AddInfrastructureServices(this IServiceCollection services, IConfiguration configuration)
        {
            services.AddDbContext<SchoolDbContext>(options =>
                options.UseSqlServer(configuration.GetConnectionString("DefaultConnection"),
                    b => b.MigrationsAssembly(typeof(SchoolDbContext).Assembly.FullName)));

            // Repositories & Unit of Work
            services.AddScoped(typeof(IGenericRepository<>), typeof(GenericRepository<>));
            services.AddScoped<IStudentRepository, StudentRepository>();
            // ... register other repositories
            services.AddScoped<IUnitOfWork, UnitOfWork>();

            // Other infrastructure services (Email, DateTime, etc.)
            // services.AddTransient<IEmailService, EmailService>();

            return services;
        }
    }
}
```

#### d. Presentation Layer (`SchoolManagement.Api`)

**`Controllers/StudentsController.cs`**
```csharp
// SchoolManagement.Api/Controllers/StudentsController.cs
using MediatR;
using Microsoft.AspNetCore.Mvc;
using SchoolManagement.Application.DTOs;
using SchoolManagement.Application.Features.Students.Commands.CreateStudent;
using SchoolManagement.Application.Features.Students.Queries.GetAllStudents; // Assuming you create this
using SchoolManagement.Application.Features.Students.Queries.GetStudentById; // Assuming you create this


namespace SchoolManagement.Api.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class StudentsController : ControllerBase
    {
        private readonly IMediator _mediator;

        public StudentsController(IMediator mediator)
        {
            _mediator = mediator;
        }

        [HttpPost]
        [ProducesResponseType(typeof(StudentDto), StatusCodes.Status201Created)]
        [ProducesResponseType(StatusCodes.Status400BadRequest)]
        public async Task<IActionResult> CreateStudent([FromBody] CreateStudentCommand command)
        {
            // In a real app, CreateStudentRequest would come from body, then mapped to CreateStudentCommand
            // Or the command itself can be the request model if simple.
            var result = await _mediator.Send(command);
            return CreatedAtAction(nameof(GetStudentById), new { id = result.Id }, result);
        }

        [HttpGet("{id}")]
        [ProducesResponseType(typeof(StudentDto), StatusCodes.Status200OK)]
        [ProducesResponseType(StatusCodes.Status404NotFound)]
        public async Task<IActionResult> GetStudentById(Guid id)
        {
            var query = new GetStudentByIdQuery { Id = id }; // Assuming this query exists
            var student = await _mediator.Send(query);
            // The query handler should throw NotFoundException if student not found,
            // which is then handled by middleware.
            return Ok(student);
        }

        [HttpGet]
        [ProducesResponseType(typeof(IEnumerable<StudentDto>), StatusCodes.Status200OK)]
        public async Task<IActionResult> GetAllStudents()
        {
            var query = new GetAllStudentsQuery(); // Assuming this query exists
            var students = await _mediator.Send(query);
            return Ok(students);
        }

        // ... Other endpoints (PUT, DELETE)
    }
}
```

**`Program.cs` (ASP.NET Core 6+ minimal API setup style)**
```csharp
// SchoolManagement.Api/Program.cs
using SchoolManagement.Application; // For AddApplicationServices
using SchoolManagement.Infrastructure; // For AddInfrastructureServices
using SchoolManagement.Api.Middleware; // For ErrorHandlingMiddleware

var builder = WebApplication.CreateBuilder(args);

// 1. Add services to the container.
builder.Services.AddApplicationServices(); // Extension method in Application layer (for MediatR, AutoMapper, FluentValidation)
builder.Services.AddInfrastructureServices(builder.Configuration); // Extension method in Infrastructure layer (for DbContext, Repositories)

builder.Services.AddControllers();
// Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

// Add CORS policy if your frontend is on a different domain
builder.Services.AddCors(options =>
{
    options.AddPolicy("AllowAll",
        policy => policy.AllowAnyOrigin()
                        .AllowAnyMethod()
                                                .AllowAnyHeader());
});


var app = builder.Build();

// 2. Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseHttpsRedirection();

app.UseCors("AllowAll"); // Apply CORS policy

// Custom Middleware
app.UseMiddleware<ErrorHandlingMiddleware>(); // Ensure this is defined

// app.UseAuthentication(); // Add if using ASP.NET Core Identity + JWT
app.UseAuthorization();

app.MapControllers();

app.Run();
```

**`Application/DependencyInjection.cs` (for Application layer DI)**
```csharp
// SchoolManagement.Application/DependencyInjection.cs
using Microsoft.Extensions.DependencyInjection;
using System.Reflection;
using MediatR;
using FluentValidation;
// using SchoolManagement.Application.Behaviours; // For MediatR pipeline behaviours

namespace SchoolManagement.Application
{
    public static class DependencyInjection
    {
        public static IServiceCollection AddApplicationServices(this IServiceCollection services)
        {
            services.AddAutoMapper(Assembly.GetExecutingAssembly());
            services.AddMediatR(cfg => cfg.RegisterServicesFromAssembly(Assembly.GetExecutingAssembly()));
            services.AddValidatorsFromAssembly(Assembly.GetExecutingAssembly()); // For FluentValidation

            // Optional: Add MediatR pipeline behaviours for common concerns
            // services.AddTransient(typeof(IPipelineBehavior<,>), typeof(UnhandledExceptionBehaviour<,>));
            // services.AddTransient(typeof(IPipelineBehavior<,>), typeof(ValidationBehaviour<,>));
            // services.AddTransient(typeof(IPipelineBehavior<,>), typeof(LoggingBehaviour<,>));


            return services;
        }
    }
}
```

### 7. Next Steps & Further Considerations:

*   **Implement ASP.NET Core Identity:** For robust user management and authentication.
*   **JWT Implementation:** Secure your API endpoints.
*   **FluentValidation:** Add comprehensive validation rules for all DTOs/Commands.
*   **Global Error Handling Middleware:** Create a middleware to catch exceptions and return standardized JSON error responses.
*   **Logging:** Integrate Serilog.
*   **Unit & Integration Tests:** Write tests for all layers.
*   **Complete other features:** Implement remaining modules (Teachers, Courses, Timetable, etc.).
*   **API Versioning:** Plan for API versioning if breaking changes are anticipated.
*   **Deployment Strategy:** Docker, Kubernetes, Azure App Service, AWS Elastic Beanstalk.
*   **CI/CD Pipeline:** Set up automated build, test, and deployment.

This comprehensive design provides a solid foundation for building a scalable and robust School Management System. The Clean Architecture ensures that the system remains maintainable and adaptable to future changes. The code snippets give a starting point for implementation. Remember to flesh out all entities, relationships, use cases, and error handling thoroughly.


Okay, let's generate code snippets and explanations for some of these critical "next steps."

**Assumptions:**
*   You have the project structure from the previous response (Domain, Application, Infrastructure, Api).
*   You're using .NET 6/7/8.

---

### 1. Implement ASP.NET Core Identity & 2. JWT Implementation

We'll combine these as they are closely related for API authentication.

#### a. Update `SchoolManagement.Domain` (Optional User Extension)

If you need custom properties on your user, extend `IdentityUser`.
**`Domain/Entities/ApplicationUser.cs`**
```csharp
using Microsoft.AspNetCore.Identity;

namespace SchoolManagement.Domain.Entities
{
    // Use Guid for primary key if your other entities use Guid
    public class ApplicationUser : IdentityUser<Guid>
    {
        public string? FirstName { get; set; }
        public string? LastName { get; set; }
        // Add any other custom properties
    }
}
```
If you don't need custom properties, you can just use `IdentityUser<Guid>` directly in your DbContext.

#### b. Update `SchoolManagement.Infrastructure`

**`Infrastructure/Identity/SchoolIdentityDbContext.cs` (or modify `SchoolDbContext`)**

It's often cleaner to keep Identity in its own DbContext or merge it. For simplicity, let's assume you merge it into `SchoolDbContext`.

Modify **`Infrastructure/Persistence/SchoolDbContext.cs`**:
```csharp
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Identity.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore;
using SchoolManagement.Domain.Entities; // For ApplicationUser and your other entities
using System.Reflection;

namespace SchoolManagement.Infrastructure.Persistence
{
    // Use Guid as the type for primary keys for Identity tables
    public class SchoolDbContext : IdentityDbContext<ApplicationUser, IdentityRole<Guid>, Guid>
    {
        public SchoolDbContext(DbContextOptions<SchoolDbContext> options) : base(options)
        {
        }

        // Your existing DbSets
        public DbSet<Student> Students { get; set; }
        public DbSet<Teacher> Teachers { get; set; }
        public DbSet<Course> Courses { get; set; }
        public DbSet<Class> Classes { get; set; }
        public DbSet<Enrollment> Enrollments { get; set; }
        public DbSet<Attendance> Attendances { get; set; }
        // ... other DbSets

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            base.OnModelCreating(modelBuilder); // This is important for Identity tables
            modelBuilder.ApplyConfigurationsFromAssembly(Assembly.GetExecutingAssembly());

            // Configure Identity table names if desired (optional)
            modelBuilder.Entity<ApplicationUser>(entity => { entity.ToTable(name: "Users"); });
            modelBuilder.Entity<IdentityRole<Guid>>(entity => { entity.ToTable(name: "Roles"); });
            modelBuilder.Entity<IdentityUserRole<Guid>>(entity => { entity.ToTable("UserRoles"); });
            modelBuilder.Entity<IdentityUserClaim<Guid>>(entity => { entity.ToTable("UserClaims"); });
            modelBuilder.Entity<IdentityUserLogin<Guid>>(entity => { entity.ToTable("UserLogins"); });
            modelBuilder.Entity<IdentityRoleClaim<Guid>>(entity => { entity.ToTable("RoleClaims"); });
            modelBuilder.Entity<IdentityUserToken<Guid>>(entity => { entity.ToTable("UserTokens"); });


            // Example of a simple relationship configuration (if not using separate config files)
            modelBuilder.Entity<Student>()
                .HasOne(s => s.Class)
                .WithMany(c => c.Students)
                .HasForeignKey(s => s.ClassId)
                .OnDelete(DeleteBehavior.SetNull);
        }

        // Your SaveChangesAsync override for AuditableEntity remains the same
        public override Task<int> SaveChangesAsync(CancellationToken cancellationToken = default)
        {
            foreach (var entry in ChangeTracker.Entries<AuditableEntity>())
            {
                switch (entry.State)
                {
                    case EntityState.Added:
                        entry.Entity.CreatedAt = DateTime.UtcNow;
                        break;
                    case EntityState.Modified:
                        entry.Entity.LastModifiedAt = DateTime.UtcNow;
                        break;
                }
            }
            return base.SaveChangesAsync(cancellationToken);
        }
    }
}
```

**Update `Infrastructure/DependencyInjection.cs`**:
```csharp
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.AspNetCore.Identity;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.IdentityModel.Tokens;
using SchoolManagement.Application.Contracts.Persistence;
using SchoolManagement.Domain.Entities; // For ApplicationUser
using SchoolManagement.Domain.Interfaces.Repositories;
using SchoolManagement.Infrastructure.Persistence;
using SchoolManagement.Infrastructure.Persistence.Repositories;
using System.Text; // For Encoding

namespace SchoolManagement.Infrastructure
{
    public static class DependencyInjection
    {
        public static IServiceCollection AddInfrastructureServices(this IServiceCollection services, IConfiguration configuration)
        {
            // Database Context
            services.AddDbContext<SchoolDbContext>(options =>
                options.UseSqlServer(configuration.GetConnectionString("DefaultConnection"),
                    b => b.MigrationsAssembly(typeof(SchoolDbContext).Assembly.FullName)));

            // ASP.NET Core Identity
            services.AddIdentity<ApplicationUser, IdentityRole<Guid>>(options =>
                {
                    options.Password.RequireDigit = true;
                    options.Password.RequireLowercase = true;
                    options.Password.RequireUppercase = true;
                    options.Password.RequireNonAlphanumeric = false; // Adjust as needed
                    options.Password.RequiredLength = 8;
                    options.User.RequireUniqueEmail = true;
                    // Lockout settings
                    options.Lockout.DefaultLockoutTimeSpan = TimeSpan.FromMinutes(5);
                    options.Lockout.MaxFailedAccessAttempts = 5;
                    options.Lockout.AllowedForNewUsers = true;
                })
                .AddEntityFrameworkStores<SchoolDbContext>()
                .AddDefaultTokenProviders(); // For password reset, 2FA tokens

            // JWT Authentication
            services.AddAuthentication(options =>
            {
                options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
                options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
                options.DefaultScheme = JwtBearerDefaults.AuthenticationScheme;
            })
            .AddJwtBearer(options =>
            {
                options.SaveToken = true;
                options.RequireHttpsMetadata = false; // In production, set to true
                options.TokenValidationParameters = new TokenValidationParameters()
                {
                    ValidateIssuer = true,
                    ValidateAudience = true,
                    ValidateLifetime = true,
                    ValidateIssuerSigningKey = true,
                    ValidIssuer = configuration["Jwt:Issuer"],
                    ValidAudience = configuration["Jwt:Audience"],
                    IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(configuration["Jwt:Key"]!)),
                    ClockSkew = TimeSpan.Zero // Removes default 5-min clock skew
                };
            });

            // Repositories & Unit of Work
            services.AddScoped(typeof(IGenericRepository<>), typeof(GenericRepository<>));
            services.AddScoped<IStudentRepository, StudentRepository>();
            services.AddScoped<IUnitOfWork, UnitOfWork>();

            return services;
        }
    }
}
```

#### c. Update `SchoolManagement.Application`

**`Application/DTOs/AuthDtos.cs`**
```csharp
using System.ComponentModel.DataAnnotations;

namespace SchoolManagement.Application.DTOs
{
    public class RegisterRequest
    {
        [Required]
        public string Username { get; set; } = string.Empty;
        [Required]
        [EmailAddress]
        public string Email { get; set; } = string.Empty;
        [Required]
        public string Password { get; set; } = string.Empty;
        public string? FirstName { get; set; }
        public string? LastName { get; set; }
    }

    public class LoginRequest
    {
        [Required]
        public string UsernameOrEmail { get; set; } = string.Empty;
        [Required]
        public string Password { get; set; } = string.Empty;
    }

    public class AuthResponse
    {
        public string UserId { get; set; } = string.Empty;
        public string Username { get; set; } = string.Empty;
        public string Email { get; set; } = string.Empty;
        public List<string> Roles { get; set; } = new List<string>();
        public string Token { get; set; } = string.Empty;
        public DateTime ExpiresAt { get; set; }
    }
}
```

#### d. Update `SchoolManagement.Api`

**`Api/appsettings.json` (and `appsettings.Development.json`)**
```json
{
  "ConnectionStrings": {
    "DefaultConnection": "Server=(localdb)\\mssqllocaldb;Database=SchoolManagementDb;Trusted_Connection=True;MultipleActiveResultSets=true"
  },
  "Jwt": {
    "Key": "THIS IS A SUPER SECRET KEY FOR JWT TOKEN GENERATION - REPLACE IT!", // Store in User Secrets or Key Vault
    "Issuer": "https://localhost:7001", // Your API's base URL
    "Audience": "https://localhost:7001", // Your API's base URL or specific client
    "DurationInMinutes": 60
  },
  "Logging": {
    // ... (Serilog config will go here later)
  },
  "AllowedHosts": "*"
}
```
**IMPORTANT:** The `Jwt:Key` should be strong and stored securely (User Secrets for dev, Azure Key Vault/AWS Secrets Manager for prod).

**`Api/Controllers/AuthController.cs`**
```csharp
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Mvc;
using Microsoft.IdentityModel.Tokens;
using SchoolManagement.Application.DTOs;
using SchoolManagement.Domain.Entities; // For ApplicationUser
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Text;

namespace SchoolManagement.Api.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class AuthController : ControllerBase
    {
        private readonly UserManager<ApplicationUser> _userManager;
        private readonly SignInManager<ApplicationUser> _signInManager; // Not strictly needed for token-based auth login
        private readonly RoleManager<IdentityRole<Guid>> _roleManager;
        private readonly IConfiguration _configuration;

        public AuthController(
            UserManager<ApplicationUser> userManager,
            SignInManager<ApplicationUser> signInManager,
            RoleManager<IdentityRole<Guid>> roleManager,
            IConfiguration configuration)
        {
            _userManager = userManager;
            _signInManager = signInManager;
            _roleManager = roleManager;
            _configuration = configuration;
        }

        [HttpPost("register")]
        [ProducesResponseType(typeof(AuthResponse), StatusCodes.Status200OK)]
        [ProducesResponseType(StatusCodes.Status400BadRequest)]
        public async Task<IActionResult> Register([FromBody] RegisterRequest model)
        {
            var userExists = await _userManager.FindByNameAsync(model.Username);
            if (userExists != null)
                return BadRequest(new { Message = "Username already exists." });

            userExists = await _userManager.FindByEmailAsync(model.Email);
            if (userExists != null)
                return BadRequest(new { Message = "Email already exists." });

            var user = new ApplicationUser
            {
                Id = Guid.NewGuid(), // Explicitly set Guid if not DB generated for IdentityUser<Guid>
                UserName = model.Username,
                Email = model.Email,
                FirstName = model.FirstName,
                LastName = model.LastName,
                EmailConfirmed = true // Or implement email confirmation flow
            };

            var result = await _userManager.CreateAsync(user, model.Password);

            if (!result.Succeeded)
            {
                return BadRequest(new { Message = "User creation failed.", Errors = result.Errors.Select(e => e.Description) });
            }

            // Optional: Assign a default role
            // if (!await _roleManager.RoleExistsAsync("Student"))
            //    await _roleManager.CreateAsync(new IdentityRole<Guid>("Student"));
            // await _userManager.AddToRoleAsync(user, "Student");

            return Ok(new { Message = "User created successfully. Please login." });
        }

        [HttpPost("login")]
        [ProducesResponseType(typeof(AuthResponse), StatusCodes.Status200OK)]
        [ProducesResponseType(StatusCodes.Status401Unauthorized)]
        public async Task<IActionResult> Login([FromBody] LoginRequest model)
        {
            var user = await _userManager.FindByNameAsync(model.UsernameOrEmail)
                       ?? await _userManager.FindByEmailAsync(model.UsernameOrEmail);

            if (user != null && await _userManager.CheckPasswordAsync(user, model.Password))
            {
                var authClaims = new List<Claim>
                {
                    new Claim(JwtRegisteredClaimNames.Sub, user.Id.ToString()), // Subject (user ID)
                    new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()), // JWT ID
                    new Claim(JwtRegisteredClaimNames.Email, user.Email!),
                    new Claim(ClaimTypes.Name, user.UserName!)
                };

                var userRoles = await _userManager.GetRolesAsync(user);
                foreach (var userRole in userRoles)
                {
                    authClaims.Add(new Claim(ClaimTypes.Role, userRole));
                }

                var authSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_configuration["Jwt:Key"]!));
                var tokenValidityInMinutes = _configuration.GetValue<int>("Jwt:DurationInMinutes");
                var tokenExpiry = DateTime.UtcNow.AddMinutes(tokenValidityInMinutes);

                var tokenDescriptor = new SecurityTokenDescriptor
                {
                    Subject = new ClaimsIdentity(authClaims),
                    Expires = tokenExpiry,
                    Issuer = _configuration["Jwt:Issuer"],
                    Audience = _configuration["Jwt:Audience"],
                    SigningCredentials = new SigningCredentials(authSigningKey, SecurityAlgorithms.HmacSha256)
                };

                var tokenHandler = new JwtSecurityTokenHandler();
                var token = tokenHandler.CreateToken(tokenDescriptor);

                return Ok(new AuthResponse
                {
                    UserId = user.Id.ToString(),
                    Username = user.UserName!,
                    Email = user.Email!,
                    Roles = userRoles.ToList(),
                    Token = tokenHandler.WriteToken(token),
                    ExpiresAt = token.ValidTo
                });
            }
            return Unauthorized(new { Message = "Invalid username/email or password." });
        }
    }
}
```

**Update `Api/Program.cs`**:
```csharp
// ... (existing usings)
using SchoolManagement.Application;
using SchoolManagement.Infrastructure;
using SchoolManagement.Api.Middleware; // For ErrorHandlingMiddleware

var builder = WebApplication.CreateBuilder(args);

// 1. Add services to the container.
builder.Services.AddApplicationServices();
builder.Services.AddInfrastructureServices(builder.Configuration); // This now includes Identity & JWT setup

builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen(options => // Swagger JWT configuration
{
    options.AddSecurityDefinition("Bearer", new Microsoft.OpenApi.Models.OpenApiSecurityScheme
    {
        Name = "Authorization",
        Type = Microsoft.OpenApi.Models.SecuritySchemeType.Http,
        Scheme = "Bearer",
        BearerFormat = "JWT",
        In = Microsoft.OpenApi.Models.ParameterLocation.Header,
        Description = "JWT Authorization header using the Bearer scheme. Example: \"Authorization: Bearer {token}\""
    });
    options.AddSecurityRequirement(new Microsoft.OpenApi.Models.OpenApiSecurityRequirement
    {
        {
            new Microsoft.OpenApi.Models.OpenApiSecurityScheme
            {
                Reference = new Microsoft.OpenApi.Models.OpenApiReference
                {
                    Type = Microsoft.OpenApi.Models.ReferenceType.SecurityScheme,
                    Id = "Bearer"
                }
            },
            new string[] {}
        }
    });
});


builder.Services.AddCors(options => /* ... */);

var app = builder.Build();

// 2. Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseHttpsRedirection();
app.UseCors("AllowAll");

// app.UseMiddleware<ErrorHandlingMiddleware>(); // Will add this later

app.UseAuthentication(); // <<<<< ADD THIS (Order matters: before Authorization)
app.UseAuthorization();  // <<<<< ADD THIS

app.MapControllers();

app.Run();
```

**To test:**
1.  Run `Add-Migration InitialIdentitySetup -Context SchoolDbContext`
2.  Run `Update-Database -Context SchoolDbContext`
3.  Use Postman/Swagger to hit `/api/auth/register` then `/api/auth/login`.
4.  Use the returned token in the Authorization header (`Bearer <token>`) for subsequent requests to protected endpoints.
    Example protected endpoint (add `[Authorize]` attribute):
    ```csharp
    // In StudentsController.cs
    [Authorize] // Or [Authorize(Roles = "Admin,Teacher")]
    [HttpGet("me")]
    public IActionResult GetMyInfo()
    {
        var userId = User.FindFirstValue(ClaimTypes.NameIdentifier); // Get user ID from token
        var userName = User.Identity?.Name;
        // ... fetch more user info if needed
        return Ok(new { UserId = userId, UserName = userName, Claims = User.Claims.Select(c => new { c.Type, c.Value }) });
    }
    ```

---

### 3. FluentValidation

**Install NuGet Package:** `FluentValidation.AspNetCore` in `SchoolManagement.Application` project.

**`Application/Features/Students/Commands/CreateStudent/CreateStudentCommandValidator.cs`**
```csharp
using FluentValidation;
using SchoolManagement.Application.Contracts.Persistence; // For IUnitOfWork
using System.Threading; // For CancellationToken
using System.Threading.Tasks; // For Task

namespace SchoolManagement.Application.Features.Students.Commands.CreateStudent
{
    public class CreateStudentCommandValidator : AbstractValidator<CreateStudentCommand>
    {
        private readonly IUnitOfWork _unitOfWork; // Assuming you have IUnitOfWork for db checks

        public CreateStudentCommandValidator(IUnitOfWork unitOfWork)
        {
            _unitOfWork = unitOfWork;

            RuleFor(p => p.FirstName)
                .NotEmpty().WithMessage("{PropertyName} is required.")
                .NotNull()
                .MaximumLength(50).WithMessage("{PropertyName} must not exceed 50 characters.");

            RuleFor(p => p.LastName)
                .NotEmpty().WithMessage("{PropertyName} is required.")
                .NotNull()
                .MaximumLength(50).WithMessage("{PropertyName} must not exceed 50 characters.");

            RuleFor(p => p.Email)
                .NotEmpty().WithMessage("{PropertyName} is required.")
                .EmailAddress().WithMessage("A valid {PropertyName} is required.")
                .MustAsync(BeUniqueEmail).WithMessage("The specified {PropertyName} already exists.");

            RuleFor(p => p.DateOfBirth)
                .NotEmpty().WithMessage("{PropertyName} is required.")
                .LessThan(DateTime.Now.AddYears(-3)).WithMessage("Student must be at least 3 years old."); // Example rule
        }

        private async Task<bool> BeUniqueEmail(string email, CancellationToken cancellationToken)
        {
            // In a real app, you'd check the repository
            var student = await _unitOfWork.StudentRepository.GetStudentByEmailAsync(email);
            return student == null;
        }
    }
}
```

**Update `Application/DependencyInjection.cs`**:
```csharp
using Microsoft.Extensions.DependencyInjection;
using System.Reflection;
using MediatR;
using FluentValidation; // <<<<< ADD THIS
using FluentValidation.AspNetCore; // <<<<< ADD THIS (for older .NET versions, not always needed for AddFluentValidationAutoValidation in .NET 6+)

namespace SchoolManagement.Application
{
    public static class DependencyInjection
    {
        public static IServiceCollection AddApplicationServices(this IServiceCollection services)
        {
            services.AddAutoMapper(Assembly.GetExecutingAssembly());
            services.AddMediatR(cfg => cfg.RegisterServicesFromAssembly(Assembly.GetExecutingAssembly()));

            // FluentValidation - registers all validators from the assembly
            services.AddValidatorsFromAssembly(Assembly.GetExecutingAssembly());
            // For automatic validation in controllers with [ApiController]
            // services.AddFluentValidationAutoValidation(); // For ASP.NET Core MVC controllers
            // services.AddFluentValidationClientsideAdapters(); // For client-side (if using MVC views)

            return services;
        }
    }
}
```
**Update `Api/Program.cs` (if not already covered by AddApplicationServices)**:
If you are using Minimal APIs or want to explicitly configure it for controllers:
```csharp
// In Program.cs, after builder.Services.AddControllers();
builder.Services.AddFluentValidationAutoValidation(); // Enables auto-validation for [ApiController]
// builder.Services.AddFluentValidationClientsideAdapters(); // If using MVC views
```
Now, when a `CreateStudentCommand` is posted to your controller, ASP.NET Core (if `AddFluentValidationAutoValidation()` is called or if you are using `[ApiController]` with MVC conventions and validators are registered) will automatically validate it. If invalid, it returns a 400 Bad Request with error details.

Your `CreateStudentCommandHandler` can remove manual validation:
```csharp
// SchoolManagement.Application/Features/Students/Commands/CreateStudent/CreateStudentCommandHandler.cs
// ...
public async Task<StudentDto> Handle(CreateStudentCommand request, CancellationToken cancellationToken)
{
    // 1. Validation is now handled automatically by ASP.NET Core + FluentValidation
    //    If you need to manually trigger validation (e.g., in a service layer without HTTP context):
    //    var validationResult = await _validator.ValidateAsync(request);
    //    if (!validationResult.IsValid)
    //        throw new ValidationException(validationResult.Errors);


    // No need for this check if the validator handles it:
    // var existingStudent = await _unitOfWork.StudentRepository.GetStudentByEmailAsync(request.Email);
    // if (existingStudent != null)
    // {
    //     throw new ArgumentException($"Student with email {request.Email} already exists.");
    // }

    // 2. Map to Domain Entity
    var student = _mapper.Map<Student>(request);
    // ... rest of the logic
}
```

---

### 4. Global Error Handling Middleware

**`Api/Middleware/ErrorHandlingMiddleware.cs`**
```csharp
using System.Net;
using System.Text.Json;
using FluentValidation; // For ValidationException from FluentValidation
using SchoolManagement.Application.Exceptions; // For custom exceptions like NotFoundException

namespace SchoolManagement.Api.Middleware
{
    public class ErrorHandlingMiddleware
    {
        private readonly RequestDelegate _next;
        private readonly ILogger<ErrorHandlingMiddleware> _logger;

        public ErrorHandlingMiddleware(RequestDelegate next, ILogger<ErrorHandlingMiddleware> logger)
        {
            _next = next;
            _logger = logger;
        }

        public async Task InvokeAsync(HttpContext context)
        {
            try
            {
                await _next(context);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "An unhandled exception has occurred.");
                await HandleExceptionAsync(context, ex);
            }
        }

        private static Task HandleExceptionAsync(HttpContext context, Exception exception)
        {
            HttpStatusCode statusCode;
            string? message;
            object? errors = null;

            switch (exception)
            {
                case NotFoundException notFoundException:
                    statusCode = HttpStatusCode.NotFound;
                    message = notFoundException.Message;
                    break;
                case FluentValidation.ValidationException validationException: // From FluentValidation
                    statusCode = HttpStatusCode.BadRequest;
                    message = "One or more validation errors occurred.";
                    errors = validationException.Errors.Select(e => new { e.PropertyName, e.ErrorMessage });
                    break;
                case Application.Exceptions.ValidationException appValidationException: // Your custom validation exception
                    statusCode = HttpStatusCode.BadRequest;
                    message = "One or more validation errors occurred.";
                    errors = appValidationException.Errors; // Assuming your custom one has an Errors property
                    break;
                case UnauthorizedAccessException unauthorizedAccessException:
                    statusCode = HttpStatusCode.Unauthorized;
                    message = unauthorizedAccessException.Message;
                    break;
                // Add more custom exception types as needed
                default:
                    statusCode = HttpStatusCode.InternalServerError;
                    message = "An unexpected internal server error has occurred.";
#if DEBUG
                    message = exception.Message; // Show more details in debug
                    errors = exception.StackTrace;
#endif
                    break;
            }

            context.Response.ContentType = "application/json";
            context.Response.StatusCode = (int)statusCode;

            var result = JsonSerializer.Serialize(new { error = message, details = errors });
            return context.Response.WriteAsync(result);
        }
    }
}
```
**Define Custom Exceptions in `SchoolManagement.Application`**:
**`Application/Exceptions/NotFoundException.cs`**
```csharp
namespace SchoolManagement.Application.Exceptions
{
    public class NotFoundException : ApplicationException
    {
        public NotFoundException(string name, object key)
            : base($"Entity \"{name}\" ({key}) was not found.")
        {
        }
         public NotFoundException(string message)
            : base(message)
        {
        }
    }
}
```
**`Application/Exceptions/ValidationException.cs` (if you need a custom one distinct from FluentValidation's)**
```csharp
namespace SchoolManagement.Application.Exceptions
{
    public class ValidationException : ApplicationException
    {
        public IDictionary<string, string[]> Errors { get; }

        public ValidationException()
            : base("One or more validation failures have occurred.")
        {
            Errors = new Dictionary<string, string[]>();
        }

        public ValidationException(IDictionary<string, string[]> errors)
            : this()
        {
            Errors = errors;
        }
        // Constructor if you're not using FluentValidation's structure
        public ValidationException(string message) : base(message)
        {
             Errors = new Dictionary<string, string[]>();
        }
    }
}
```
**Update `Api/Program.cs` to use the middleware:**
```csharp
// ...
var app = builder.Build();

// Configure the HTTP request pipeline.

// Middleware order is important!
app.UseMiddleware<ErrorHandlingMiddleware>(); // <<<<< ADD THIS (early in the pipeline)

if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}
// ... rest of the pipeline (HttpsRedirection, Cors, Auth, etc.)
app.UseHttpsRedirection();
app.UseCors("AllowAll");

app.UseAuthentication();
app.UseAuthorization();

app.MapControllers();
app.Run();
```

---

### 5. Logging: Integrate Serilog

**Install NuGet Packages in `SchoolManagement.Api`:**
*   `Serilog.AspNetCore`
*   `Serilog.Sinks.Console`
*   `Serilog.Sinks.File` (optional, for file logging)
*   `Serilog.Settings.Configuration` (to read config from `appsettings.json`)
*   `Serilog.Enrichers.Environment` (optional, useful enricher)
*   `Serilog.Exceptions` (optional, for better exception logging)

**Update `Api/Program.cs`:**
```csharp
using Serilog; // <<<<< ADD THIS
// ... (other usings)

// Configure Serilog immediately, before building the host
Log.Logger = new LoggerConfiguration()
    .WriteTo.Console() // Basic console sink
    // Add more sinks and configurations here later, or read from appsettings.json
    .CreateBootstrapLogger(); // Use bootstrap logger for early logging, then replace with full config

try
{
    var builder = WebApplication.CreateBuilder(args);

    // Replace default .NET logging with Serilog
    builder.Host.UseSerilog((context, services, configuration) => configuration
        .ReadFrom.Configuration(context.Configuration) // Reads "Serilog" section from appsettings.json
        .ReadFrom.Services(services) // Allows services to be injected into custom sinks/enrichers
        .Enrich.FromLogContext()
        .Enrich.WithMachineName()
        .Enrich.WithThreadId()
        .Enrich.WithProperty("ApplicationName", "SchoolManagementAPI")
        // Add more enrichers as needed (e.g., .Enrich.WithExceptionDetails() from Serilog.Exceptions)
        // .WriteTo.Console() // Can be configured in appsettings.json
        // .WriteTo.File("logs/school-app-.log", rollingInterval: RollingInterval.Day) // Can be configured in appsettings.json
    );


    // 1. Add services to the container.
    builder.Services.AddApplicationServices();
    // ... (rest of service configuration)

    var app = builder.Build();

    // ... (rest of pipeline configuration)
    app.Run();
}
catch (Exception ex)
{
    Log.Fatal(ex, "Application terminated unexpectedly");
}
finally
{
    Log.CloseAndFlush();
}
```

**Update `Api/appsettings.json`:**
```json
{
  // ... (ConnectionStrings, Jwt)
  "Serilog": {
    "MinimumLevel": {
      "Default": "Information", // Log Info and higher by default
      "Override": {
        "Microsoft": "Warning", // Quieten down Microsoft logs
        "Microsoft.Hosting.Lifetime": "Information",
        "System": "Warning"
      }
    },
    "Enrich": ["FromLogContext", "WithMachineName", "WithThreadId"],
    "WriteTo": [
      { "Name": "Console" },
      {
        "Name": "File",
        "Args": {
          "path": "logs/applog-.txt", // Log file path
          "rollingInterval": "Day", // Create new log file daily
          "retainedFileCountLimit": 7, // Keep last 7 log files
          "outputTemplate": "{Timestamp:yyyy-MM-dd HH:mm:ss.fff zzz} [{Level:u3}] {Message:lj}{NewLine}{Exception}"
        }
      }
      // {
      //   "Name": "Seq", // Example for Seq logging server
      //   "Args": { "serverUrl": "http://localhost:5341" }
      // }
    ],
    "Properties": {
      "Application": "SchoolManagementAPI"
    }
  },
  "Logging": { // Keep this for default .NET logging if Serilog fails to initialize
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*"
}
```

**Usage in a service/controller:**
```csharp
// In any class where you have ILogger injected
public class SomeService
{
    private readonly ILogger<SomeService> _logger;
    public SomeService(ILogger<SomeService> logger)
    {
        _logger = logger;
    }

    public void DoSomething()
    {
        _logger.LogInformation("Doing something interesting with parameter {Parameter}", "myValue");
        try
        {
            // ... some operation that might fail
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "An error occurred while doing something.");
        }
    }
}
```

---

The remaining points (Unit/Integration Tests, Completing Features, API Versioning, Deployment, CI/CD) are broader topics.
*   **Unit & Integration Tests:** Use xUnit or MSTest. For unit tests, mock dependencies (e.g., with Moq). For integration tests, you might use `WebApplicationFactory` and an in-memory database or testcontainer.
*   **API Versioning:** Use `Microsoft.AspNetCore.Mvc.Versioning` NuGet package.
*   **Deployment & CI/CD:** These are platform-specific (Azure DevOps, GitHub Actions, Jenkins, etc.) and involve scripting builds, tests, and deployments.

This provides a substantial amount of code and configuration to get you started on these crucial aspects! Remember to adapt paths, names, and specific configurations to your exact project setup.