অবশ্যই! আগের ১০০টি CSS প্রপার্টির পর পরবর্তী ১০০টি প্রপার্টির উদাহরণ এবং ব্যাখ্যা নিচে দেওয়া হলো:

---

101. **`flex-flow`**: `flex-direction` এবং `flex-wrap` প্রপার্টি একসাথে লেখার শর্টহ্যান্ড।
 ```css
    .flex-container {
        display: flex;
        flex-flow: column wrap; /* আইটেমগুলো উল্লম্বভাবে সাজানো হবে এবং প্রয়োজনে একাধিক কলামে মোড়াবে */
        height: 200px; /* মোড়ানো দেখতে উচ্চতা প্রয়োজন */
    }
    ```

102. **`flex-grow`**: একটি ফ্লেক্স আইটেম কন্টেইনারে অতিরিক্ত ফাঁকা জায়গা থাকলে অন্য ফ্লেক্স আইটেমগুলোর তুলনায় কতটুকু বৃদ্ধি পাবে (grow) তার অনুপাত নির্ধারণ করে।
```css
    .flex-container { display: flex; width: 300px; }
    .item1 { flex-grow: 1; background-color: lightblue; } /* ফাঁকা জায়গার ১ ভাগ নেবে */
    .item2 { flex-grow: 2; background-color: lightgreen; } /* ফাঁকা জায়গার ২ ভাগ নেবে */
    ```
    **ব্যাখ্যা:** `.item2` `.item1` এর চেয়ে দ্বিগুণ পরিমাণ অতিরিক্ত জায়গা নেবে।

103. **`flex-shrink`**: কন্টেইনারে পর্যাপ্ত জায়গা না থাকলে একটি ফ্লেক্স আইটেম অন্য ফ্লেক্স আইটেমগুলোর তুলনায় কতটুকু সংকুচিত (shrink) হবে তার অনুপাত নির্ধারণ করে।
 ```css
    .flex-container { display: flex; width: 200px; }
    .itemA { width: 150px; flex-shrink: 1; background-color: lightcoral; } /* প্রয়োজন হলে ১ অনুপাতে সংকুচিত হবে */
    .itemB { width: 150px; flex-shrink: 0; background-color: lightyellow; } /* সংকুচিত হবে না, ১৫০px থাকবে */
    ```
    **ব্যাখ্যা:** যদি কন্টেইনারের প্রস্থ ৩০০px এর কম হয়, `.itemA` সংকুচিত হবে কিন্তু `.itemB` তার ১৫০px প্রস্থ ধরে রাখার চেষ্টা করবে।

104. **`flex-wrap`**: ফ্লেক্স আইটেমগুলো কন্টেইনারে এক লাইনে সংকুলান না হলে সেগুলো নতুন লাইনে মোড়াবে (`wrap`) কিনা, নাকি এক লাইনেই থাকবে (`nowrap`, ডিফল্ট), অথবা উল্টো দিকে মোড়াবে (`wrap-reverse`) তা নির্ধারণ করে।
```css
    .flex-container-wrap {
        display: flex;
        width: 200px; /* কন্টেইনারের প্রস্থ আইটেমগুলোর মোট প্রস্থের চেয়ে কম */
        flex-wrap: wrap; /* আইটেমগুলো নতুন লাইনে মোড়াবে */
    }
    .flex-item { width: 80px; height: 50px; background-color: lightblue; margin: 5px; }
    ```

105. **`float`**: একটি এলিমেন্টকে তার স্বাভাবিক প্রবাহ থেকে বের করে বামে (`left`) বা ডানে (`right`) ভাসিয়ে দেয় এবং তার চারপাশের কন্টেন্টকে তার পাশে প্রবাহিত হতে দেয়।
```css
    img.float-left {
        float: left;
        margin-right: 15px; /* ছবির ডানে কিছুটা ফাঁকা জায়গা */
        margin-bottom: 5px;
    }
    .clearfix::after { /* ফ্লোট ক্লিয়ার করার একটি সাধারণ পদ্ধতি */
      content: "";
      clear: both;
      display: table;
    }
 ```
    **ব্যাখ্যা:** ছবিটি বাম দিকে ভাসবে এবং টেক্সট তার ডান দিক দিয়ে প্রবাহিত হবে।

106. **`font`**: ফন্টের বিভিন্ন প্রপার্টি (যেমন `font-style`, `font-variant`, `font-weight`, `font-size/line-height`, `font-family`) একসাথে লেখার শর্টহ্যান্ড।
```css
    body {
        font: italic small-caps bold 16px/1.5 Arial, sans-serif;
        /* style variant weight size/line-height family */
    }
    p {
        font: 1em "Times New Roman", serif; /* শুধু size এবং family */
    }
    ```
    **গুরুত্বপূর্ণ:** `font-size` এবং `font-family` এই শর্টহ্যান্ডে অবশ্যই উল্লেখ করতে হবে।

107. **`font-family`**: টেক্সটের জন্য এক বা একাধিক ফন্ট পরিবারের (font family) একটি অগ্রাধিকার তালিকা নির্ধারণ করে। ব্রাউজার তালিকা থেকে প্রথম উপলব্ধ ফন্টটি ব্যবহার করবে।
```css
    h1 {
        font-family: "Georgia", "Times New Roman", serif; /* প্রথমে Georgia, না পেলে Times, না পেলে যেকোনো serif ফন্ট */
    }
    p {
        font-family: "Helvetica Neue", Arial, sans-serif;
    }
    ```

108. **`font-feature-settings`**: OpenType ফন্টের অ্যাডভান্সড টাইপোগ্রাফিক বৈশিষ্ট্যগুলো (যেমন লিগ্যাচার, কার্নিং, বিকল্প অক্ষর) নিয়ন্ত্রণ করার জন্য নিম্ন-স্তরের অ্যাক্সেস প্রদান করে।
 ```css
    .fancy-text {
        font-family: "MyOpenTypeFont";
        font-feature-settings: "liga" on, "kern" on, "salt" 1; /* লিগ্যাচার ও কার্নিং অন, স্টাইলিস্টিক বিকল্প ১ ব্যবহার */
    }
    ```
    **ব্যাখ্যা:** এটি অ্যাডভান্সড ব্যবহারের জন্য এবং নির্দিষ্ট ফন্টের উপর নির্ভরশীল।

109. **`font-kerning`**: ফন্টের মধ্যে কার্নিং (নির্দিষ্ট অক্ষর জোড়ার মধ্যে স্বয়ংক্রিয় ফাঁক সমন্বয়) সক্রিয় (`auto` বা `normal`) বা নিষ্ক্রিয় (`none`) করা হবে কিনা তা নিয়ন্ত্রণ করে।
```css
    .kerning-example {
        font-family: "SomeProfessionalFont";
        font-kerning: normal; /* ফন্টের ডিফল্ট কার্নিং ব্যবহার করবে (যদি থাকে) */
    }
    .no-kerning {
        font-kerning: none; /* কার্নিং নিষ্ক্রিয় করবে */
    }
    ```

110. **`font-language-override`**: ফন্টের মধ্যে ভাষা-নির্দিষ্ট গ্লিফ (অক্ষরের রূপ) ব্যবহারের জন্য `lang` অ্যাট্রিবিউটের মানকে ওভাররাইড করে।
```css
    .turkish-i {
        font-family: "SomeFontWithTurkishGlyphs";
        font-language-override: "TRK"; /* তুর্কি ভাষার গ্লিফ ব্যবহার করতে বাধ্য করবে */
    }
    ```
    **ব্যাখ্যা:** এটি খুবই বিরল ক্ষেত্রে ব্যবহৃত হয়।

111. **`font-optical-sizing`**: ফন্টটি অপটিক্যাল সাইজিং সমর্থন করলে (অর্থাৎ বিভিন্ন আকারে অক্ষরের ডিজাইন সামান্য পরিবর্তিত হয় পাঠযোগ্যতা বাড়ানোর জন্য) সেটি সক্রিয় (`auto`, ডিফল্ট) বা নিষ্ক্রিয় (`none`) করা হবে কিনা তা নিয়ন্ত্রণ করে।
```css
    body {
        font-family: "VariableFontWithOpticalSize";
        font-optical-sizing: auto; /* ফন্ট অপটিক্যাল সাইজিং ব্যবহার করবে */
    }
    ```

112. **`font-size`**: টেক্সটের আকার নির্ধারণ করে (যেমন `px`, `em`, `rem`, `%`, `pt`, কীওয়ার্ড যেমন `small`, `large`)।
```css
    p {
        font-size: 16px; /* পিক্সেল এককে */
    }
    h1 {
        font-size: 2.5em; /* প্যারেন্ট এলিমেন্টের ফন্ট সাইজের ২.৫ গুণ */
    }
    small {
        font-size: smaller; /* প্যারেন্টের চেয়ে ছোট */
    }
    ```

113. **`font-size-adjust`**: বিভিন্ন ফন্টের মধ্যে "x-height" (ছোট হাতের 'x' অক্ষরের উচ্চতা) এর ভিন্নতার কারণে পাঠযোগ্যতার তারতম্য কমাতে সাহায্য করে। এটি একটি সংখ্যামান নেয় যা "aspect value" নির্দেশ করে।
```css
    body {
        font-family: Verdana, Arial, sans-serif;
        font-size: 16px;
        font-size-adjust: 0.5; /* যদি Verdana না পাওয়া যায়, অন্য ফন্টের x-height সমন্বয় করবে */
    }
    ```
    **ব্যাখ্যা:** এটি কম ব্যবহৃত একটি প্রপার্টি।

114. **`font-stretch`**: ফন্টটি যদি συμπీಡিত (condensed) বা প্রসারিত (extended) রূপ সমর্থন করে, তবে সেটি নির্বাচন করতে দেয় (যেমন `condensed`, `semi-condensed`, `normal`, `semi-expanded`, `expanded`, `ultra-condensed`, `ultra-expanded`)।
```css
    .condensed-text {
        font-family: "InterVariable", sans-serif; /* একটি ভ্যারিয়েবল ফন্ট যা stretch সমর্থন করে */
        font-stretch: condensed;
    }
    .expanded-text {
        font-family: "InterVariable", sans-serif;
        font-stretch: 125%; /* পার্সেন্টেজ মানও ব্যবহার করা যায় */
    }
    ```

115. **`font-style`**: ফন্টের স্টাইল নির্ধারণ করে: `normal` (সাধারণ), `italic` (ইটালিক), বা `oblique` (তির্যক)।
```css
    em, i {
        font-style: italic; /* ইটালিক স্টাইল */
    }
    .oblique-text {
        font-style: oblique 10deg; /* ১০ ডিগ্রি তির্যক (যদি ফন্ট সমর্থন করে) */
    }
    ```

116. **`font-synthesis`**: যখন একটি ফন্টে বোল্ড বা ইটালিক স্টাইল উপলব্ধ না থাকে, তখন ব্রাউজার কৃত্রিমভাবে (synthetically) সেই স্টাইল তৈরি করবে কিনা তা নিয়ন্ত্রণ করে। (এখন `font-synthesis-weight`, `font-synthesis-style`, `font-synthesis-small-caps` এ বিভক্ত)।
```css
    p {
        /* font-synthesis: weight style; পুরনো পদ্ধতি */
        font-synthesis-weight: auto; /* ব্রাউজার প্রয়োজনে কৃত্রিম বোল্ড তৈরি করতে পারবে */
        font-synthesis-style: none; /* ব্রাউজার কৃত্রিম ইটালিক তৈরি করবে না */
    }
    ```
    **ব্যাখ্যা:** ডিফল্ট `auto` থাকে।

117. **`font-variant`**: টেক্সটের বিভিন্ন রূপ (variant) যেমন `small-caps` (ছোট হাতের অক্ষরকে ছোট আকারের বড় হাতের अक्षরের মতো দেখানো) নির্ধারণের জন্য একটি শর্টহ্যান্ড।
```css
    .title-variant {
        font-variant: small-caps;
    }
    /* এটি এখন font-variant-caps, font-variant-numeric ইত্যাদির শর্টহ্যান্ড */
    ```

118. **`font-variant-alternates`**: ফন্টের বিকল্প গ্লিফ (যেমন স্টাইলিস্টিক সেট) ব্যবহারের জন্য। (অ্যাডভান্সড টাইপোগ্রাফি)
 ```css
    .alt-glyphs {
        font-family: "MyFancyFont";
        font-variant-alternates: stylistic(alt-a); /* 'a' অক্ষরের একটি বিকল্প রূপ ব্যবহার করবে (যদি ফন্টে থাকে) */
    }
    ```

119. **`font-variant-caps`**: টেক্সটের ক্যাপিটালাইজেশন নিয়ন্ত্রণ করে (যেমন `small-caps`, `all-small-caps`, `petite-caps`, `unicase`, `titling-caps`)।
```css
    .small-caps-heading {
        font-variant-caps: small-caps;
    }
    .all-small {
        font-variant-caps: all-small-caps;
    }
    ```

120. **`font-variant-east-asian`**: ইস্ট এশিয়ান (যেমন জাপানি, কোরিয়ান, চীনা) ফন্টের বিভিন্ন রূপ (যেমন `jis78`, `jis04`, `simplified`, `traditional`, `ruby`) নিয়ন্ত্রণ করে।
 ```css
    .japanese-text {
        font-variant-east-asian: ruby; /* রুবি টেক্সট (ফurigana) দেখানোর জন্য */
    }
    ```

121. **`font-variant-ligatures`**: ফন্টের লিগ্যাচার (একাধিক অক্ষর একত্রিত হয়ে একটি বিশেষ গ্লিফ তৈরি করা, যেমন 'fi' বা 'fl') নিয়ন্ত্রণ করে (যেমন `common-ligatures`, `discretionary-ligatures`, `historical-ligatures`, `no-common-ligatures`)।
 ```css
    body {
        font-variant-ligatures: common-ligatures; /* সাধারণ লিগ্যাচার (fi, fl) ব্যবহার করবে (ডিফল্ট) */
    }
    .fancy-ligatures {
        font-variant-ligatures: discretionary-ligatures; /* ঐচ্ছিক সুন্দর লিগ্যাচার (যেমন 'st') ব্যবহার করবে */
    }
    ```

122. **`font-variant-numeric`**: সংখ্যার বিভিন্ন রূপ (যেমন `lining-nums`, `oldstyle-nums`, `proportional-nums`, `tabular-nums`, `diagonal-fractions`, `stacked-fractions`, `ordinal`, `slashed-zero`) নিয়ন্ত্রণ করে।
```css
    .oldstyle-figures {
        font-variant-numeric: oldstyle-nums; /* পুরনো স্টাইলের সংখ্যা (কিছু উপরে কিছু নিচে নামে) */
    }
    .fractions {
        font-variant-numeric: diagonal-fractions; /* যেমন ১/২ কে সুন্দর ভগ্নাংশ আকারে দেখাবে */
    }
    ```

123. **`font-variant-position`**: টেক্সটের সাবস্ক্রিপ্ট (`sub`) বা সুপারস্ক্রিপ্ট (`super`) অবস্থান নিয়ন্ত্রণ করে। (সাধারণত HTML ট্যাগ `<sub>` বা `<sup>` ব্যবহার করাই শ্রেয়)।
```css
    .superscript-css {
        font-variant-position: super;
    }
    .subscript-css {
        font-variant-position: sub;
    }
    ```

124. **`font-weight`**: ফন্টের "ওজন" বা গাঢ়ত্ব (boldness) নির্ধারণ করে। মান হতে পারে `normal`, `bold`, অথবা সংখ্যা (100 থেকে 900, যেখানে 400 হল normal, 700 হল bold)।
```css
    h1 {
        font-weight: bold; /* অথবা 700 */
    }
    p.light-text {
        font-family: "Roboto", sans-serif; /* Roboto ফন্টের বিভিন্ন ওজন আছে */
        font-weight: 300; /* হালকা ওজন */
    }
    strong, b {
        font-weight: bolder; /* প্যারেন্টের চেয়ে বেশি গাঢ় */
    }
    ```

125. **`gap`**: ফ্লেক্সবক্স বা গ্রিড কন্টেইনারে আইটেমগুলোর মধ্যে সারি (`row-gap`) এবং কলাম (`column-gap`) বরাবর ফাঁক নির্ধারণের শর্টহ্যান্ড।
```css
    .grid-container {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 20px 10px; /* সারির মধ্যে ২০px, কলামের মধ্যে ১০px ফাঁক */
    }
    .flex-container-gap {
        display: flex;
        flex-wrap: wrap;
        gap: 15px; /* সারি ও কলাম উভয় দিকে ১৫px ফাঁক */
    }
    ```

126. **`grid`**: গ্রিড লেআউটের অনেকগুলো প্রপার্টি (যেমন `grid-template-rows`, `grid-template-columns`, `grid-template-areas`, `grid-auto-flow`, `grid-auto-rows`, `grid-auto-columns`) একসাথে লেখার একটি জটিল শর্টহ্যান্ড।
```css
    .grid-layout {
        display: grid;
        grid: "header header" auto
              "sidebar main" 1fr / 200px 1fr;
        /* এই শর্টহ্যান্ডটি grid-template-areas, grid-template-rows এবং grid-template-columns সেট করে */
        gap: 10px;
    }
    .header { grid-area: header; background: lightblue;}
    .sidebar { grid-area: sidebar; background: lightgreen;}
    .main { grid-area: main; background: lightcoral;}
    ```
    **ব্যাখ্যা:** এটি একটি শক্তিশালী কিন্তু জটিল শর্টহ্যান্ড।

127. **`grid-area`**: একটি গ্রিড আইটেমকে গ্রিড টেমপ্লেটে (`grid-template-areas` দ্বারা সংজ্ঞায়িত) একটি নির্দিষ্ট নামের এলাকার সাথে যুক্ত করে অথবা তার সারি/কলামের শুরু/শেষ লাইন নির্ধারণ করে।
 ```css
    /* .grid-layout এর উদাহরণের সাথে দেখুন */
    .item-a {
        grid-area: myArea; /* 'myArea' নামের গ্রিড এলাকার সাথে যুক্ত */
    }
    .item-b {
        grid-area: 2 / 1 / 3 / 3; /* row-start / col-start / row-end / col-end */
    }
    ```

128. **`grid-auto-columns`**: গ্রিড কন্টেইনারে যখন কন্টেন্ট সুস্পষ্টভাবে সংজ্ঞায়িত কলামের বাইরে চলে যায় (implicit grid), তখন সেই স্বয়ংক্রিয়ভাবে তৈরি হওয়া কলামগুলোর আকার নির্ধারণ করে।
 ```css
    .auto-cols-grid {
        display: grid;
        grid-template-columns: 100px 100px; /* ২টি সুস্পষ্ট কলাম */
        grid-auto-columns: 50px; /* যদি ৩য় বা তার বেশি আইটেম আসে, তাদের কলাম ৫০px চওড়া হবে */
        gap: 5px;
    }
    .auto-cols-grid div { background: #eee; padding: 5px; }
    ```
    ```html
    <div class="auto-cols-grid">
      <div>1</div><div>2</div><div>3 (auto col)</div><div>4 (auto col)</div>
    </div>
    ```

129. **`grid-auto-flow`**: গ্রিড কন্টেইনারে আইটেমগুলো (বিশেষত যেগুলো নির্দিষ্ট `grid-area` ছাড়া) স্বয়ংক্রিয়ভাবে কীভাবে সাজানো হবে তার অ্যালগরিদম নির্ধারণ করে (`row`, `column`, `dense`)।
```css
    .flow-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        grid-auto-rows: 50px;
        grid-auto-flow: row dense; /* প্রথমে সারি বরাবর বসাবে এবং ফাঁকা জায়গা পূরণের চেষ্টা করবে (dense) */
        gap: 10px;
    }
    ```

130. **`grid-auto-rows`**: গ্রিড কন্টেইনারে স্বয়ংক্রিয়ভাবে তৈরি হওয়া সারিগুলোর (implicit grid) ডিফল্ট উচ্চতা নির্ধারণ করে।
```css
    .auto-rows-grid {
        display: grid;
        grid-template-rows: 100px; /* ১টি সুস্পষ্ট সারি */
        grid-auto-rows: 75px; /* যদি ২য় বা তার বেশি আইটেম আসে, তাদের সারি ৭৫px উঁচু হবে */
        grid-template-columns: 1fr 1fr;
        gap: 5px;
    }
    .auto-rows-grid div { background: #ddd; padding: 5px; }
    ```
    ```html
    <div class="auto-rows-grid">
      <div>Item A1</div><div>Item A2</div>
      <div>Item B1 (auto row)</div><div>Item B2 (auto row)</div>
    </div>
    ```

131. **`grid-column`**: একটি গ্রিড আইটেমের কলামের শুরু এবং শেষ লাইন নির্ধারণের শর্টহ্যান্ড (`grid-column-start / grid-column-end`)।
 ```css
    .grid-container { display: grid; grid-template-columns: repeat(4, 1fr); gap: 5px; }
    .spanned-item {
        grid-column: 2 / 4; /* ২য় কলাম লাইন থেকে শুরু হয়ে ৪র্থ কলাম লাইনের আগে শেষ হবে (অর্থাৎ কলাম ২ এবং ৩ জুড়ে) */
        /* অথবা: grid-column: 2 / span 2; (২য় কলাম থেকে শুরু করে ২টি কলাম জুড়ে) */
        background-color: lightblue;
    }
    .grid-container div { border: 1px solid; }
    ```

132. **`grid-column-end`**: একটি গ্রিড আইটেম কোন কলাম লাইনে শেষ হবে তা নির্ধারণ করে।
```css
    .item-specific-end {
        grid-column-start: 1;
        grid-column-end: 3; /* ৩য় কলাম লাইনের আগে শেষ হবে (অর্থাৎ কলাম ১ এবং ২ জুড়ে) */
        background-color: lightgreen;
    }
    ```

133. **`grid-column-gap`**: (অপ্রচলিত, এর পরিবর্তে `gap` বা `column-gap` ব্যবহার করুন) গ্রিড কলামগুলোর মধ্যে ফাঁক নির্ধারণ করে।
```css
    .old-gap-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        grid-column-gap: 15px; /* অপ্রচলিত */
        /* আধুনিক: column-gap: 15px; বা gap: 10px 15px; */
    }
    ```

134. **`grid-column-start`**: একটি গ্রিড আইটেম কোন কলাম লাইন থেকে শুরু হবে তা নির্ধারণ করে।
```css
    .item-specific-start {
        grid-column-start: 3; /* ৩য় কলাম লাইন থেকে শুরু হবে */
        grid-column-end: 5;
        background-color: lightcoral;
    }
    ```

135. **`grid-gap`**: (অপ্রচলিত, এর পরিবর্তে `gap` ব্যবহার করুন) গ্রিড সারি এবং কলামের মধ্যে ফাঁক নির্ধারণের শর্টহ্যান্ড (`grid-row-gap grid-column-gap`)।
```css
    .old-grid-gap-example {
        display: grid;
        grid-template-columns: 1fr 1fr;
        grid-gap: 20px 30px; /* অপ্রচলিত */
        /* আধুনিক: gap: 20px 30px; */
    }
    ```

136. **`grid-row`**: একটি গ্রিড আইটেমের সারির শুরু এবং শেষ লাইন নির্ধারণের শর্টহ্যান্ড (`grid-row-start / grid-row-end`)।
```css
    .grid-container { display: grid; grid-template-rows: repeat(3, 50px); gap: 5px; }
    .row-spanned-item {
        grid-row: 1 / 3; /* ১ম সারি লাইন থেকে শুরু হয়ে ৩য় সারি লাইনের আগে শেষ হবে (সারি ১ এবং ২ জুড়ে) */
        background-color: lightyellow;
    }
    .grid-container div { border: 1px solid; }
    ```

137. **`grid-row-end`**: একটি গ্রিড আইটেম কোন সারি লাইনে শেষ হবে তা নির্ধারণ করে।
```css
    .item-row-end {
        grid-row-start: 2;
        grid-row-end: 4; /* ৪র্থ সারি লাইনের আগে শেষ হবে */
        background-color: beige;
    }
    ```

138. **`grid-row-gap`**: (অপ্রচলিত, এর পরিবর্তে `gap` বা `row-gap` ব্যবহার করুন) গ্রিড সারিগুলোর মধ্যে ফাঁক নির্ধারণ করে।
```css
    .old-row-gap-grid {
        display: grid;
        grid-template-rows: auto auto;
        grid-row-gap: 10px; /* অপ্রচলিত */
        /* আধুনিক: row-gap: 10px; বা gap: 10px; */
    }
    ```

139. **`grid-row-start`**: একটি গ্রিড আইটেম কোন সারি লাইন থেকে শুরু হবে তা নির্ধারণ করে।
```css
    .item-row-start {
        grid-row-start: 1; /* ১ম সারি লাইন থেকে শুরু হবে */
        grid-row-end: 2;
        background-color: lavender;
    }
    ```

140. **`grid-template`**: গ্রিড লেআউটের `grid-template-rows`, `grid-template-columns` এবং `grid-template-areas` প্রপার্টি একসাথে লেখার একটি জটিল শর্টহ্যান্ড।
```css
    .complex-grid {
        display: grid;
        grid-template:
            "head head head" 50px
            "nav  main aside" 1fr
            "foot foot foot" 30px / 150px 1fr 100px;
        /*
        "area-names" row-size
        ...
        / column-sizes
        */
        gap: 5px;
    }
    .complex-grid > div { border:1px solid; }
    .h { grid-area: head; } .n { grid-area: nav; } .m { grid-area: main; }
    .a { grid-area: aside; } .f { grid-area: foot; }
    ```
    ```html
    <div class="complex-grid">
      <div class="h">Header</div> <div class="n">Nav</div> <div class="m">Main</div>
      <div class="a">Aside</div> <div class="f">Footer</div>
    </div>
    ```

141. **`grid-template-areas`**: গ্রিড কন্টেইনারের এলাকাগুলোকে নাম দিয়ে একটি টেমপ্লেট তৈরি করে, যা গ্রিড আইটেমগুলোকে `grid-area` প্রপার্টির মাধ্যমে স্থাপন করতে ব্যবহৃত হয়।
 ```css
    .layout-container {
        display: grid;
        grid-template-columns: 1fr 3fr;
        grid-template-rows: auto 1fr auto;
        grid-template-areas:
            "header header"
            "sidebar content"
            "footer footer";
        gap: 10px;
        height: 300px;
    }
    .header { grid-area: header; background: lightblue; }
    .sidebar { grid-area: sidebar; background: lightgreen; }
    .content { grid-area: content; background: lightcoral; }
    .footer { grid-area: footer; background: lightgray; }
    ```

142. **`grid-template-columns`**: গ্রিড কন্টেইনারের কলামগুলোর আকার এবং সংখ্যা নির্ধারণ করে।
```css
    .column-template-grid {
        display: grid;
        grid-template-columns: 100px 1fr 2fr 15%; /* ৪টি কলাম বিভিন্ন আকারে */
        /* 1fr মানে অবশিষ্ট জায়গার ১ ভাগ */
        gap: 10px;
    }
    .repeat-cols-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr); /* ৩টি সমান প্রস্থের কলাম */
        gap: 5px;
    }
    ```

143. **`grid-template-rows`**: গ্রিড কন্টেইনারের সারিগুলোর উচ্চতা এবং সংখ্যা নির্ধারণ করে।
```css
    .row-template-grid {
        display: grid;
        grid-template-rows: 50px auto 100px; /* ৩টি সারি বিভিন্ন উচ্চতায় */
        grid-template-columns: 1fr 1fr;
        gap: 10px;
    }
    .minmax-rows-grid {
        display: grid;
        grid-template-rows: repeat(auto-fill, minmax(80px, auto)); /* সারিগুলো কমপক্ষে ৮০px উঁচু হবে এবং কন্টেন্ট অনুযায়ী বাড়বে */
        gap: 5px;
    }
    ```

144. **`hanging-punctuation`**: কিছু বিরামচিহ্ন (যেমন হাইফেন, উদ্ধৃতি চিহ্ন) টেক্সট ব্লকের প্রান্তের বাইরে সামান্য "ঝুলে" থাকবে কিনা তা নিয়ন্ত্রণ করে (পাঠযোগ্যতা বাড়ানোর জন্য)। (`first`, `last`, `allow-end`, `force-end`)
 ```css
    p.hanging-quote {
        hanging-punctuation: first; /* লাইনের শুরুতে উদ্ধৃতি চিহ্ন সামান্য বাইরে ঝুলে থাকবে */
    }
    ```
    **ব্যাখ্যা:** এই প্রপার্টির ব্রাউজার সমর্থন সীমিত।

145. **`height`**: একটি এলিমেন্টের কন্টেন্ট এলাকার উচ্চতা নির্ধারণ করে।
 ```css
    div.fixed-height {
        height: 200px;
        background-color: lightyellow;
        overflow: auto; /* কন্টেন্ট বেশি হলে স্ক্রলবার আসবে */
    }
    img.specific-height {
        height: 150px; /* ছবির উচ্চতা ১৫০ পিক্সেল হবে, প্রস্থ স্বয়ংক্রিয়ভাবে সমন্বিত হবে */
        width: auto;
    }
    ```

146. **`hyphens`**: একটি শব্দের মাঝে হাইফেন (-) ব্যবহার করে শব্দ ভাঙা (hyphenation) নিয়ন্ত্রণ করে, যখন শব্দটি এক লাইনে সংকুলান হয় না। (`none`, `manual`, `auto`)
 ```css
    p.hyphenated-text {
        width: 150px; /* সংকীর্ণ প্রস্থ হাইফেনেশন দেখানোর জন্য */
        border: 1px solid;
        padding: 5px;
        hyphens: auto; /* ব্রাউজার স্বয়ংক্রিয়ভাবে হাইফেন যোগ করবে (lang অ্যাট্রিবিউট সঠিকভাবে সেট করা থাকলে) */
    }
    ```
    ```html
    <p class="hyphenated-text" lang="bn">এখানেকিছুবড়বড়শব্দলিখুনযালাইনভেঙেযেতেপারেযেমনউদাহরণস্বরূপ।</p>
    ```
    **ব্যাখ্যা:** `lang` অ্যাট্রিবিউট (যেমন `lang="en"` বা `lang="bn"`) সঠিকভাবে সেট করা গুরুত্বপূর্ণ।

147. **`image-orientation`**: (मुख्यত EXIF ডেটা সহ JPEG ছবির জন্য) ছবিটি তার স্বাভাবিক অভিযোজন (orientation) অনুযায়ী ঘোরানো হবে কিনা তা নিয়ন্ত্রণ করে। (`from-image` বা `none`)।
```css
    img.oriented {
        image-orientation: from-image; /* ছবির EXIF ডেটা অনুযায়ী ঘোরানো হবে (ডিফল্ট) */
    }
    img.no-orientation {
        image-orientation: none; /* ছবির EXIF ডেটা উপেক্ষা করে যেমন আছে তেমন দেখাবে */
    }
    ```
    **ব্যাখ্যা:** এই প্রপার্টির ব্যবহার এখন কমে এসেছে কারণ ব্রাউজারগুলো ডিফল্টভাবেই EXIF অনুযায়ী ছবি দেখায়।

148. **`image-rendering`**: ব্রাউজার যখন একটি ইমেজকে স্কেল করে (ছোট বা বড় করে), তখন তার গুণমান কীভাবে বজায় রাখবে তা নিয়ন্ত্রণ করে (`auto`, `crisp-edges` বা `pixelated` (পিক্সেল আর্টের জন্য), `smooth`)।
```css
    img.pixel-art {
        width: 200px; /* মূল ছবির চেয়ে বড় করা হচ্ছে */
        height: 200px;
        image-rendering: pixelated; /* পিক্সেলগুলো তীক্ষ্ণ থাকবে, ঝাপসা হবে না */
    }
    img.smooth-photo {
        width: 100px; /* মূল ছবির চেয়ে ছোট করা হচ্ছে */
        image-rendering: smooth; /* মসৃণভাবে স্কেল করবে (ডিফল্ট) */
    }
    ```

149. **`inline-size`**: একটি এলিমেন্টের "ইনলাইন" দিকের (সাধারণত প্রস্থ, তবে `writing-mode` এর উপর নির্ভরশীল) আকার নির্ধারণ করে।
```css
    .box-inline {
        writing-mode: vertical-rl;
        inline-size: 150px; /* এক্ষেত্রে এটি এলিমেন্টের উচ্চতা হবে */
        block-size: 100px; /* এক্ষেত্রে এটি এলিমেন্টের প্রস্থ হবে */
        background-color: lightpink;
    }
    .normal-box-inline {
        inline-size: 200px; /* স্বাভাবিক লেখার দিকে এটি প্রস্থ */
        background-color: lightcyan;
    }
    ```

150. **`inset`**: পজিশনিং প্রপার্টি `top`, `right`, `bottom`, এবং `left` একসাথে লেখার একটি শর্টহ্যান্ড।
```css
    .overlay {
        position: fixed;
        inset: 0; /* top: 0; right: 0; bottom: 0; left: 0; এর সমান, পুরো ভিউপোর্ট জুড়ে থাকবে */
        background-color: rgba(0,0,0,0.5);
    }
    .centered-box {
        position: absolute;
        width: 100px; height: 100px;
        inset: 50% auto auto 50%; /* top: 50%; left: 50%; এর কাছাকাছি, কিন্তু transform দিয়ে সেন্টার করা ভালো */
        transform: translate(-50%, -50%);
        background-color: white;
    }
    ```

151. **`inset-block`**: লজিক্যাল প্রপার্টি; `top` ও `bottom` (অনুভূমিক লেখার মোডে) অথবা `left` ও `right` (উল্লম্ব লেখার মোডে) এর শর্টহ্যান্ড। (`inset-block-start` ও `inset-block-end`)
 ```css
    .positioned-element {
        position: absolute;
        inset-block: 10px 20px; /* top: 10px; bottom: 20px; (যদি writing-mode অনুভূমিক হয়) */
    }
    ```

152. **`inset-block-end`**: লজিক্যাল প্রপার্টি; `bottom` (অনুভূমিক লেখার মোডে) অথবা `left` (ডান-থেকে-বাম উল্লম্ব মোডে) বা `right` (বাম-থেকে-ডান উল্লম্ব মোডে) এর সমতুল্য।
```css
    .block-end-pos {
        position: absolute;
        inset-block-end: 0; /* এলিমেন্ট তার কন্টেইনিং ব্লকের নিচে/শেষে থাকবে */
    }
    ```

153. **`inset-block-start`**: লজিক্যাল প্রপার্টি; `top` (অনুভূমিক লেখার মোডে) অথবা `left` (বাম-থেকে-ডান উল্লম্ব মোডে) বা `right` (ডান-থেকে-বাম উল্লম্ব মোডে) এর সমতুল্য।
 ```css
    .block-start-pos {
        position: absolute;
        inset-block-start: 0; /* এলিমেন্ট তার কন্টেইনিং ব্লকের উপরে/শুরুতে থাকবে */
    }
    ```

154. **`inset-inline`**: লজিক্যাল প্রপার্টি; `left` ও `right` (অনুভূমিক লেখার মোডে) অথবা `top` ও `bottom` (উল্লম্ব লেখার মোডে) এর শর্টহ্যান্ড। (`inset-inline-start` ও `inset-inline-end`)
```css
    .positioned-element-inline {
        position: absolute;
        inset-inline: 5% 10%; /* left: 5%; right: 10%; (যদি writing-mode অনুভূমিক হয়) */
    }
    ```

155. **`inset-inline-end`**: লজিক্যাল প্রপার্টি; `right` (বাম-থেকে-ডান অনুভূমিক মোডে) অথবা `left` (ডান-থেকে-বাম অনুভূমিক মোডে) অথবা `bottom`/`top` (উল্লম্ব মোডে) এর সমতুল্য।
 ```css
    .inline-end-pos {
        position: absolute;
        inset-inline-end: 0; /* এলিমেন্ট তার কন্টেইনিং ব্লকের ডানে/শেষে (ltr মোডে) থাকবে */
    }
    ```

156. **`inset-inline-start`**: লজিক্যাল প্রপার্টি; `left` (বাম-থেকে-ডান অনুভূমিক মোডে) অথবা `right` (ডান-থেকে-বাম অনুভূমিক মোডে) অথবা `top`/`bottom` (উল্লম্ব মোডে) এর সমতুল্য।
```css
    .inline-start-pos {
        position: absolute;
        inset-inline-start: 0; /* এলিমেন্ট তার কন্টেইনিং ব্লকের বামে/শুরুতে (ltr মোডে) থাকবে */
    }
    ```

157. **`isolation`**: একটি এলিমেন্ট একটি নতুন স্ট্যাকিং কনটেক্সট (stacking context) তৈরি করবে কিনা তা নিয়ন্ত্রণ করে। `mix-blend-mode` এর সাথে এটি গুরুত্বপূর্ণ।
```css
    .parent { background-color: yellow; }
    .blending-element {
        width: 100px; height: 100px;
        background-color: blue;
        mix-blend-mode: multiply; /* হলুদ ও নীলের মিশ্রণ হবে */
    }
    .isolated-blending-element {
        width: 100px; height: 100px;
        background-color: red;
        isolation: isolate; /* এটি একটি নতুন স্ট্যাকিং কনটেক্সট তৈরি করবে */
        /* এর ভেতরের কোনো এলিমেন্টের mix-blend-mode শুধু এই লাল ব্যাকগ্রাউন্ডের সাথে কাজ করবে, হলুদ প্যারেন্টের সাথে নয় */
    }
    ```
    **ব্যাখ্যা:** `isolate` মান দিলে এলিমেন্ট এবং তার কন্টেন্ট একটি স্বতন্ত্র গ্রুপ হিসেবে বিবেচিত হয়, যা তার বাইরের এলিমেন্টের সাথে ব্লেন্ডিং বা মাস্কিং থেকে এটিকে আলাদা করে।

158. **`justify-content`**: ফ্লেক্সবক্স বা গ্রিড কন্টেইনারে আইটেমগুলোকে প্রধান অক্ষ বরাবর (main axis, ফ্লেক্সের ক্ষেত্রে সাধারণত অনুভূমিকভাবে) কীভাবে সাজানো এবং তাদের মধ্যে ফাঁকা জায়গা কীভাবে বিতরণ করা হবে তা নিয়ন্ত্রণ করে।
 ```css
    .flex-container-justify {
        display: flex;
        width: 400px; border: 1px solid;
        justify-content: space-between; /* আইটেমগুলোর মধ্যে সমান ফাঁকা জায়গা, প্রথম ও শেষ আইটেম প্রান্তে থাকবে */
    }
    .flex-item-justify { width: 80px; height: 50px; background: lightblue; }
    /* অন্যান্য মান: flex-start, flex-end, center, space-around, space-evenly */
    ```

159. **`justify-items`**: গ্রিড কন্টেইনারের আইটেমগুলোকে তাদের গ্রিড এলাকার মধ্যে অনুভূমিকভাবে (inline axis) কীভাবে সারিবদ্ধ করা হবে তা নির্ধারণ করে।
```css
    .grid-justify-items {
        display: grid;
        grid-template-columns: 100px 100px;
        justify-items: center; /* প্রতিটি আইটেম তার সেলের অনুভূমিক মাঝখানে থাকবে */
        border: 1px solid;
    }
    .grid-justify-items div { background: lightcoral; padding: 5px; }
    /* অন্যান্য মান: start, end, stretch (ডিফল্ট) */
    ```

160. **`justify-self`**: একটি নির্দিষ্ট গ্রিড আইটেমের জন্য `justify-items` প্রপার্টির মানকে ওভাররাইড করে, অর্থাৎ এটি শুধু নিজের অনুভূমিক সারিবদ্ধকরণ নিয়ন্ত্রণ করে।
 ```css
    .grid-container-self {
        display: grid;
        grid-template-columns: 1fr 1fr;
        justify-items: stretch; /* ডিফল্ট */
        border: 1px solid;
    }
    .special-item {
        justify-self: end; /* এই আইটেমটি তার সেলের ডান প্রান্তে থাকবে */
        background-color: lightgreen;
    }
    .grid-container-self div { padding: 10px; border: 1px dashed gray; }
    ```

161. **`left`**: পজিশন করা (যেমন `position: absolute` বা `relative` বা `fixed`) এলিমেন্টের বাম প্রান্ত তার কন্টেইনিং ব্লকের বাম প্রান্ত থেকে কত দূরে থাকবে তা নির্ধারণ করে।
 ```css
    .positioned-right {
        position: relative; /* অথবা absolute */
        left: 50px; /* এলিমেন্টটি তার স্বাভাবিক অবস্থান থেকে ৫০ পিক্সেল ডানে সরে যাবে */
        background-color: #eee;
    }
    ```

162. **`letter-spacing`**: টেক্সটের অক্ষরগুলোর মধ্যে অতিরিক্ত ফাঁকা জায়গা নির্ধারণ করে।
```css
    h1.wide-letters {
        letter-spacing: 5px; /* অক্ষরগুলোর মধ্যে ৫ পিক্সেল ফাঁক */
    }
    p.condensed-letters {
        letter-spacing: -1px; /* অক্ষরগুলো কাছাকাছি আসবে */
    }
    ```

163. **`line-break`**: বিরামচিহ্ন এবং প্রতীক ব্যবহার করে টেক্সটের লাইন ভাঙার নিয়মগুলো কীভাবে প্রয়োগ হবে তা নির্ধারণ করে (বিশেষত ইস্ট এশিয়ান ভাষার জন্য)। (`auto`, `loose`, `normal`, `strict`, `anywhere`)
```css
    .strict-break {
        width: 100px; border: 1px solid;
        line-break: strict; /* কঠোর লাইন ভাঙার নিয়ম (যেমন জাপানি ভাষার জন্য) */
    }
    .anywhere-break {
        width: 100px; border: 1px solid;
        line-break: anywhere; /* যেকোনো অক্ষরের পর লাইন ভাঙতে পারে (ওভারফ্লো রোধে) */
    }
    ```

164. **`line-height`**: টেক্সট লাইনের উচ্চতা নির্ধারণ করে। এটি ফন্ট সাইজের গুণিতক (যেমন `1.5`), পিক্সেল (`20px`), বা `normal` হতে পারে।
```css
    p.readable-text {
        font-size: 16px;
        line-height: 1.6; /* লাইনের উচ্চতা হবে 16px * 1.6 = 25.6px */
    }
    h2 {
        line-height: 1.2em; /* ফন্ট সাইজের ১.২ গুণ */
    }
    ```

165. **`list-style`**: লিস্ট আইটেমের মার্কারের (`list-style-type`, `list-style-position`, `list-style-image`) শর্টহ্যান্ড।
```css
    ul.custom-bullets {
        list-style: square inside url("custom-bullet.png");
        /* type position image */
    }
    ol.no-markers {
        list-style: none; /* কোনো মার্কার দেখাবে না */
    }
    ```

166. **`list-style-image`**: লিস্ট আইটেমের মার্কার হিসেবে একটি ইমেজ ব্যবহার করার জন্য ইমেজের URL নির্ধারণ করে।
```css
    ul.image-bullets {
        list-style-image: url("star.gif");
    }
    ```

167. **`list-style-position`**: লিস্ট আইটেমের মার্কারটি কন্টেন্টের ভিতরে (`inside`) নাকি বাইরে (`outside`, ডিফল্ট) থাকবে তা নির্ধারণ করে।
```css
    ul.markers-inside {
        list-style-position: inside; /* মার্কারগুলো টেক্সট ব্লকের ভিতরে থাকবে, টেক্সট মোড়ালে মার্কারও সরবে */
        width: 150px; border: 1px solid;
    }
    ```

168. **`list-style-type`**: লিস্ট আইটেমের মার্কারের ধরন নির্ধারণ করে (যেমন `disc`, `circle`, `square`, `decimal`, `lower-roman`, `none` ইত্যাদি)।
```css
    ul { list-style-type: disc; } /* ভরাট বৃত্ত (ডিফল্ট) */
    ol { list-style-type: decimal; } /* সংখ্যা (ডিফল্ট) */
    ul.custom { list-style-type: "\2713"; } /* ইউনিকোড চেক মার্ক (সাথে content ও লাগে ভালো ফলাফলের জন্য) */
    ```

169. **`margin`**: একটি এলিমেন্টের বর্ডারের বাইরের চারপাশের ফাঁকা জায়গা বা মার্জিন নির্ধারণ করে। এটি এক থেকে চারটি মান নিতে পারে (top, right, bottom, left)।
```css
    .box-with-margin {
        margin: 10px 20px 15px 5px; /* টপ-১০, রাইট-২০, বটম-১৫, লেফট-৫ পিক্সেল */
        border: 1px solid;
    }
    .centered-block {
        width: 50%;
        margin: 0 auto; /* উপরে-নিচে ০, ডানে-বামে স্বয়ংক্রিয়ভাবে সমান মার্জিন (ব্লক এলিমেন্টকে সেন্টারে আনে) */
        border: 1px solid;
    }
    ```

170. **`margin-block`**: লজিক্যাল প্রপার্টি; `margin-top` ও `margin-bottom` (অনুভূমিক লেখার মোডে) অথবা `margin-left` ও `margin-right` (উল্লম্ব লেখার মোডে) এর শর্টহ্যান্ড।
```css
    .element-margin-block {
        margin-block: 1em 2em; /* margin-block-start: 1em; margin-block-end: 2em; */
    }
    ```

171. **`margin-block-end`**: লজিক্যাল প্রপার্টি; `margin-bottom` (অনুভূমিক লেখার মোডে) অথবা `margin-left` (ডান-থেকে-বাম উল্লম্ব মোডে) বা `margin-right` (বাম-থেকে-ডান উল্লম্ব মোডে) এর সমতুল্য।
```css
    .block-end-margin {
        margin-block-end: 20px;
    }
    ```

172. **`margin-block-start`**: লজিক্যাল প্রপার্টি; `margin-top` (অনুভূমিক লেখার মোডে) অথবা `margin-left` (বাম-থেকে-ডান উল্লম্ব মোডে) বা `margin-right` (ডান-থেকে-বাম উল্লম্ব মোডে) এর সমতুল্য।
```css
    .block-start-margin {
        margin-block-start: 10px;
    }
    ```

173. **`margin-bottom`**: এলিমেন্টের নিচের মার্জিন নির্ধারণ করে।
 ```css
    p {
        margin-bottom: 15px; /* প্যারাগ্রাফের নিচে ১৫ পিক্সেল ফাঁকা জায়গা */
    }
    ```

174. **`margin-inline`**: লজিক্যাল প্রপার্টি; `margin-left` ও `margin-right` (অনুভূমিক লেখার মোডে) অথবা `margin-top` ও `margin-bottom` (উল্লম্ব লেখার মোডে) এর শর্টহ্যান্ড।
 ```css
    .element-margin-inline {
        margin-inline: auto; /* অনুভূমিক দিকে মাঝখানে আনার জন্য */
        width: fit-content;
    }
    ```

175. **`margin-inline-end`**: লজিক্যাল প্রপার্টি; `margin-right` (বাম-থেকে-ডান অনুভূমিক মোডে) অথবা `margin-left` (ডান-থেকে-বাম অনুভূমিক মোডে) এর সমতুল্য।
```css
    .inline-end-margin {
        margin-inline-end: 25px;
    }
    ```

176. **`margin-inline-start`**: লজিক্যাল প্রপার্টি; `margin-left` (বাম-থেকে-ডান অনুভূমিক মোডে) অথবা `margin-right` (ডান-থেকে-বাম অনুভূমিক মোডে) এর সমতুল্য।
 ```css
    .inline-start-margin {
        margin-inline-start: 5px;
    }
    ```

177. **`margin-left`**: এলিমেন্টের বাম মার্জিন নির্ধারণ করে।
 ```css
    .indented-block {
        margin-left: 40px; /* বাম দিকে ৪০ পিক্সেল সরে আসবে */
    }
    ```

178. **`margin-right`**: এলিমেন্টের ডান মার্জিন নির্ধারণ করে।
 ```css
    .item-spacing {
        margin-right: 10px; /* ডান দিকে ১০ পিক্সেল ফাঁকা জায়গা */
    }
    ```

179. **`margin-top`**: এলিমেন্টের উপরের মার্জিন নির্ধারণ করে।
 ```css
    h1 {
        margin-top: 20px; /* হেডিংয়ের উপরে ২০ পিক্সেল ফাঁকা জায়গা */
    }
    ```

180. **`mask`**: একটি এলিমেন্টের দৃশ্যমান অংশকে একটি ইমেজ বা SVG আকৃতি ব্যবহার করে মাস্ক বা আড়াল করার জন্য শর্টহ্যান্ড প্রপার্টি।
 ```css
    .masked-image {
        width: 200px; height: 200px;
        background-image: url("photo.jpg");
        background-size: cover;
        mask: url("star-shape.svg") no-repeat center / contain;
        /* mask-image, mask-repeat, mask-position / mask-size */
        -webkit-mask: url("star-shape.svg") no-repeat center / contain; /* Safari র জন্য */
    }
    ```
    **ব্যাখ্যা:** ছবিটি তারা (star) আকৃতিতে মাস্ক করা হবে।

181. **`mask-clip`**: মাস্কের ক্লিপিং এলাকা নির্ধারণ করে (`border-box`, `padding-box`, `content-box`, `text` ইত্যাদি)।
```css
    .text-mask-clip {
        mask-image: linear-gradient(black, transparent);
        mask-clip: text; /* মাস্ক শুধু টেক্সট অংশে প্রযোজ্য হবে */
        -webkit-mask-clip: text;
        color: transparent; /* টেক্সট স্বচ্ছ করে দিতে হবে যাতে মাস্ক দেখা যায় */
        background-image: url("galaxy.jpg"); /* এই ব্যাকগ্রাউন্ড মাস্কের মাধ্যমে টেক্সটে দেখা যাবে */
        font-size: 50px; font-weight: bold;
    }
    ```

182. **`mask-composite`**: যখন একাধিক মাস্ক লেয়ার থাকে, তখন সেগুলো একে অপরের সাথে কীভাবে মিলিত বা বিয়োজিত হবে তা নির্ধারণ করে (`add`, `subtract`, `intersect`, `exclude`)।
```css
    .composite-mask {
        mask-image: url("circle.svg"), url("square.svg");
        mask-composite: intersect; /* বৃত্ত এবং বর্গক্ষেত্রের ছেদ অংশ মাস্ক হবে */
    }
    ```

183. **`mask-image`**: মাস্ক হিসেবে ব্যবহার করার জন্য এক বা একাধিক ইমেজ (বা গ্রেডিয়েন্ট) নির্ধারণ করে।
 ```css
    .gradient-mask {
        mask-image: linear-gradient(to right, black 0%, transparent 100%);
        /* বাম থেকে ডানে কালো থেকে স্বচ্ছ গ্রেডিয়েন্ট মাস্ক */
    }
    ```

184. **`mask-mode`**: মাস্কটি লুমিন্যান্স (আলোর তীব্রতা) নাকি আলফা (স্বচ্ছতা) মানের উপর ভিত্তি করে কাজ করবে তা নির্ধারণ করে (`alpha`, `luminance`, `match-source`)।
```css
    .luminance-mask-example {
        mask-image: url("grayscale-pattern.png");
        mask-mode: luminance; /* মাস্ক ইমেজের উজ্জ্বল অংশ দৃশ্যমান, অন্ধকার অংশ স্বচ্ছ হবে */
    }
    ```

185. **`mask-origin`**: `mask-position` এর সাপেক্ষে মাস্ক ইমেজের অবস্থান কোথা থেকে শুরু হবে তা নির্ধারণ করে (`border-box`, `padding-box`, `content-box` ইত্যাদি)।
 ```css
    .mask-origin-example {
        padding: 20px; border: 5px solid;
        mask-image: url("small-mask.png");
        mask-origin: content-box; /* মাস্ক কন্টেন্ট বক্স থেকে শুরু হবে */
    }
    ```

186. **`mask-position`**: মাস্ক ইমেজের প্রাথমিক অবস্থান নির্ধারণ করে।
 ```css
    .mask-position-example {
        mask-image: url("icon-mask.svg");
        mask-position: top right; /* মাস্কটি উপরে ডানদিকে থাকবে */
    }
    ```

187. **`mask-repeat`**: মাস্ক ইমেজটি কীভাবে পুনরাবৃত্তি হবে তা নির্ধারণ করে।
 ```css
    .mask-repeat-example {
        mask-image: url("pattern-mask.png");
        mask-repeat: repeat-x; /* মাস্ক শুধুমাত্র অনুভূমিকভাবে পুনরাবৃত্তি হবে */
    }
    ```

188. **`mask-size`**: মাস্ক ইমেজের আকার নির্ধারণ করে।
```css
    .mask-size-example {
        mask-image: url("logo-mask.svg");
        mask-size: 50% auto; /* মাস্কের প্রস্থ ৫০%, উচ্চতা স্বয়ংক্রিয় */
    }
    ```

189. **`max-block-size`**: একটি এলিমেন্টের ব্লক দিকের (সাধারণত উচ্চতা) সর্বোচ্চ আকার নির্ধারণ করে।
 ```css
    .limited-block-height {
        max-block-size: 300px; /* উচ্চতা ৩০০ পিক্সেলের বেশি হবে না */
        overflow: auto;
    }
    ```

190. **`max-height`**: একটি এলিমেন্টের সর্বোচ্চ উচ্চতা নির্ধারণ করে। এলিমেন্টের কন্টেন্ট এর চেয়ে বেশি হলেও উচ্চতা এর বেশি বাড়বে না।
```css
    .scrollable-content {
        max-height: 250px; /* সর্বোচ্চ উচ্চতা ২৫০ পিক্সেল */
        overflow-y: auto; /* কন্টেন্ট বেশি হলে উল্লম্ব স্ক্রলবার আসবে */
        border: 1px solid #ccc; padding: 10px;
    }
    ```

191. **`max-inline-size`**: একটি এলিমেন্টের ইনলাইন দিকের (সাধারণত প্রস্থ) সর্বোচ্চ আকার নির্ধারণ করে।
```css
    .limited-inline-width {
        max-inline-size: 600px; /* প্রস্থ ৬০০ পিক্সেলের বেশি হবে না */
        margin-inline: auto; /* মাঝখানে আনার জন্য */
    }
    ```

192. **`max-width`**: একটি এলিমেন্টের সর্বোচ্চ প্রস্থ নির্ধারণ করে। এলিমেন্টের কন্টেন্ট বা ভিউপোর্ট এর চেয়ে বেশি হলেও প্রস্থ এর বেশি বাড়বে না।
 ```css
    .responsive-container {
        max-width: 960px; /* সর্বোচ্চ প্রস্থ ৯৬০ পিক্সেল */
        width: 100%; /* ডিফল্টভাবে পুরো উপলব্ধ প্রস্থ নেবে */
        margin: 0 auto; /* কন্টেইনারকে সেন্টারে রাখবে */
        background-color: #f0f0f0;
    }
    ```

193. **`min-block-size`**: একটি এলিমেন্টের ব্লক দিকের (সাধারণত উচ্চতা) সর্বনিম্ন আকার নির্ধারণ করে।
```css
    .min-block-height-box {
        min-block-size: 100px; /* উচ্চতা কমপক্ষে ১০০ পিক্সেল হবে */
        background-color: lightblue;
    }
    ```

194. **`min-height`**: একটি এলিমেন্টের সর্বনিম্ন উচ্চতা নির্ধারণ করে। এলিমেন্টের কন্টেন্ট কম হলেও উচ্চতা এর চেয়ে কম হবে না।
```css
    .footer-area {
        min-height: 80px; /* ফুটারের উচ্চতা কমপক্ষে ৮০ পিক্সেল হবে */
        background-color: #333;
        color: white;
        padding: 20px;
    }
    ```

195. **`min-inline-size`**: একটি এলিমেন্টের ইনলাইন দিকের (সাধারণত প্রস্থ) সর্বনিম্ন আকার নির্ধারণ করে।
  ```css
    .min-inline-width-button {
        display: inline-block;
        min-inline-size: 120px; /* বাটনের প্রস্থ কমপক্ষে ১২০ পিক্সেল হবে */
        padding: 10px; text-align: center; background-color: green; color: white;
    }
    ```

196. **`min-width`**: একটি এলিমেন্টের সর্বনিম্ন প্রস্থ নির্ধারণ করে। এলিমেন্টের কন্টেন্ট বা ভিউপোর্ট কম হলেও প্রস্থ এর চেয়ে কম হবে না।
 ```css
    .sidebar-nav {
        min-width: 180px; /* সাইডবারের প্রস্থ কমপক্ষে ১৮০ পিক্সেল হবে */
        background-color: #f8f8f8;
        padding: 15px;
    }
    ```

197. **`mix-blend-mode`**: একটি এলিমেন্ট তার পেছনের কন্টেন্ট বা এলিমেন্টের সাথে কীভাবে মিশে (blend) যাবে তা নির্ধারণ করে (যেমন `multiply`, `screen`, `overlay`, `darken`, `lighten`, `difference` ইত্যাদি)।
```css
    .blend-text {
        font-size: 5em; font-weight: bold; color: white;
        mix-blend-mode: difference; /* সাদা টেক্সট তার পেছনের রঙের সাথে difference মোডে মিশবে */
    }
    body { background-color: lightcoral; } /* এই ব্যাকগ্রাউন্ডের সাথে টেক্সট মিশবে */
    ```

198. **`object-fit`**: `<img>` বা `<video>` ট্যাগের কন্টেন্ট তার ধার্যকৃত প্রস্থ এবং উচ্চতার মধ্যে কীভাবে ফিট হবে বা ক্রপ হবে তা নিয়ন্ত্রণ করে (`fill`, `contain`, `cover`, `none`, `scale-down`)।
 ```css
    .image-container { width: 200px; height: 150px; border: 1px solid; }
    .image-container img.cover-fit {
        width: 100%; height: 100%;
        object-fit: cover; /* পুরো কন্টেইনার জুড়ে থাকবে, প্রয়োজনে ক্রপ হবে, aspect ratio বজায় থাকবে */
    }
    .image-container img.contain-fit {
        width: 100%; height: 100%;
        object-fit: contain; /* পুরো ছবি দেখা যাবে, aspect ratio বজায় থাকবে, প্রয়োজনে ফাঁকা জায়গা থাকবে */
    }
    ```

199. **`object-position`**: `object-fit` ব্যবহার করার সময় ইমেজ বা ভিডিও তার কন্টেইনারের মধ্যে কীভাবে অবস্থান করবে তা নির্ধারণ করে ( `background-position` এর মতো)।
 ```css
    .image-container-pos { width: 200px; height: 150px; border: 1px solid; overflow: hidden; }
    .image-container-pos img {
        width: 100%; height: 100%;
        object-fit: cover;
        object-position: top center; /* 'cover' করার সময় ছবির উপরের মাঝের অংশ দেখানোর চেষ্টা করবে */
    }
    ```

200. **`offset`**: (এখন সাধারণত `offset-path`, `offset-distance` ইত্যাদিতে বিভক্ত) একটি এলিমেন্টকে একটি নির্দিষ্ট পাথ বা পথে সরানোর (animate) জন্য শর্টহ্যান্ড।
 ```css
    /* এটি একটি নতুন এবং পরীক্ষামূলক প্রপার্টি, পুরনো offset-path ব্যবহার শ্রেয় */
    /* .animated-on-path {
        offset-path: path('M10 80 Q 95 10 180 80');
        offset-distance: 0%;
        animation: moveAlongPath 5s infinite linear;
    }
    @keyframes moveAlongPath {
        to { offset-distance: 100%; }
    } */
    /*  For now, it's better to use individual properties like offset-path, offset-distance, etc. */
    .motion-path-example {
        width: 50px; height: 50px; background: red; border-radius: 50%;
        offset-path: path('M20,20 C20,100 200,100 200,20'); /* একটি বক্ররেখা */
        animation: followPath 3s linear infinite;
    }
    @keyframes followPath {
      0% { offset-distance: 0%; }
      100% { offset-distance: 100%; }
    }
    ```
    **ব্যাখ্যা:** `offset` শর্টহ্যান্ড এর পরিবর্তে `offset-path`, `offset-distance`, `offset-rotate`, `offset-anchor` আলাদাভাবে ব্যবহার করা ভালো।



201. **`offset-anchor`**: মোশন পাথে (`offset-path`) চলমান এলিমেন্টের কোন বিন্দুটি পাথের সাথে সংযুক্ত থাকবে তা নির্ধারণ করে। ( `offset-position` নামেও পরিচিত ছিল)
 ```css
    .path-animated-anchor {
        width: 50px; height: 50px; background: blue;
        offset-path: path('M0,50 L200,50');
        offset-anchor: center center; /* এলিমেন্টের কেন্দ্র পাথের উপর থাকবে */
        animation: move 3s linear infinite;
    }
    @keyframes move { to { offset-distance: 100%; } }
    ```

202. **`offset-distance`**: `offset-path` বরাবর একটি এলিমেন্ট কতটুকু দূরত্বে অবস্থান করবে তা নির্ধারণ করে। অ্যানিমেশনের জন্য এটি খুবই উপযোগী।
 ```css
    .path-animated-distance {
        width: 30px; height: 30px; background: green;
        offset-path: circle(100px at center);
        offset-distance: 0%; /* শুরুতে পাথের ০% দূরত্বে */
        animation: circleMove 5s infinite;
    }
    @keyframes circleMove {
        to { offset-distance: 100%; } /* পাথের ১০০% দূরত্বে (অর্থাৎ সম্পূর্ণ পথ ঘুরে আসবে) */
    }
    ```

203. **`offset-path`**: একটি এলিমেন্টের চলার জন্য জ্যামিতিক পথ (যেমন SVG path, basic shape) নির্ধারণ করে।
  ```css
    .path-runner {
        width: 20px; height: 20px; background: purple;
        offset-path: path('M10 80 C 40 10, 65 10, 95 80 S 150 150, 180 80'); /* একটি জটিল SVG পাথ */
        animation: runPath 4s linear infinite;
    }
    @keyframes runPath { from {offset-distance: 0%;} to {offset-distance: 100%;} }
    ```

204. **`offset-rotate`**: `offset-path` বরাবর চলার সময় এলিমেন্টটি পাথের দিকের সাথে স্বয়ংক্রিয়ভাবে ঘুরবে (`auto`), নাকি একটি নির্দিষ্ট কোণে (`<angle>`) থাকবে, নাকি ঘুরবে না (`0deg`), তা নির্ধারণ করে।
 ```css
    .path-rotating-element {
        width: 40px; height: 20px; background: orange;
        offset-path: path('M0,0 Q100,100 200,0');
        offset-rotate: auto 90deg; /* পাথের দিকের সাথে স্বয়ংক্রিয়ভাবে ঘুরবে এবং অতিরিক্ত ৯০ ডিগ্রি ঘুরবে */
        animation: moveAndRotate 3s linear infinite;
    }
    @keyframes moveAndRotate { to { offset-distance: 100%; } }
    ```

205. **`opacity`**: একটি এলিমেন্টের স্বচ্ছতা (opaqueness) নির্ধারণ করে। মান `0.0` (সম্পূর্ণ স্বচ্ছ) থেকে `1.0` (সম্পূর্ণ অস্বচ্ছ বা দৃশ্যমান) পর্যন্ত হয়।
  ```css
    .transparent-box {
        width: 100px; height: 100px; background-color: red;
        opacity: 0.5; /* বক্সটি ৫০% স্বচ্ছ হবে */
    }
    img.faded {
        opacity: 0.3;
    }
    ```

206. **`order`**: ফ্লেক্সবক্স বা গ্রিড কন্টেইনারে আইটেমগুলোর প্রদর্শনের ক্রম (order) নির্ধারণ করে। কম মানের আইটেম আগে আসে। ডিফল্ট মান `0`।
 ```css
    .flex-container-order { display: flex; }
    .item-first { order: -1; background: lightblue; padding: 10px; } /* এটি প্রথমে দেখাবে */
    .item-default { order: 0; background: lightgreen; padding: 10px; } /* স্বাভাবিক ক্রমে */
    .item-last { order: 1; background: lightcoral; padding: 10px; } /* এটি শেষে দেখাবে */
    ```

207. **`orphans`**: প্রিন্ট করার সময় একটি প্যারাগ্রাফের শেষ অংশ (orphan lines) নতুন পেজের শুরুতে একা কতগুলো লাইন থাকতে পারবে তার সর্বনিম্ন সংখ্যা নির্ধারণ করে।
 ```css
    p.avoid-orphans {
        orphans: 3; /* নতুন পেজের শুরুতে কমপক্ষে ৩টি লাইন থাকতে হবে, নতুবা আগের পেজে ব্রেক হবে */
    }
    ```
    **ব্যাখ্যা:** এটি মূলত প্রিন্ট লেআউটের জন্য।

208. **`outline`**: এলিমেন্টের বর্ডারের বাইরে একটি অতিরিক্ত লাইন বা আউটলাইন আঁকার জন্য শর্টহ্যান্ড ( `outline-width`, `outline-style`, `outline-color`)। এটি লেআউটে কোনো জায়গা নেয় না।
  ```css
    .focused-input:focus {
        outline: 3px dashed blue; /* ফোকাস পেলে ৩ পিক্সেল ড্যাশড নীল আউটলাইন */
    }
    ```

209. **`outline-color`**: আউটলাইনের রঙ নির্ধারণ করে।
  ```css
    button:hover {
        outline-style: solid;
        outline-width: 2px;
        outline-color: green;
    }
    ```

210. **`outline-offset`**: আউটলাইনটি এলিমেন্টের বর্ডার থেকে কত দূরে থাকবে তা নির্ধারণ করে। ধনাত্মক মান বাইরে, ঋণাত্মক মান ভিতরে সরায়।
 ```css
    .offset-outline {
        border: 1px solid black;
        outline: 2px solid red;
        outline-offset: 5px; /* আউটলাইনটি বর্ডার থেকে ৫ পিক্সেল বাইরে থাকবে */
    }
    ```

211. **`outline-style`**: আউটলাইনের স্টাইল নির্ধারণ করে (যেমন `solid`, `dashed`, `dotted`, `double`, `auto` (ব্রাউজার ডিফল্ট))।
 ```css
    .custom-focus:focus-visible { /* কীবোর্ড ফোকাসের জন্য */
        outline-width: 2px;
        outline-color: orange;
        outline-style: dotted;
    }
    ```

212. **`outline-width`**: আউটলাইনের পুরুত্ব নির্ধারণ করে।
 ```css
    .thick-outline {
        outline-style: solid;
        outline-color: black;
        outline-width: 4px;
    }
    ```

213. **`overflow`**: একটি এলিমেন্টের কন্টেন্ট যখন তার নির্ধারিত আকার (প্রস্থ/উচ্চতা) ছাড়িয়ে যায়, তখন সেই অতিরিক্ত কন্টেন্ট কীভাবে দেখানো বা নিয়ন্ত্রণ করা হবে তা নির্ধারণ করে (`visible` (ডিফল্ট), `hidden`, `scroll`, `auto`, `clip`)।
  ```css
    .scrollable-div {
        width: 200px; height: 100px;
        overflow: scroll; /* কন্টেন্ট বেশি হলে সবসময় স্ক্রলবার দেখাবে */
        border: 1px solid;
    }
    .auto-scroll-div {
        width: 200px; height: 100px;
        overflow: auto; /* কন্টেন্ট বেশি হলেই স্ক্রলবার দেখাবে */
        border: 1px solid;
    }
    .hidden-overflow {
        width: 100px; height: 50px;
        overflow: hidden; /* অতিরিক্ত কন্টেন্ট কেটে ফেলা হবে, দেখা যাবে না */
        border: 1px solid;
    }
    ```

214. **`overflow-anchor`**: ব্যবহারকারী যখন একটি পৃষ্ঠার উপরের দিকে স্ক্রল করে কন্টেন্ট লোড করেন, তখন ব্রাউজার স্ক্রল পজিশন স্বয়ংক্রিয়ভাবে সমন্বয় করে যেন নতুন কন্টেন্ট ব্যবহারকারীর বর্তমান ভিউকে ধাক্কা না দেয়। এই আচরণ নিয়ন্ত্রণ করে (`auto` বা `none`)।
 ```css
    body {
        overflow-anchor: auto; /* ডিফল্ট, ব্রাউজার স্ক্রল অ্যাঙ্করিং করবে */
    }
    .disable-anchoring-section {
        overflow-anchor: none; /* এই সেকশনে স্ক্রল অ্যাঙ্করিং নিষ্ক্রিয় থাকবে */
    }
    ```
    **ব্যাখ্যা:** এটি মূলত বড়, ডাইনামিক কন্টেন্টযুক্ত পেজের জন্য।

215. **`overflow-block`**: লজিক্যাল প্রপার্টি; একটি এলিমেন্টের ব্লক দিকের ওভারফ্লো নিয়ন্ত্রণ করে।
  ```css
    .overflow-block-example {
        writing-mode: vertical-rl;
        block-size: 100px; /* প্রস্থ (উল্লম্ব মোডে) */
        inline-size: 150px; /* উচ্চতা (উল্লম্ব মোডে) */
        overflow-block: scroll; /* ব্লক দিকে (প্রস্থে) স্ক্রলবার আসবে */
    }
    ```

216. **`overflow-inline`**: লজিক্যাল প্রপার্টি; একটি এলিমেন্টের ইনলাইন দিকের ওভারফ্লো নিয়ন্ত্রণ করে।
 ```css
    .overflow-inline-example {
        writing-mode: vertical-rl;
        block-size: 100px;
        inline-size: 150px; /* উচ্চতা (উল্লম্ব মোডে) */
        overflow-inline: auto; /* ইনলাইন দিকে (উচ্চতায়) প্রয়োজনে স্ক্রলবার আসবে */
    }
    ```

217. **`overflow-wrap`**: একটি অবিচ্ছিন্ন শব্দ (যেমন খুব লম্বা URL) যদি তার কন্টেইনারের প্রস্থ ছাড়িয়ে যায়, তাহলে সেই শব্দটি ভাঙা (`break-word`) হবে কিনা, নাকি স্বাভাবিকভাবে (`normal`) ওভারফ্লো করবে তা নিয়ন্ত্রণ করে। (সমার্থক: `word-wrap`)
 ```css
    .long-url-container {
        width: 200px;
        border: 1px solid;
        padding: 5px;
        overflow-wrap: break-word; /* লম্বা শব্দ প্রয়োজনে ভেঙে নতুন লাইনে যাবে */
    }
    ```
    ```html
    <div class="long-url-container">
      <p>Visit: https://www.thisisaveryveryverylongurlthatwillnotfitinonenormalcontainer.com/somepage</p>
    </div>
    ```

218. **`overflow-x`**: একটি এলিমেন্টের শুধুমাত্র অনুভূমিক (horizontal) ওভারফ্লো নিয়ন্ত্রণ করে (`visible`, `hidden`, `scroll`, `auto`, `clip`)।
   ```css
    .horizontal-scroll {
        width: 250px;
        overflow-x: scroll; /* অনুভূমিক স্ক্রলবার দেখাবে */
        overflow-y: hidden; /* উল্লম্ব স্ক্রলবার দেখাবে না */
        white-space: nowrap; /* টেক্সট এক লাইনে থাকবে */
        border: 1px solid;
    }
    ```

219. **`overflow-y`**: একটি এলিমেন্টের শুধুমাত্র উল্লম্ব (vertical) ওভারফ্লো নিয়ন্ত্রণ করে (`visible`, `hidden`, `scroll`, `auto`, `clip`)।
  ```css
    .vertical-scroll {
        height: 150px;
        overflow-y: auto; /* উল্লম্ব দিকে প্রয়োজনে স্ক্রলবার দেখাবে */
        overflow-x: hidden;
        border: 1px solid;
    }
    ```

220. **`overscroll-behavior`**: যখন একটি স্ক্রলযোগ্য এলাকার কন্টেন্ট তার প্রান্তে পৌঁছায় (টপ/বটম বা লেফট/রাইট), তখন আরও স্ক্রল করার চেষ্টা করলে ব্রাউজারের মূল পৃষ্ঠার স্ক্রলিং ("scroll chaining") বা "বাউন্স" ইফেক্ট ঘটবে কিনা তা নিয়ন্ত্রণ করে।
 ```css
    .modal-scrollable-content {
        max-height: 80vh;
        overflow-y: auto;
        overscroll-behavior-y: contain; /* এই কন্টেইনারের উল্লম্ব স্ক্রল প্যারেন্টকে প্রভাবিত করবে না */
    }
    /* মান হতে পারে: auto (ডিফল্ট), contain, none */
    ```

221. **`overscroll-behavior-block`**: লজিক্যাল প্রপার্টি; ব্লক দিকের (`overscroll-behavior-y` এর মতো অনুভূমিক লেখার মোডে) ওভারস্ক্রল আচরণ নিয়ন্ত্রণ করে।
 ```css
    .chat-window {
        height: 300px; overflow-y: scroll;
        overscroll-behavior-block: contain;
    }
    ```

222. **`overscroll-behavior-inline`**: লজিক্যাল প্রপার্টি; ইনলাইন দিকের (`overscroll-behavior-x` এর মতো অনুভূমিক লেখার মোডে) ওভারস্ক্রল আচরণ নিয়ন্ত্রণ করে।
  ```css
    .horizontal-gallery {
        width: 100vw; overflow-x: scroll; white-space: nowrap;
        overscroll-behavior-inline: none; /* অনুভূমিক স্ক্রল চেইনিং ও বাউন্স বন্ধ */
    }
    ```

223. **`overscroll-behavior-x`**: শুধুমাত্র অনুভূমিক ওভারস্ক্রল আচরণ নিয়ন্ত্রণ করে।
 ```css
    .slider-x {
        overflow-x: auto;
        overscroll-behavior-x: contain; /* অনুভূমিক স্ক্রল প্যারেন্টকে প্রভাবিত করবে না */
    }
    ```

224. **`overscroll-behavior-y`**: শুধুমাত্র উল্লম্ব ওভারস্ক্রল আচরণ নিয়ন্ত্রণ করে।
 ```css
    .dropdown-menu {
        max-height: 200px; overflow-y: auto;
        overscroll-behavior-y: none; /* উল্লম্ব স্ক্রল চেইনিং ও বাউন্স বন্ধ */
    }
    ```

225. **`padding`**: একটি এলিমেন্টের কন্টেন্ট এবং তার বর্ডারের মধ্যেকার ফাঁকা জায়গা বা প্যাডিং নির্ধারণ করে। এটি এক থেকে চারটি মান নিতে পারে (top, right, bottom, left)।
 ```css
    .padded-box {
        padding: 10px 20px; /* উপরে-নিচে ১০ পিক্সেল, ডানে-বামে ২০ পিক্সেল প্যাডিং */
        border: 1px solid;
    }
    .all-sides-padding {
        padding: 15px; /* চারদিকে ১৫ পিক্সেল প্যাডিং */
        background-color: #eee;
    }
    ```

226. **`padding-block`**: লজিক্যাল প্রপার্টি; `padding-top` ও `padding-bottom` (অনুভূমিক লেখার মোডে) এর শর্টহ্যান্ড।
  ```css
    .element-padding-block {
        padding-block: 0.5em 1em; /* padding-block-start: 0.5em; padding-block-end: 1em; */
    }
    ```

227. **`padding-block-end`**: লজিক্যাল প্রপার্টি; `padding-bottom` (অনুভূমিক লেখার মোডে) এর সমতুল্য।
 ```css
    .block-end-padding {
        padding-block-end: 10px;
    }
    ```

228. **`padding-block-start`**: লজিক্যাল প্রপার্টি; `padding-top` (অনুভূমিক লেখার মোডে) এর সমতুল্য।
 ```css
    .block-start-padding {
        padding-block-start: 5px;
    }
    ```

229. **`padding-bottom`**: এলিমেন্টের নিচের প্যাডিং নির্ধারণ করে।
 ```css
    button {
        padding-bottom: 8px;
    }
    ```

230. **`padding-inline`**: লজিক্যাল প্রপার্টি; `padding-left` ও `padding-right` (অনুভূমিক লেখার মোডে) এর শর্টহ্যান্ড।
  ```css
    .text-container-padding-inline {
        padding-inline: 2%; /* ডানে-বামে কন্টেইনারের প্রস্থের ২% প্যাডিং */
    }
    ```

231. **`padding-inline-end`**: লজিক্যাল প্রপার্টি; `padding-right` (বাম-থেকে-ডান অনুভূমিক মোডে) এর সমতুল্য।
  ```css
    .inline-end-padding {
        padding-inline-end: 12px;
    }
    ```

232. **`padding-inline-start`**: লজিক্যাল প্রপার্টি; `padding-left` (বাম-থেকে-ডান অনুভূমিক মোডে) এর সমতুল্য।
 ```css
    .inline-start-padding {
        padding-inline-start: 12px;
    }
    ```

233. **`padding-left`**: এলিমেন্টের বাম প্যাডিং নির্ধারণ করে।
 ```css
    .list-item {
        padding-left: 20px; /* লিস্ট আইটেমের বাম দিকে ২০ পিক্সেল প্যাডিং */
    }
    ```

234. **`padding-right`**: এলিমেন্টের ডান প্যাডিং নির্ধারণ করে।
  ```css
    .input-field-wrapper {
        padding-right: 10px;
    }
    ```

235. **`padding-top`**: এলিমেন্টের উপরের প্যাডিং নির্ধারণ করে।
  ```css
    .card-content {
        padding-top: 15px;
    }
    ```

236. **`page`**: `@page` ನಿಯমের মধ্যে প্রিন্ট করা পৃষ্ঠার জন্য একটি নির্দিষ্ট নাম বা ধরন (`:left`, `:right`, `:first`) নির্ধারণ করতে ব্যবহৃত হয়, যার মাধ্যমে বিভিন্ন পৃষ্ঠার জন্য ভিন্ন মার্জিন বা হেডার/ফুটার সেট করা যায়।
 ```css
    @page :first { /* প্রথম পৃষ্ঠার জন্য বিশেষ স্টাইল */
        margin-top: 4cm;
    }
    @page chapter-start { /* 'chapter-start' নামের পেজের জন্য */
        margin-left: 3cm;
    }
    .chapter-title {
        page: chapter-start; /* এই এলিমেন্টটি 'chapter-start' পেজ ফরম্যাট ব্যবহার করবে */
        break-before: page;
    }
    ```
    **ব্যাখ্যা:** এটি প্রিন্ট স্টাইলশীটের জন্য ব্যবহৃত হয়।

237. **`page-break-after`**: (অপ্রচলিত, এর পরিবর্তে `break-after` ব্যবহার করুন) একটি এলিমেন্টের পরে পেজ ব্রেক হবে কিনা তা নির্ধারণ করে (`auto`, `always`, `avoid`, `left`, `right`)।
 ```css
    .section-end {
        page-break-after: always; /* এই এলিমেন্টের পর সবসময় নতুন পেজ শুরু হবে (অপ্রচলিত) */
    }
    ```

238. **`page-break-before`**: (অপ্রচলিত, এর পরিবর্তে `break-before` ব্যবহার করুন) একটি এলিমেন্টের আগে পেজ ব্রেক হবে কিনা তা নির্ধারণ করে।
 ```css
    .new-chapter {
        page-break-before: always; /* এই এলিমেন্টের আগে সবসময় নতুন পেজ শুরু হবে (অপ্রচলিত) */
    }
    ```

239. **`page-break-inside`**: (অপ্রচলিত, এর পরিবর্তে `break-inside` ব্যবহার করুন) একটি এলিমেন্টের ভেতরে পেজ ব্রেক এড়ানো হবে কিনা তা নির্ধারণ করে (`auto`, `avoid`)।
 ```css
    figure.no-break {
        page-break-inside: avoid; /* এই ফিগারের ভেতরে পেজ ব্রেক হবে না (অপ্রচলিত) */
    }
    ```

240. **`paint-order`**: SVG টেক্সট বা আকৃতির `fill` (ভরাট), `stroke` (রেখা), এবং `markers` (যেমন তীরের মাথা) কোন ক্রমে আঁকা হবে তা নির্ধারণ করে।
 ```css
    text.outlined-text {
        stroke: black;
        stroke-width: 2px;
        fill: white;
        paint-order: stroke fill; /* প্রথমে স্ট্রোক আঁকা হবে, তারপর তার উপরে ফিল */
    }
    ```
    **ব্যাখ্যা:** এটি SVG এর স্টাইলিং এর জন্য বেশি প্রাসঙ্গিক।

241. **`perspective`**: 3D ট্রান্সফর্মেশন করা চাইল্ড এলিমেন্টগুলোর জন্য একটি দৃষ্টিকোণ বা পার্সপেক্টিভ নির্ধারণ করে। এটি প্যারেন্ট এলিমেন্টে সেট করা হয়। মান যত কম, পার্সপেক্টিভ তত বেশি অতিরঞ্জিত।
 ```css
    .scene {
        width: 200px; height: 200px; border: 1px solid black;
        perspective: 500px; /* ৫০০ পিক্সেল দূর থেকে দেখার দৃষ্টিকোণ */
    }
    .scene .cube {
        width: 100px; height: 100px; background-color: skyblue;
        transform: rotateY(45deg); /* এই ঘূর্ণনটি পার্সপেক্টিভের কারণে 3D দেখাবে */
        margin: 50px;
    }
    ```

242. **`perspective-origin`**: 3D পার্সপেক্টিভের "vanishing point" বা দৃষ্টিকোণের উৎস বিন্দু নির্ধারণ করে (`perspective` প্রপার্টি সেট করা এলিমেন্টে)।
 ```css
    .scene-origin {
        perspective: 600px;
        perspective-origin: top right; /* দৃষ্টিকোণের উৎস উপরে ডানদিকে */
    }
    .scene-origin .transformed-object {
        transform: rotateX(30deg);
    }
    ```

243. **`place-content`**: গ্রিড বা ফ্লেক্সবক্স কন্টেইনারে `align-content` এবং `justify-content` প্রপার্টি একসাথে লেখার শর্টহ্যান্ড। প্রথম মান `align-content`, দ্বিতীয় মান `justify-content`।
 ```css
    .grid-container-place {
        display: grid; height: 200px; width: 200px; border: 1px solid;
        grid-template-columns: repeat(2, 50px);
        grid-template-rows: repeat(2, 50px);
        place-content: center space-around;
        /* align-content: center; justify-content: space-around; */
    }
    ```

244. **`place-items`**: গ্রিড বা ফ্লেক্সবক্স কন্টেইনারে `align-items` এবং `justify-items` প্রপার্টি একসাথে লেখার শর্টহ্যান্ড। প্রথম মান `align-items`, দ্বিতীয় মান `justify-items`।
 ```css
    .grid-container-place-items {
        display: grid;
        grid-template-columns: 100px 100px;
        place-items: center end;
        /* align-items: center; justify-items: end; */
        border: 1px solid;
    }
    .grid-container-place-items div { background: #eee; padding: 5px; }
    ```

245. **`place-self`**: গ্রিড আইটেমের `align-self` এবং `justify-self` প্রপার্টি একসাথে লেখার শর্টহ্যান্ড। প্রথম মান `align-self`, দ্বিতীয় মান `justify-self`।
 ```css
    .grid-container-place-self { display: grid; grid-template-columns: 1fr 1fr; border:1px solid; }
    .special-placed-item {
        place-self: center end; /* উল্লম্বভাবে মাঝখানে, অনুভূমিকভাবে শেষে */
        background-color: lightgreen;
    }
    .grid-container-place-self div { padding:10px; border:1px dashed gray;}
    ```

246. **`pointer-events`**: একটি এলিমেন্ট মাউস বা টাচ ইভেন্টের (যেমন ক্লিক, হোভার) লক্ষ্যবস্তু হতে পারবে কিনা তা নির্ধারণ করে। `none` মান দিলে এলিমেন্টটি ইভেন্টের জন্য "অদৃশ্য" হয়ে যায়।
 ```css
    .non-clickable-overlay {
        position: absolute; inset: 0;
        background-color: rgba(255,0,0,0.2); /* হালকা লাল ওভারলে */
        pointer-events: none; /* এই ওভারলেতে ক্লিক করলে এর পেছনের এলিমেন্টে ক্লিক হবে */
    }
    button.disabled-look {
        opacity: 0.5;
        pointer-events: none; /* বাটনটি ক্লিক করা যাবে না */
    }
    ```

247. **`position`**: একটি এলিমেন্টের পজিশনিং পদ্ধতি নির্ধারণ করে (`static` (ডিফল্ট), `relative`, `absolute`, `fixed`, `sticky`)।
 ```css
    .relative-box {
        position: relative; /* তার স্বাভাবিক অবস্থানের সাপেক্ষে সরানো যাবে */
        top: 10px; left: 20px;
    }
    .absolute-box {
        position: absolute; /* তার নিকটতম পজিশন করা প্যারেন্টের সাপেক্ষে পজিশন হবে */
        top: 0; right: 0;
    }
    .fixed-box {
        position: fixed; /* ভিউপোর্টের সাপেক্ষে পজিশন হবে, স্ক্রল করলেও নড়বে না */
        bottom: 10px; right: 10px;
    }
    .sticky-header {
        position: sticky; /* স্ক্রল করার সময় একটি নির্দিষ্ট বিন্দুতে আটকে যাবে */
        top: 0; background-color: white; z-index: 100;
    }
    ```

248. **`quotes`**: `content` প্রপার্টিতে `open-quote` এবং `close-quote` মান ব্যবহার করার সময় কোন উদ্ধৃতি চিহ্নগুলো ব্যবহৃত হবে তা নির্ধারণ করে।
 ```css
    q {
        quotes: "“" "”" "‘" "’"; /* প্রথম জোড়া প্রধান উদ্ধৃতি, দ্বিতীয় জোড়া নেস্টেড উদ্ধৃতির জন্য */
    }
    q::before { content: open-quote; }
    q::after { content: close-quote; }
    ```
    ```html
    <p>তিনি বললেন, <q>আমি কি <q>এটা</q> করতে পারি?</q></p>
    <!-- আউটপুট: তিনি বললেন, “আমি কি ‘এটা’ করতে পারি?” -->
    ```

249. **`resize`**: ব্যবহারকারী একটি এলিমেন্টকে রিসাইজ (আকার পরিবর্তন) করতে পারবে কিনা এবং কোন দিকে (`none`, `both`, `horizontal`, `vertical`, `block`, `inline`) তা নির্ধারণ করে। এলিমেন্টের `overflow` প্রপার্টি `visible` ছাড়া অন্য কিছু হতে হবে।
 ```css
    textarea.resizable-both {
        resize: both; /* ব্যবহারকারী উভয় দিকে রিসাইজ করতে পারবে */
        overflow: auto;
    }
    div.resizable-horizontal {
        resize: horizontal; /* শুধুমাত্র অনুভূমিকভাবে রিসাইজ করা যাবে */
        overflow: auto; width: 200px; height: 100px; border: 1px solid;
    }
    ```

250. **`right`**: পজিশন করা এলিমেন্টের ডান প্রান্ত তার কন্টেইনিং ব্লকের ডান প্রান্ত থেকে কত দূরে থাকবে তা নির্ধারণ করে।
  ```css
    .alert-banner {
        position: fixed;
        top: 20px;
        right: 20px; /* ভিউপোর্টের ডান দিক থেকে ২০ পিক্সেল দূরে */
        background-color: yellow; padding: 10px;
    }
    ```
---
অবশ্যই! CSS প্রপার্টির তালিকার পরবর্তী অংশ নিচে দেওয়া হলো:

---

251. **`rotate`**: ( `transform` প্রপার্টির একটি স্বতন্ত্র রূপ) একটি এলিমেন্টকে একটি নির্দিষ্ট কোণে ঘোরানো (rotate) নির্দেশ করে।
 ```css
    .rotated-div {
        width: 100px; height: 100px; background: lightblue;
        rotate: 45deg; /* এলিমেন্টটি ৪৫ ডিগ্রি ঘুরবে */
        margin: 30px;
    }
    .rotate-z-axis {
        rotate: z 30deg; /* Z-অক্ষ বরাবর ৩০ ডিগ্রি ঘুরবে (2D ঘূর্ণনের মতো) */
    }
    .rotate-3d {
        rotate: 1 1 0 60deg; /* x=1, y=1, z=0 ভেক্টর বরাবর ৬০ ডিগ্রি ঘুরবে (3D) */
    }
    ```

252. **`row-gap`**: গ্রিড বা ফ্লেক্সবক্স কন্টেইনারে সারিগুলোর মধ্যে ফাঁক নির্ধারণ করে। (এটি এখন `gap` প্রপার্টির অংশ, তবে স্বতন্ত্রভাবেও কাজ করে)।
 ```css
    .grid-with-row-gap {
        display: grid;
        grid-template-columns: 1fr 1fr;
        row-gap: 25px; /* সারিগুলোর মধ্যে ২৫ পিক্সেল ফাঁক */
    }
    .flex-with-row-gap {
        display: flex;
        flex-wrap: wrap; /* সারি তৈরি হওয়ার জন্য */
        row-gap: 10px;
    }
    ```

253. **`scale`**: ( `transform` প্রপার্টির একটি স্বতন্ত্র রূপ) একটি এলিমেন্টকে একটি নির্দিষ্ট ফ্যাক্টর দ্বারা স্কেল (বড় বা ছোট) করা নির্দেশ করে।
  ```css
    .scaled-element {
        width: 50px; height: 50px; background: lightgreen;
        scale: 1.5; /* এলিমেন্টটি ১.৫ গুণ বড় হবে */
        margin: 20px;
    }
    .scale-xy {
        scale: 2 0.5; /* X-অক্ষ বরাবর ২ গুণ, Y-অক্ষ বরাবর ০.৫ গুণ স্কেল হবে */
    }
    ```

254. **`scroll-behavior`**: যখন ব্যবহারকারী একটি ইন-পেজ লিঙ্কে (যেমন `#section2`) ক্লিক করে বা জাভাস্ক্রিপ্টের মাধ্যমে স্ক্রলিং শুরু হয়, তখন স্ক্রলিং মসৃণভাবে (`smooth`) হবে নাকি তাৎক্ষণিকভাবে (`auto`, ডিফল্ট) হবে তা নির্ধারণ করে।
 ```css
    html { /* সাধারণত html বা body তে সেট করা হয় */
        scroll-behavior: smooth;
    }
    ```
    ```html
    <a href="#target-section">সেকশনে যান</a>
    <!-- ... অনেক কন্টেন্ট ... -->
    <section id="target-section">লক্ষ্য সেকশন</section>
    ```
    **ব্যাখ্যা:** লিঙ্কে ক্লিক করলে পৃষ্ঠাটি মসৃণভাবে স্ক্রল করে `target-section` এ যাবে।

255. **`scroll-margin`**: ( `scroll-snap-margin` এর পুরনো নাম) স্ক্রল স্ন্যাপিং এর সময়, স্ন্যাপ পজিশনের চারপাশে একটি "অদৃশ্য" মার্জিন তৈরি করে। এটি `scroll-margin-top`, `scroll-margin-right` ইত্যাদির শর্টহ্যান্ড।
 ```css
    .scroll-container {
        scroll-snap-type: y mandatory;
        height: 300px; overflow-y: scroll;
    }
    .snap-item {
        height: 300px;
        scroll-margin: 20px; /* স্ন্যাপ করার সময় চারপাশে ২০px মার্জিন থাকবে */
        scroll-snap-align: start;
        border: 2px solid blue; margin-bottom: 10px;
    }
    ```
    **ব্যাখ্যা:** স্ন্যাপ আইটেমটি ভিউপোর্টের প্রান্ত থেকে ২০ পিক্সেল দূরত্বে স্ন্যাপ করবে।

256. **`scroll-margin-block`**: লজিক্যাল প্রপার্টি; স্ক্রল স্ন্যাপিং এর জন্য ব্লক দিকের (`scroll-margin-top` ও `scroll-margin-bottom`) মার্জিন নির্ধারণ করে।
  ```css
    .snap-item-block-margin {
        scroll-margin-block: 10px 15px; /* block-start: 10px; block-end: 15px; */
    }
    ```

257. **`scroll-margin-block-end`**: লজিক্যাল প্রপার্টি; স্ক্রল স্ন্যাপিং এর জন্য ব্লক দিকের শেষ প্রান্তের মার্জিন নির্ধারণ করে।
 ```css
    .item { scroll-margin-block-end: 5vh; }
    ```

258. **`scroll-margin-block-start`**: লজিক্যাল প্রপার্টি; স্ক্রল স্ন্যাপিং এর জন্য ব্লক দিকের শুরু প্রান্তের মার্জিন নির্ধারণ করে।
  ```css
    .item { scroll-margin-block-start: 20px; }
    ```

259. **`scroll-margin-bottom`**: স্ক্রল স্ন্যাপিং এর জন্য নিচের মার্জিন নির্ধারণ করে।
    ```css
    .snap-target {
        scroll-margin-bottom: 10%; /* ভিউপোর্টের উচ্চতার ১০% নিচে স্ন্যাপ করবে */
    }
    ```

260. **`scroll-margin-inline`**: লজিক্যাল প্রপার্টি; স্ক্রল স্ন্যাপিং এর জন্য ইনলাইন দিকের (`scroll-margin-left` ও `scroll-margin-right`) মার্জিন নির্ধারণ করে।
    ```css
    .snap-item-inline-margin {
        scroll-margin-inline: 5px; /* inline-start: 5px; inline-end: 5px; */
    }
    ```

261. **`scroll-margin-inline-end`**: লজিক্যাল প্রপার্টি; স্ক্রল স্ন্যাপিং এর জন্য ইনলাইন দিকের শেষ প্রান্তের মার্জিন নির্ধারণ করে।
    ```css
    .item { scroll-margin-inline-end: 30px; }
    ```

262. **`scroll-margin-inline-start`**: লজিক্যাল প্রপার্টি; স্ক্রল স্ন্যাপিং এর জন্য ইনলাইন দিকের শুরু প্রান্তের মার্জিন নির্ধারণ করে।
    ```css
    .item { scroll-margin-inline-start: 10px; }
    ```

263. **`scroll-margin-left`**: স্ক্রল স্ন্যাপিং এর জন্য বাম মার্জিন নির্ধারণ করে।
    ```css
    .gallery-image {
        scroll-margin-left: 15px;
    }
    ```

264. **`scroll-margin-right`**: স্ক্রল স্ন্যাপিং এর জন্য ডান মার্জিন নির্ধারণ করে।
    ```css
    .card-in-slider {
        scroll-margin-right: 10px;
    }
    ```

265. **`scroll-margin-top`**: স্ক্রল স্ন্যাপিং এর জন্য উপরের মার্জিন নির্ধারণ করে। একটি স্টিকি হেডারের নিচে কন্টেন্ট স্ন্যাপ করার জন্য এটি খুব দরকারী।
    ```css
    .section-to-snap {
        scroll-margin-top: 60px; /* যদি একটি ৬০px উঁচু স্টিকি হেডার থাকে */
    }
    ```

266. **`scroll-padding`**: স্ক্রল কন্টেইনারের প্রান্ত এবং স্ন্যাপ পজিশনের মধ্যে একটি "অদৃশ্য" প্যাডিং তৈরি করে। এটি `scroll-padding-top`, `scroll-padding-right` ইত্যাদির শর্টহ্যান্ড।
    ```css
    .scroll-container-padding {
        scroll-snap-type: y mandatory;
        height: 400px; overflow-y: scroll;
        scroll-padding: 50px 0 0 0; /* উপরে ৫০px প্যাডিং, স্ন্যাপ আইটেমগুলো এই প্যাডিংয়ের নিচে স্ন্যাপ করবে */
    }
    .snap-child { height: 400px; scroll-snap-align: start; border: 1px solid; }
    ```

267. **`scroll-padding-block`**: লজিক্যাল প্রপার্টি; স্ক্রল কন্টেইনারের ব্লক দিকের (`scroll-padding-top` ও `scroll-padding-bottom`) প্যাডিং নির্ধারণ করে।
    ```css
    .container { scroll-padding-block: 1em; }
    ```

268. **`scroll-padding-block-end`**: লজিক্যাল প্রপার্টি; স্ক্রল কন্টেইনারের ব্লক দিকের শেষ প্রান্তের প্যাডিং নির্ধারণ করে।
    ```css
    .container { scroll-padding-block-end: 20px; }
    ```

269. **`scroll-padding-block-start`**: লজিক্যাল প্রপার্টি; স্ক্রল কন্টেইনারের ব্লক দিকের শুরু প্রান্তের প্যাডিং নির্ধারণ করে।
    ```css
    .container { scroll-padding-block-start: 10%; }
    ```

270. **`scroll-padding-bottom`**: স্ক্রল কন্টেইনারের নিচের প্যাডিং নির্ধারণ করে।
    ```css
    .scroll-box { scroll-padding-bottom: 30px; }
    ```

271. **`scroll-padding-inline`**: লজিক্যাল প্রপার্টি; স্ক্রল কন্টেইনারের ইনলাইন দিকের (`scroll-padding-left` ও `scroll-padding-right`) প্যাডিং নির্ধারণ করে।
    ```css
    .container { scroll-padding-inline: 5vw; }
    ```

272. **`scroll-padding-inline-end`**: লজিক্যাল প্রপার্টি; স্ক্রল কন্টেইনারের ইনলাইন দিকের শেষ প্রান্তের প্যাডিং নির্ধারণ করে।
    ```css
    .container { scroll-padding-inline-end: 15px; }
    ```

273. **`scroll-padding-inline-start`**: লজিক্যাল প্রপার্টি; স্ক্রল কন্টেইনারের ইনলাইন দিকের শুরু প্রান্তের প্যাডিং নির্ধারণ করে।
    ```css
    .container { scroll-padding-inline-start: 15px; }
    ```

274. **`scroll-padding-left`**: স্ক্রল কন্টেইনারের বাম প্যাডিং নির্ধারণ করে।
    ```css
    .horizontal-scroller { scroll-padding-left: 10px; }
    ```

275. **`scroll-padding-right`**: স্ক্রল কন্টেইনারের ডান প্যাডিং নির্ধারণ করে।
    ```css
    .horizontal-scroller { scroll-padding-right: 10px; }
    ```

276. **`scroll-padding-top`**: স্ক্রল কন্টেইনারের উপরের প্যাডিং নির্ধারণ করে।
    ```css
    .vertical-scroller { scroll-padding-top: 50px; /* স্টিকি হেডারের জন্য জায়গা */ }
    ```

277. **`scroll-snap-align`**: একটি স্ক্রল কন্টেইনারের চাইল্ড এলিমেন্টগুলো ভিউপোর্টের কোন অংশে ( `start`, `center`, `end`, `none`) স্ন্যাপ বা সারিবদ্ধ হবে তা নির্ধারণ করে।
    ```css
    .scroll-container-snap {
        scroll-snap-type: x mandatory;
        display: flex; overflow-x: scroll; width: 300px;
    }
    .snap-child-align {
        flex: 0 0 100%; /* প্রতিটি আইটেম কন্টেইনারের সমান প্রস্থের */
        height: 100px;
        scroll-snap-align: center; /* প্রতিটি আইটেম স্ক্রল করার সময় ভিউপোর্টের মাঝখানে স্ন্যাপ করবে */
        border: 1px solid red;
    }
    ```

278. **`scroll-snap-stop`**: স্ক্রল করার সময় ব্রাউজার স্ন্যাপ পয়েন্টগুলোতে সবসময় (`always`) থামবে, নাকি দ্রুত স্ক্রল করলে কিছু স্ন্যাপ পয়েন্ট এড়িয়ে যেতে (`normal`, ডিফল্ট) পারবে তা নির্ধারণ করে।
    ```css
    .gallery-container {
        scroll-snap-type: x mandatory;
        scroll-snap-stop: always; /* প্রতিটি স্ন্যাপ পয়েন্টে অবশ্যই থামবে */
    }
    ```

279. **`scroll-snap-type`**: একটি স্ক্রল কন্টেইনারে স্ক্রল স্ন্যাপিং সক্রিয় করে এবং কোন অক্ষ বরাবর ( `x`, `y`, `block`, `inline`, `both`) এবং কতটা কঠোরভাবে (`mandatory`, `proximity`) স্ন্যাপিং হবে তা নির্ধারণ করে।
    ```css
    .vertical-snap-container {
        height: 400px;
        overflow-y: scroll;
        scroll-snap-type: y mandatory; /* উল্লম্ব দিকে বাধ্যতামূলক স্ন্যাপিং */
    }
    .horizontal-snap-container {
        display: flex;
        overflow-x: scroll;
        scroll-snap-type: x proximity; /* অনুভূমিক দিকে কাছাকাছি স্ন্যাপিং */
    }
    ```

280. **`scrollbar-color`**: স্ক্রলবারের থাম্ব (যেটি ড্র্যাগ করা হয়) এবং ট্র্যাকের (যেটির উপর থাম্ব চলে) রঙ নির্ধারণ করে। (ফায়ারফক্সে ভালো সমর্থন)
    ```css
    .custom-scrollbar {
        width: 200px; height: 100px; overflow: auto;
        scrollbar-color: darkblue lightblue; /* থাম্বের রঙ darkblue, ট্র্যাকের রঙ lightblue */
        border: 1px solid;
    }
    ```

281. **`scrollbar-gutter`**: স্ক্রলবার দেখানোর জন্য একটি স্থায়ী ফাঁকা জায়গা (gutter) রিজার্ভ করা হবে কিনা তা নির্ধারণ করে, যাতে কন্টেন্ট লোড হওয়ার সাথে স্ক্রলবার এলে লেআউট শিফট না হয়। (`auto`, `stable`, `stable both-edges`)
    ```css
    .container-with-gutter {
        height: 150px; overflow-y: auto;
        scrollbar-gutter: stable; /* স্ক্রলবার না থাকলেও তার জন্য জায়গা রিজার্ভ থাকবে */
    }
    ```

282. **`scrollbar-width`**: স্ক্রলবারের প্রস্থ কেমন হবে তা নির্ধারণ করে (`auto`, `thin`, `none`)।
    ```css
    .thin-scrollbar-div {
        width: 150px; height: 100px; overflow: auto;
        scrollbar-width: thin; /* স্ক্রলবার চিকন হবে */
        scrollbar-color: gray lightgray;
        border: 1px solid;
    }
    ```

283. **`shape-image-threshold`**: যখন `shape-outside` এর জন্য একটি ইমেজ (আলফা চ্যানেল সহ) ব্যবহার করা হয়, তখন কোন পিক্সেলগুলো শেপের অংশ হিসেবে বিবেচিত হবে তার জন্য আলফা মানের (স্বচ্ছতার) একটি থ্রেশহোল্ড (সীমা) নির্ধারণ করে।
    ```css
    .image-shape {
        float: left;
        width: 150px; height: 150px;
        shape-outside: url("alpha-mask-image.png");
        shape-image-threshold: 0.5; /* যে পিক্সেলের আলফা মান ০.৫ এর বেশি, সেটি শেপের অংশ হবে */
    }
    ```
    **ব্যাখ্যা:** টেক্সট ইমেজটির অস্বচ্ছ অংশের চারপাশে প্রবাহিত হবে।

284. **`shape-margin`**: `shape-outside` দ্বারা তৈরি শেপের চারপাশে একটি অতিরিক্ত মার্জিন বা ফাঁকা জায়গা যোগ করে।
    ```css
    .shape-with-margin {
        float: right;
        width: 120px; height: 120px;
        shape-outside: circle(50%);
        shape-margin: 15px; /* বৃত্তাকার শেপের চারপাশে ১৫ পিক্সেল অতিরিক্ত ফাঁকা জায়গা থাকবে */
        background-color: lightblue;
    }
    ```
    **ব্যাখ্যা:** টেক্সট বৃত্ত থেকে ১৫ পিক্সেল দূরত্ব বজায় রেখে প্রবাহিত হবে।

285. **`shape-outside`**: একটি ফ্লোটিং এলিমেন্টের চারপাশে কন্টেন্ট (সাধারণত টেক্সট) কীভাবে প্রবাহিত হবে তার জন্য একটি জ্যামিতিক আকৃতি (যেমন বৃত্ত, উপবৃত্ত, বহুভুজ, বা আলফা মাস্ক সহ ইমেজ) নির্ধারণ করে।
    ```css
    .circle-float {
        float: left;
        width: 100px; height: 100px;
        shape-outside: circle(50% at 50% 50%); /* একটি বৃত্তাকার শেপ তৈরি করবে */
        background-color: lightcoral; clip-path: circle(50%); /* এলিমেন্টটিকেও বৃত্তাকার দেখাতে */
        margin-right: 10px;
    }
    ```
    **ব্যাখ্যা:** টেক্সট এলিমেন্টটির বৃত্তাকার আকৃতির চারপাশে প্রবাহিত হবে।

286. **`tab-size`**: টেক্সটের মধ্যে ট্যাব ক্যারেক্টার (`\t`) কতগুলো স্পেসের সমান প্রস্থ নেবে তা নির্ধারণ করে।
    ```css
    pre.code-block {
        tab-size: 4; /* একটি ট্যাব ৪টি স্পেসের সমান হবে */
        white-space: pre; /* স্পেস ও ট্যাব সংরক্ষিত রাখতে */
    }
    ```

287. **`table-layout`**: টেবিলের কলামের প্রস্থ কীভাবে গণনা করা হবে তার অ্যালগরিদম নির্ধারণ করে। `auto` (ডিফল্ট) মানে কন্টেন্টের উপর ভিত্তি করে, `fixed` মানে টেবিল বা কলামের প্রস্থের উপর ভিত্তি করে (যা দ্রুত রেন্ডার হতে পারে)।
    ```css
    table.fixed-layout {
        width: 400px;
        table-layout: fixed; /* কলামের প্রস্থ টেবিলের প্রস্থ এবং col/th/td এর প্রস্থ অনুযায়ী নির্ধারিত হবে, কন্টেন্ট অনুযায়ী নয় */
    }
    table.fixed-layout td {
        white-space: nowrap; overflow: hidden; text-overflow: ellipsis; /* লম্বা কন্টেন্ট কেটে (...) দেখাবে */
    }
    ```

288. **`text-align`**: একটি ব্লক-লেভেল এলিমেন্টের ভেতরের ইনলাইন কন্টেন্ট (যেমন টেক্সট, ইমেজ) অনুভূমিকভাবে কীভাবে সারিবদ্ধ হবে তা নির্ধারণ করে (`left`, `right`, `center`, `justify`, `start`, `end`)।
    ```css
    p.centered-text {
        text-align: center; /* টেক্সট মাঝখানে সারিবদ্ধ হবে */
    }
    .justified-paragraph {
        text-align: justify; /* টেক্সট উভয় দিকে সমানভাবে ছড়ানো থাকবে */
    }
    ```

289. **`text-align-last`**: `text-align: justify` ব্যবহার করা একটি টেক্সট ব্লকের শেষ লাইনের সারিবদ্ধকরণ কীভাবে হবে তা নির্ধারণ করে (`auto`, `start`, `end`, `left`, `right`, `center`, `justify`)।
    ```css
    .justified-block {
        text-align: justify;
        text-align-last: right; /* জাস্টিফাইড টেক্সটের শেষ লাইনটি ডান দিকে সারিবদ্ধ হবে */
    }
    ```

290. **`text-combine-upright`**: উল্লম্ব লেখার মোডে ( `writing-mode: vertical-rl` বা `vertical-lr`), নির্দিষ্ট সংখ্যক অক্ষর বা সংখ্যাকে (সাধারণত ৪টির কম) অনুভূমিকভাবে একটি একক উল্লম্ব অক্ষরের জায়গায় প্রদর্শন করার অনুমতি দেয়। (বিশেষত ইস্ট এশিয়ান ভাষার জন্য)। (`none`, `all`, `digits <integer>`)
    ```css
    .vertical-text-combined {
        writing-mode: vertical-rl;
        text-combine-upright: all; /* সব উপযুক্ত অক্ষর (যেমন ২টি সংখ্যা) অনুভূমিকভাবে দেখাবে */
    }
    ```
    ```html
    <p class="vertical-text-combined">縦中横<span style="text-combine-upright: all;">12</span>月</p>
    <!-- '12' সংখ্যাটি উল্লম্ব লাইনে অনুভূমিকভাবে দেখাবে -->
    ```

291. **`text-decoration`**: টেক্সটের সজ্জা যেমন আন্ডারলাইন, ওভারলাইন, লাইন-থ্রু এর জন্য একটি শর্টহ্যান্ড প্রপার্টি। এটি `text-decoration-line`, `text-decoration-color`, `text-decoration-style`, এবং `text-decoration-thickness` এর সমন্বয়।
    ```css
    a {
        text-decoration: none; /* লিঙ্কের ডিফল্ট আন্ডারলাইন সরিয়ে দেবে */
    }
    .highlighted-text {
        text-decoration: underline wavy red 2px;
        /* line style color thickness */
    }
    ```

292. **`text-decoration-color`**: `text-decoration-line` দ্বারা সংজ্ঞায়িত সজ্জার (যেমন আন্ডারলাইন) রঙ নির্ধারণ করে।
    ```css
    .red-underline {
        text-decoration-line: underline;
        text-decoration-color: red;
    }
    ```

293. **`text-decoration-line`**: টেক্সটের উপর কোন ধরনের সজ্জা রেখা ( `underline`, `overline`, `line-through`, `blink` (অপ্রচলিত), `none`) প্রয়োগ করা হবে তা নির্ধারণ করে। একাধিক মান স্পেস দিয়ে লেখা যায়।
    ```css
    .strike-and-underline {
        text-decoration-line: line-through underline;
    }
    ```

294. **`text-decoration-skip`**: (খুব বেশি ব্রাউজার সমর্থন নেই) `text-decoration-line` এর রেখা কোথায় স্কিপ বা এড়িয়ে যাওয়া হবে (যেমন ডিসেন্ডার, স্পেস) তা নির্ধারণ করে। এর পরিবর্তে `text-decoration-skip-ink` বেশি ব্যবহৃত হয়।
    ```css
    /* .skipped-decoration {
        text-decoration: underline;
        text-decoration-skip: objects spaces;
    } */
    /* Better use text-decoration-skip-ink */
    ```

295. **`text-decoration-skip-ink`**: আন্ডারলাইন বা ওভারলাইন যখন অক্ষরের ডিসেন্ডার (যেমন 'g', 'p' এর নিচের অংশ) বা অ্যাসেন্ডারের (যেমন 'h', 'l' এর উপরের অংশ) উপর দিয়ে যায়, তখন সেই অংশটুকুতে রেখা এড়িয়ে (`skip`) যাবে কিনা তা নিয়ন্ত্রণ করে (`none` বা `auto` (ডিফল্ট))।
    ```css
    a.ink-skip {
        text-decoration: underline;
        text-decoration-skip-ink: auto; /* অক্ষরের অংশ যাতে ঢেকে না যায় (ডিফল্ট) */
    }
    a.no-ink-skip {
        text-decoration: underline;
        text-decoration-skip-ink: none; /* অক্ষরের উপর দিয়েও রেখা যাবে */
    }
    ```

296. **`text-decoration-style`**: `text-decoration-line` দ্বারা সংজ্ঞায়িত সজ্জা রেখার স্টাইল নির্ধারণ করে (`solid` (ডিফল্ট), `double`, `dotted`, `dashed`, `wavy`)।
    ```css
    .wavy-underline {
        text-decoration-line: underline;
        text-decoration-style: wavy;
        text-decoration-color: blue;
    }
    ```

297. **`text-decoration-thickness`**: `text-decoration-line` দ্বারা সংজ্ঞায়িত সজ্জা রেখার পুরুত্ব নির্ধারণ করে (`auto`, `<length>`, `<percentage>`)।
    ```css
    .thick-overline {
        text-decoration-line: overline;
        text-decoration-thickness: 3px; /* বা 0.1em */
        text-decoration-color: green;
    }
    ```

298. **`text-emphasis`**: টেক্সটের উপর জোর দেওয়ার জন্য ছোট প্রতীক (emphasis mark) যোগ করার শর্টহ্যান্ড (`text-emphasis-style` এবং `text-emphasis-color`)। (বিশেষত ইস্ট এশিয়ান ভাষার জন্য)।
    ```css
    .emphasized-japanese {
        font-family: "MS Mincho", serif;
        text-emphasis: filled circle red; /* ভরাট বৃত্তাকার লাল রঙের এমফ্যাসিস মার্ক */
    }
    ```
    ```html
    <p class="emphasized-japanese">これは<em style="text-emphasis-style: sesame; text-emphasis-color: blue;">重要</em>です。</p>
    ```

299. **`text-emphasis-color`**: টেক্সট এমফ্যাসিস মার্কের রঙ নির্ধারণ করে।
    ```css
    .emphasis-custom-color {
        text-emphasis-style: dot;
        text-emphasis-color: purple;
    }
    ```

300. **`text-emphasis-position`**: টেক্সট এমফ্যাসিস মার্ক টেক্সটের উপরে (`over`) নাকি নিচে (`under`), এবং ডান (`right`) নাকি বাম (`left`) দিকে থাকবে তা নির্ধারণ করে (উল্লম্ব লেখার মোডের জন্য)।
    ```css
    .emphasis-above {
        text-emphasis-style: triangle;
        text-emphasis-position: over right; /* অনুভূমিক টেক্সটের উপরে, উল্লম্ব টেক্সটের ডানে */
    }
    ```

অবশ্যই! CSS প্রপার্টির তালিকার পরবর্তী এবং শেষ অংশ নিচে দেওয়া হলো:

---

301. **`text-emphasis-style`**: টেক্সট এমফ্যাসিস মার্কের আকৃতি নির্ধারণ করে (যেমন `none`, `filled`, `open`, `dot`, `circle`, `double-circle`, `triangle`, `sesame`, বা একটি `<string>`)।
    ```css
    .custom-emphasis {
        text-emphasis-style: '❤'; /* একটি কাস্টম স্ট্রিং (হার্ট) এমফ্যাসিস মার্ক হিসেবে */
        text-emphasis-color: deeppink;
    }
    .dot-emphasis {
        text-emphasis-style: filled dot;
    }
    ```

302. **`text-indent`**: একটি টেক্সট ব্লকের প্রথম লাইনের ইন্ডেন্টেশন (ভেতরের দিকে সরানো) নির্ধারণ করে।
    ```css
    p.indented-paragraph {
        text-indent: 30px; /* প্রথম লাইন ৩০ পিক্সেল ইন্ডেন্ট হবে */
    }
    p.hanging-indent {
        text-indent: -2em; /* প্রথম লাইন বাইরে যাবে (hanging indent) */
        padding-left: 2em; /* বাকি লাইনগুলো স্বাভাবিক রাখতে */
    }
    ```

303. **`text-justify`**: যখন `text-align: justify` ব্যবহার করা হয়, তখন টেক্সটকে জাস্টিফাই করার জন্য কোন পদ্ধতি ব্যবহার করা হবে তা নির্ধারণ করে (`auto`, `inter-word`, `inter-character`, `none`)।
    ```css
    .justified-text-interword {
        text-align: justify;
        text-justify: inter-word; /* শব্দের মধ্যে ফাঁকা জায়গা বাড়িয়ে জাস্টিফাই করবে (সাধারণত ডিফল্ট) */
    }
    .justified-text-interchar {
        text-align: justify;
        text-justify: inter-character; /* অক্ষরের মধ্যে ফাঁকা জায়গা বাড়িয়ে জাস্টিফাই করবে (ইস্ট এশিয়ান ভাষার জন্য) */
    }
    ```
    **ব্যাখ্যা:** এই প্রপার্টির ব্রাউজার সমর্থন এবং আচরণ ভিন্ন হতে পারে।

304. **`text-orientation`**: উল্লম্ব লেখার মোডে (`writing-mode: vertical-rl` বা `vertical-lr`) টেক্সটের অক্ষরগুলোর অভিযোজন (orientation) নিয়ন্ত্রণ করে (`mixed` (ডিফল্ট), `upright`, `sideways`)।
    ```css
    .vertical-text-upright {
        writing-mode: vertical-rl;
        text-orientation: upright; /* সব অক্ষর উল্লম্বভাবে সোজা থাকবে (যেমন ইস্ট এশিয়ান ভাষায়) */
        font-family: "SimSun", serif;
    }
    .vertical-text-sideways {
        writing-mode: vertical-rl;
        text-orientation: sideways; /* অক্ষরগুলো অনুভূমিক টেক্সটের মতো থাকবে, কিন্তু পুরো লাইন উল্লম্বভাবে ঘুরবে */
    }
    ```

305. **`text-overflow`**: যখন একটি ইনলাইন কন্টেন্ট (সাধারণত টেক্সট) তার কন্টেইনারের প্রস্থ ছাড়িয়ে যায় এবং `overflow` প্রপার্টি `hidden`, `scroll`, বা `auto` সেট করা থাকে, তখন অতিরিক্ত টেক্সট কীভাবে দেখানো হবে তা নির্ধারণ করে (`clip` (ডিফল্ট, কেটে ফেলা), `ellipsis` (...) ` বা একটি `<string>`)।
    ```css
    .ellipsis-overflow {
        width: 150px;
        white-space: nowrap; /* টেক্সটকে এক লাইনে রাখতে হবে */
        overflow: hidden; /* অতিরিক্ত অংশ লুকাতে হবে */
        text-overflow: ellipsis; /* অতিরিক্ত টেক্সটের জায়গায় ... দেখাবে */
        border: 1px solid; padding: 5px;
    }
    ```

306. **`text-rendering`**: টেক্সট রেন্ডারিংয়ের সময় ব্রাউজারকে অপটিমাইজেশনের জন্য হিন্ট দেয়, যেমন পাঠযোগ্যতা (`optimizeLegibility`), পারফরম্যান্স (`optimizeSpeed`), অথবা জ্যামিতিক নির্ভুলতা (`geometricPrecision`)।
    ```css
    body {
        text-rendering: optimizeLegibility; /* কার্নিং ও লিগ্যাচার ভালোভাবে দেখানোর চেষ্টা করবে */
    }
    /* অন্যান্য মান: auto, optimizeSpeed, geometricPrecision */
    ```
    **ব্যাখ্যা:** এই প্রপার্টির প্রভাব ব্রাউজার এবং ফন্টের উপর নির্ভরশীল।

307. **`text-shadow`**: টেক্সটের চারপাশে এক বা একাধিক ছায়া যোগ করে।
    ```css
    h1.shadowed-heading {
        text-shadow: 2px 2px 5px rgba(0,0,0,0.5);
        /* offset-x | offset-y | blur-radius | color */
    }
    .multi-shadow-text {
        color: white;
        text-shadow:
            1px 1px 0px #000,
            -1px -1px 0px #000,
            1px -1px 0px #000,
            -1px 1px 0px #000; /* একটি আউটলাইনের মতো ইফেক্ট */
    }
    ```

308. **`text-transform`**: টেক্সটের কেস (case) বা অক্ষর পরিবর্তন করে (`none` (ডিফল্ট), `capitalize` (প্রতিটি শব্দের প্রথম অক্ষর বড়), `uppercase` (সব অক্ষর বড়), `lowercase` (সব অক্ষর ছোট), `full-width` (ইস্ট এশিয়ান ভাষার জন্য))।
    ```css
    .page-title {
        text-transform: uppercase; /* সব অক্ষর বড় হাতের হবে */
    }
    .section-heading {
        text-transform: capitalize; /* প্রতিটি শব্দের প্রথম অক্ষর বড় হাতের হবে */
    }
    ```

309. **`text-underline-offset`**: `text-decoration-line: underline` দ্বারা তৈরি আন্ডারলাইনের উল্লম্ব অফসেট বা দূরত্ব টেক্সটের বেসলাইন থেকে নির্ধারণ করে।
    ```css
    a.custom-underline {
        text-decoration-line: underline;
        text-underline-offset: 3px; /* আন্ডারলাইন টেক্সট থেকে ৩ পিক্সেল নিচে থাকবে */
        text-decoration-thickness: 2px;
    }
    ```

310. **`text-underline-position`**: আন্ডারলাইন টেক্সটের কোন অংশে ( `auto` (ডিফল্ট), `under`, `left`, `right`) অবস্থান করবে তা নির্ধারণ করে (বিশেষত উল্লম্ব লেখার মোড এবং ডিসেন্ডার সহ অক্ষরের জন্য)।
    ```css
    .underline-below-descenders {
        text-decoration: underline;
        text-underline-position: under; /* আন্ডারলাইন ডিসেন্ডারগুলোর নিচে যাবে (যদি ফন্ট ও ব্রাউজার সমর্থন করে) */
    }
    ```

311. **`top`**: পজিশন করা এলিমেন্টের উপরের প্রান্ত তার কন্টেইনিং ব্লকের উপরের প্রান্ত থেকে কত দূরে থাকবে তা নির্ধারণ করে।
    ```css
    .modal-dialog {
        position: fixed;
        top: 50%; /* ভিউপোর্টের মাঝখানে আনার জন্য (transform দিয়ে সমন্বয় করতে হবে) */
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: white; padding: 20px;
    }
    ```

312. **`touch-action`**: একটি এলিমেন্টে টাচস্ক্রিন অঙ্গভঙ্গি (gestures) যেমন পিঞ্চ-জুম বা প্যানিং ব্রাউজারের ডিফল্ট আচরণকে কীভাবে প্রভাবিত করবে তা নিয়ন্ত্রণ করে।
    ```css
    .custom-map-canvas {
        touch-action: pan-y pinch-zoom; /* শুধুমাত্র উল্লম্ব প্যানিং এবং পিঞ্চ-জুম কাজ করবে, অনুভূমিক প্যানিং ব্রাউজার নিয়ন্ত্রণ করবে না */
    }
    .no-touch-scroll {
        touch-action: none; /* এই এলিমেন্টে কোনো ডিফল্ট টাচ আচরণ (যেমন স্ক্রলিং) কাজ করবে না */
    }
    ```
    **ব্যাখ্যা:** কাস্টম টাচ ইন্টারঅ্যাকশন তৈরির জন্য এটি গুরুত্বপূর্ণ। (আপনার তালিকায় `touch-action Sch` ছিল, সঠিক প্রপার্টি `touch-action`)

313. **`transform`**: একটি এলিমেন্টকে ঘোরানো (`rotate`), স্কেল করা (`scale`), সরানো (`translate`), বা তির্যক (`skew`) করার জন্য 2D বা 3D ট্রান্সফর্মেশন প্রয়োগ করে।
    ```css
    .transformed-box {
        width: 100px; height: 100px; background-color: teal;
        transform: rotate(30deg) scale(1.2) translateX(50px); /* একাধিক ট্রান্সফর্ম */
        margin: 50px;
    }
    .skewed-element {
        transform: skewX(20deg); /* X-অক্ষ বরাবর ২০ ডিগ্রি তির্যক হবে */
    }
    ```

314. **`transform-box`**: `transform` এবং `transform-origin` প্রপার্টিগুলো কোন রেফারেন্স বক্সের সাপেক্ষে কাজ করবে তা নির্ধারণ করে (`content-box`, `border-box`, `fill-box` (SVG), `stroke-box` (SVG), `view-box` (SVG))।
    ```css
    svg .transformed-group {
        transform-box: fill-box; /* ট্রান্সফর্মেশন SVG এলিমেন্টের fill box এর সাপেক্ষে হবে */
        transform-origin: center center;
        transform: rotate(45deg);
    }
    div.transformed-div {
        transform-box: border-box; /* ডিফল্ট (সাধারণ HTML এলিমেন্টের জন্য) */
        transform: scale(0.8);
    }
    ```

315. **`transform-origin`**: 2D বা 3D ট্রান্সফর্মেশনের কেন্দ্রবিন্দু বা উৎস বিন্দু নির্ধারণ করে। ডিফল্ট মান `50% 50%` (এলিমেন্টের কেন্দ্র)।
    ```css
    .rotated-from-corner {
        width: 100px; height: 100px; background-color: tomato;
        transform-origin: top left; /* উপরের বাম কোণা থেকে ঘুরবে */
        transform: rotate(45deg);
        margin: 50px;
    }
    ```

316. **`transform-style`**: নেস্টেড 3D ট্রান্সফর্মেশন করা এলিমেন্টগুলো কীভাবে রেন্ডার হবে তা নির্ধারণ করে। `preserve-3d` মান দিলে চাইল্ড এলিমেন্টগুলো প্যারেন্টের 3D স্পেসে থাকবে। `flat` (ডিফল্ট) মান দিলে তারা 2D প্লেনে সমতল হয়ে যাবে।
    ```css
    .scene-3d {
        perspective: 600px;
    }
    .cube-container {
        width: 100px; height: 100px; position: relative; margin: 50px;
        transform-style: preserve-3d; /* চাইল্ড ফেসগুলো 3D তে থাকবে */
        transform: rotateX(-30deg) rotateY(-45deg);
    }
    .cube-face {
        position: absolute; width: 100px; height: 100px;
        border: 1px solid black; background-color: rgba(0,150,255,0.7);
        /* প্রতিটি ফেসের জন্য আলাদা transform: rotate... translateZ... লাগবে */
    }
    ```

317. **`transition`**: একটি CSS প্রপার্টির মান পরিবর্তনের সময় অ্যানিমেটেড ট্রানজিশন (মসৃণ পরিবর্তন) ইফেক্ট তৈরি করার জন্য শর্টহ্যান্ড। এটি `transition-property`, `transition-duration`, `transition-timing-function`, এবং `transition-delay` এর সমন্বয়।
    ```css
    .button-hover-effect {
        background-color: blue;
        color: white;
        padding: 10px 20px;
        border-radius: 5px;
        transition: background-color 0.3s ease-in-out, transform 0.2s linear; /* দুটি প্রপার্টির জন্য ট্রানজিশন */
    }
    .button-hover-effect:hover {
        background-color: darkblue;
        transform: scale(1.05);
    }
    ```

318. **`transition-delay`**: ট্রানজিশন ইফেক্ট শুরু হওয়ার আগে কতক্ষণ দেরি হবে তা নির্ধারণ করে।
    ```css
    .delayed-fade-in {
        opacity: 0;
        transition-property: opacity;
        transition-duration: 0.5s;
        transition-delay: 1s; /* ১ সেকেন্ড পর ফেড-ইন শুরু হবে */
    }
    .delayed-fade-in.visible { /* একটি ক্লাস যোগ করে ট্রানজিশন ট্রিগার করা */
        opacity: 1;
    }
    ```

319. **`transition-duration`**: ট্রানজিশন ইফেক্টটি সম্পূর্ণ হতে কত সময় লাগবে তা নির্ধারণ করে।
    ```css
    .quick-transition {
        width: 100px; height: 100px; background: red;
        transition-property: width, background-color;
        transition-duration: 0.2s, 0.5s; /* প্রস্থ ০.২ সেকেন্ডে, ব্যাকগ্রাউন্ড ০.৫ সেকেন্ডে পরিবর্তিত হবে */
    }
    .quick-transition:hover { width: 150px; background-color: blue; }
    ```

320. **`transition-property`**: কোন CSS প্রপার্টি(গুলো)তে ট্রানজিশন ইফেক্ট প্রয়োগ করা হবে তা নির্ধারণ করে (`all` (ডিফল্ট), বা নির্দিষ্ট প্রপার্টির নাম যেমন `width`, `opacity`, `background-color`)।
    ```css
    .size-transition {
        transition-property: width, height; /* শুধুমাত্র প্রস্থ ও উচ্চতায় ট্রানজিশন হবে */
        transition-duration: 0.4s;
    }
    ```

321. **`transition-timing-function`**: ট্রানজিশন ইফেক্টের গতির বক্ররেখা (acceleration curve) নির্ধারণ করে (যেমন `ease`, `linear`, `ease-in`, `ease-out`, `ease-in-out`, `cubic-bezier(...)`)।
    ```css
    .smooth-transition {
        transition-property: opacity;
        transition-duration: 1s;
        transition-timing-function: ease-in-out; /* শুরুতে এবং শেষে ধীরে, মাঝে দ্রুত */
    }
    ```

322. **`translate`**: ( `transform` প্রপার্টির একটি স্বতন্ত্র রূপ) একটি এলিমেন্টকে X, Y, এবং Z (3D তে) অক্ষ বরাবর সরানো (translate) নির্দেশ করে।
    ```css
    .translated-element {
        width: 80px; height: 80px; background: purple;
        translate: 50px 20px; /* X-অক্ষে ৫০px, Y-অক্ষে ২০px সরবে */
        margin: 10px;
    }
    .translate-z {
        perspective: 300px; /* 3D তে দেখতে perspective লাগবে */
    }
    .translate-z .inner {
        width: 50px; height: 50px; background: gold;
        translate: 0 0 50px; /* Z-অক্ষে ৫০px সামনে আসবে */
    }
    ```

323. **`unicode-bidi`**: HTML এর `dir` অ্যাট্রিবিউটের সাথে মিলে ইউনিকোড দ্বি-দিকনির্দেশক (bi-directional) অ্যালগরিদমের আচরণ নিয়ন্ত্রণ করে। এটি টেক্সটের দিক (বাম-থেকে-ডান বা ডান-থেকে-বাম) সঠিকভাবে রেন্ডার করতে সাহায্য করে, বিশেষত মিশ্র ভাষার কন্টেন্টের জন্য।
    ```css
    .mixed-language-text {
        unicode-bidi: embed; /* একটি নতুন দ্বি-দিকনির্দেশক স্তর তৈরি করে */
    }
    .override-direction {
        unicode-bidi: bidi-override;
        direction: rtl; /* টেক্সট কঠোরভাবে ডান থেকে বামে দেখাবে, অক্ষরের স্বাভাবিক দিক উপেক্ষা করে */
    }
    ```
    **ব্যাখ্যা:** এটি একটি অ্যাডভান্সড প্রপার্টি এবং সাধারণত HTML `dir` অ্যাট্রিবিউট ও `bdo` এলিমেন্ট ব্যবহার করাই যথেষ্ট।

324. **`user-select`**: ব্যবহারকারী পৃষ্ঠার টেক্সট সিলেক্ট বা নির্বাচন করতে পারবে কিনা তা নিয়ন্ত্রণ করে (`auto` (ডিফল্ট), `none`, `text`, `all`)। (আপনার তালিকায় `user od` ছিল, সঠিক প্রপার্টি `user-select`)
    ```css
    .non-selectable-text {
        user-select: none; /* এই টেক্সট সিলেক্ট করা যাবে না */
        -webkit-user-select: none; /* পুরনো ব্রাউজারের জন্য */
        -ms-user-select: none;
    }
    .code-snippet {
        user-select: all; /* এক ক্লিকে পুরো কোড সিলেক্ট হবে */
    }
    ```

325. **`vertical-align`**: একটি ইনলাইন বা টেবিল-সেল এলিমেন্টের উল্লম্ব সারিবদ্ধকরণ (vertical alignment) তার লাইনের সাপেক্ষে বা টেবিল সেলের সাপেক্ষে নির্ধারণ করে।
    ```css
    img.align-middle {
        vertical-align: middle; /* ছবিটি তার চারপাশের টেক্সটের মাঝখানে সারিবদ্ধ হবে */
    }
    span.superscript-style {
        vertical-align: super; /* সুপারস্ক্রিপ্টের মতো দেখাবে */
        font-size: smaller;
    }
    td.cell-top-align {
        vertical-align: top; /* টেবিল সেলের কন্টেন্ট উপরে সারিবদ্ধ হবে */
    }
    /* মান হতে পারে: baseline (ডিফল্ট), sub, super, top, text-top, middle, bottom, text-bottom, <length>, <percentage> */
    ```

326. **`visibility`**: একটি এলিমেন্ট দৃশ্যমান (`visible`, ডিফল্ট) হবে নাকি অদৃশ্য (`hidden`) থাকবে তা নির্ধারণ করে। `hidden` করলে এলিমেন্টটি জায়গা ধরে রাখে ( `display: none` এর মতো জায়গা ছেড়ে দেয় না)। `collapse` মান টেবিল সারি/কলামের জন্য ব্যবহৃত হয়।
    ```css
    .invisible-element {
        visibility: hidden; /* এলিমেন্ট অদৃশ্য, কিন্তু লেআউটে জায়গা নেবে */
    }
    .conditionally-visible {
        visibility: visible;
    }
    ```

327. **`white-space`**: একটি এলিমেন্টের ভেতরে হোয়াইটস্পেস (স্পেস, ট্যাব, নতুন লাইন) কীভাবে আচরণ করবে তা নির্ধারণ করে।
    ```css
    pre.code-block-ws {
        white-space: pre; /* হোয়াইটস্পেস ও নতুন লাইন যেমন আছে তেমন দেখাবে */
    }
    .no-wrap-text {
        white-space: nowrap; /* টেক্সট এক লাইনে থাকবে, মোড়াবে না */
        overflow: hidden; text-overflow: ellipsis; width: 100px;
    }
    .pre-wrap-text {
        white-space: pre-wrap; /* হোয়াইটস্পেস সংরক্ষিত থাকবে, কিন্তু প্রয়োজনে লাইন মোড়াবে */
    }
    /* অন্যান্য মান: normal (ডিফল্ট), pre-line, break-spaces */
    ```

328. **`widows`**: প্রিন্ট করার সময় একটি প্যারাগ্রাফের প্রথম অংশ (widow lines) আগের পেজের শেষে একা কতগুলো লাইন থাকতে পারবে তার সর্বনিম্ন সংখ্যা নির্ধারণ করে।
    ```css
    p.avoid-widows {
        widows: 3; /* আগের পেজের শেষে কমপক্ষে ৩টি লাইন থাকতে হবে, নতুবা পরের পেজে ব্রেক হবে */
    }
    ```
    **ব্যাখ্যা:** এটি মূলত প্রিন্ট লেআউটের জন্য।

329. **`width`**: একটি এলিমেন্টের কন্টেন্ট এলাকার প্রস্থ নির্ধারণ করে।
    ```css
    .fixed-width-div {
        width: 300px; /* ডিভের প্রস্থ ৩০০ পিক্সেল */
        background-color: #fafafa; border: 1px solid #ccc;
    }
    img.responsive-image {
        width: 100%; /* প্যারেন্ট কন্টেইনারের পুরো প্রস্থ নেবে */
        max-width: 600px; /* তবে ৬০০ পিক্সেলের বেশি চওড়া হবে না */
        height: auto; /* উচ্চতা অনুপাত অনুযায়ী সমন্বিত হবে */
    }
    ```

330. **`will-change`**: ব্রাউজারকে আগে থেকে জানিয়ে দেয় যে একটি নির্দিষ্ট প্রপার্টি ভবিষ্যতে পরিবর্তিত হতে পারে, যাতে ব্রাউজার সেই পরিবর্তনের জন্য অপটিমাইজেশন করতে পারে। এটি অ্যানিমেশন বা ট্রানজিশনের পারফরম্যান্স উন্নত করতে পারে।
    ```css
    .animated-element {
        will-change: transform, opacity; /* ব্রাউজারকে জানানো হচ্ছে যে transform এবং opacity প্রপার্টি পরিবর্তিত হবে */
        transition: transform 0.5s, opacity 0.5s;
    }
    .animated-element:hover {
        transform: scale(1.2);
        opacity: 0.8;
    }
    ```
    **গুরুত্বপূর্ণ:** এই প্রপার্টিটি অতিরিক্ত ব্যবহার করলে পারফরম্যান্স খারাপ হতে পারে। শুধুমাত্র যখন প্রয়োজন তখনই ব্যবহার করুন।

331. **`word-break`**: খুব লম্বা শব্দ বা অবিচ্ছিন্ন স্ট্রিং (যেমন URL) কীভাবে লাইন ভাঙবে তা নির্ধারণ করে।
    ```css
    .break-all-words {
        width: 150px; border: 1px solid; padding: 5px;
        word-break: break-all; /* যেকোনো অক্ষরের পর শব্দ ভাঙতে পারে (CJK ভাষার জন্য উপযোগী) */
    }
    .keep-all-words {
        width: 150px; border: 1px solid; padding: 5px;
        word-break: keep-all; /* শব্দ ভাঙবে না, ওভারফ্লো হতে পারে (CJK ভাষার জন্য) */
    }
    .break-word-deprecated { /* এটি overflow-wrap এর একটি পুরনো নাম */
        /* word-break: break-word; */ /* অপ্রচলিত, overflow-wrap: break-word; ব্যবহার করুন */
    }
    ```

332. **`word-spacing`**: টেক্সটের শব্দগুলোর মধ্যে অতিরিক্ত ফাঁকা জায়গা নির্ধারণ করে ( `letter-spacing` অক্ষরের মধ্যে)।
    ```css
    .expanded-word-spacing {
        word-spacing: 10px; /* শব্দগুলোর মধ্যে ১০ পিক্সেল অতিরিক্ত ফাঁক */
    }
    .condensed-word-spacing {
        word-spacing: -3px; /* শব্দগুলো কাছাকাছি আসবে */
    }
    ```

333. **`writing-mode`**: টেক্সট এবং অন্যান্য ইনলাইন কন্টেন্টের প্রবাহের দিক নির্ধারণ করে (অনুভূমিক বা উল্লম্ব) এবং ব্লক কন্টেন্টের বিন্যাসের দিক নির্ধারণ করে।
    ```css
    .vertical-text-container {
        writing-mode: vertical-rl; /* টেক্সট উল্লম্বভাবে উপর থেকে নিচে, লাইন ডান থেকে বামে যাবে */
        width: 50px; /* উল্লম্ব মোডে এটি উচ্চতা নির্দেশ করতে পারে */
        height: 200px; /* উল্লম্ব মোডে এটি প্রস্থ নির্দেশ করতে পারে */
        border: 1px solid; padding: 5px;
    }
    .horizontal-tb {
        writing-mode: horizontal-tb; /* ডিফল্ট, অনুভূমিকভাবে উপর থেকে নিচে */
    }
    /* অন্যান্য মান: vertical-lr, sideways-rl, sideways-lr */
    ```

334. **`z-index`**: পজিশন করা ( `position` এর মান `static` ছাড়া অন্য কিছু) এলিমেন্টগুলোর স্ট্যাকিং ক্রম (stacking order) বা স্তর নির্ধারণ করে। বেশি `z-index` মানের এলিমেন্ট কম মানের এলিমেন্টের উপরে দেখায়।
 ```css
    .overlay-dialog {
        position: fixed;
        inset: 0;
        background-color: rgba(0,0,0,0.5);
        z-index: 1000; /* অন্য সবকিছুর উপরে দেখানোর জন্য উচ্চ z-index */
    }
    .header-bar {
        position: sticky; top: 0;
        background-color: white;
        z-index: 100; /* ডায়ালগের চেয়ে নিচে, কিন্তু সাধারণ কন্টেন্টের উপরে */
    }
    ```
    **ব্যাখ্যা:** `z-index` শুধুমাত্র পজিশন করা এলিমেন্টের উপর কাজ করে এবং নতুন স্ট্যাকিং কনটেক্সট তৈরি করতে পারে।

```

